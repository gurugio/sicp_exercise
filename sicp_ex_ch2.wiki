== 2.1.scm ==


{{{
(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))

(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))

(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))

(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))

(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))

(define (make-rat n d)
  (let ((g (gcd n d)))
    (if (< d 0) ; denom is always positive, numer can be negative
        (cons (/ (- (abs n)) g) (/ (abs d) g))
        (cons (/ n g) (/ d g)))))

(define (numer x) (car x))
(define (denom x) (cdr x))

(define (print-rat x)
  (display (numer x))
  (display "/")
  (display (denom x))
  (newline))
}}}


== 2.2.scm ==


{{{



(define (make-point x y)
  (cons x y))
(define (x-point point)
  (car point))
(define (y-point point)
  (cdr point))
(define (print-point p)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")")
  (newline))

(define (start-segment segment)
  (car segment))
(define (end-segment segment)
  (car (cdr segment)))
(define (make-segment start-point end-point)
  (list start-point end-point))

(define (midpoint-segment segment)
  (display "(")
  (display (/ (+ (x-point (start-segment segment))
              (x-point (end-segment segment)))
              2))
  (display ",")
  (display (/ (+ (y-point (start-segment segment))
                 (y-point (end-segment segment)))
              2))
  (display ")")
  (newline))
  
}}}


== 2.3.scm ==


{{{


(define (make-point x y)
  (cons x y))
(define (x-point point)
  (car point))
(define (y-point point)
  (cdr point))
(define (print-point p)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")")
  (newline))


(define (start-segment segment)
  (car segment))
(define (end-segment segment)
  (car (cdr segment)))
(define (make-segment start-point end-point)
  (list start-point end-point))
(define (length-segment segment)
  (let ((a (- (x-point (start-segment segment))
              (x-point (end-segment segment))))
        (b (- (y-point (start-segment segment))
              (y-point (end-segment segment)))))
    (+ (* a a) (* b b))))

; make rectangle with two points
(define (make-rectangle left-top-point right-bottom-point)
  (list left-top-point right-bottom-point))

; select vertical segment and horizontal segment
(define (left-point-rectangle rectangle)
  (if (< (x-point (start-segment rectangle))
         (x-point (end-segment rectangle)))
      (start-segment rectangle)
      (end-segment rectangle)))
(define (right-point-rectangle rectangle)
  (if (< (x-point (start-segment rectangle))
         (x-point (end-segment rectangle)))
      (end-segment rectangle)
      (start-segment rectangle)))
(define (bottom-point-rectangle rectangle)
  (if (< (y-point (start-segment rectangle))
         (y-point (end-segment rectangle)))
      (start-segment rectangle)
      (end-segment rectangle)))
(define (top-point-rectangle rectangle)
  (if (< (y-point (start-segment rectangle))
         (y-point (end-segment rectangle)))
      (end-segment rectangle)
      (start-segment rectangle)))

; select high and width
(define (high-rectangle rectangle)
  (- (y-point (top-point-rectangle rectangle))
     (y-point (bottom-point-rectangle rectangle))))
(define (width-rectangle rectangle)
  (- (x-point (top-point-rectangle rectangle))
     (x-point (bottom-point-rectangle rectangle))))

; compute the area and perimeter
(define (area-rectangle rectangle)
  (* (high-rectangle rectangle)
     (width-rectangle rectangle)))
(define (perimeter-rectangle rectangle)
  (+ (* 2 (high-rectangle rectangle))
     (* 2 (width-rectangle rectangle))))
}}}


== 2.4.scm ==


{{{

(define (cons x y)
  (lambda (m) (m x y)))

(define (car z)
  (z (lambda (p q) p)))

(define (cdr z)
  (z (lambda (p q) q)))
}}}


== 2.5.scm ==


{{{

; cons
(define (expt-cons a b)
  (* (expt 2 a) (expt 3 b)))

; get 2^a
(define (two-product expt)
  (if (= 0 (remainder expt 3))
      (two-product (/ expt 3))
      expt))
;get 3^b
(define (three-product expt)
  (if (= 0 (remainder expt 2))
      (three-product (/ expt 2))
      expt))

;get a
(define (two-expo-body num count)
  (if (= 1 (/ num 2))
      count
      (two-expo-body (/ num 2) (+ count 1))))
(define (two-expo num)
  (two-expo-body num 1))

;get b
(define (three-expo-body num count)
  (if (= 1 (/ num 3))
      count
      (three-expo-body (/ num 3) (+ count 1))))
(define (three-expo num)
  (three-expo-body num 1))

; car
(define (expt-car expt)
  (two-expo (two-product expt)))
; cdr
(define (expt-cdr expt)
  (three-expo (three-product expt)))
}}}


== 2.6.scm ==


{{{

; this is zero??
(define zero (lambda (f) (lambda (x) x)))
; If (lambda (x) x) == E1, (lambda (f) (E1)) -> E1
; (lambda (x) x) -> x
; Argument of procedure zero is nothing, therefore x -> nothing
; Finally procedure zero is nothing?

(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))

; Q1) one = (add-1 zero)
;; (add-1 zero)
;; 1. (n f) = (zero f) = ((lambda (f) (lambda (x) x)) f) = (lambda (x) x)
;; 2. ((n f) x) = ((lambda (x) x) x) = x
;; 3. (f ((n f) x)) = (f x)
;; finally, one = (lambda (f) (lambda (x) (f x)))
(define one (lambda (f) (lambda (x) (f x))))

;; Q2) two = (add-1 one)
;; 1. ((n f) x) = ((one f) x) = (f x)
;; 2. (f (n f) x) = (f (f x))
;; finally, two = (lambda (f) (lambda (x) (f (f x))))
(define two (lambda (f) (lambda (x) (f (f x)))))

;;The meaning of Church numerals is the repeat of certain function
((one sqrt) 16) ;; -> (sqrt 16) = 4.0
((two sqrt) 16) ;; -> (sqrt (sqrt 16)) = 2.0


;; I cannot find a direct definition of the +

}}}


== 2.7.scm ==


{{{
(define (make-interval a b) (cons a b))

(define (upper-bound interval) (cdr interval))
(define (lower-bound interval) (car interval))

(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))

(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))

(define (div-interval x y)
  (mul-interval x 
                (make-interval (/ 1.0 (upper-bound y))
                               (/ 1.0 (lower-bound y)))))

;; My solution is following..
;; (define (sub-interval x y)
;;   (make-interval (- (lower-bound x) (upper-bound y))
;;                  (- (upper-bound x) (lower-bound x))))
;; copy from somewhere
(define (sub-interval x y)
  (add-interval x (make-interval (- (upper-bound y)) (- (lower-bound y)))))

(define (width-interval x)
  (/ (- (upper-bound x) (lower-bound x)) 2))

(define (compare-width x y operation)
  (let ((width-x (width-interval x))
        (width-y (width-interval y))
        (width-result (width-interval (operation x y))))
    (cond ((equal? operation add-interval) 
           (display (+ width-x width-y))
           (display "=?")
           (display width-result)
           (newline))
          ((equal? operation sub-interval)
           (display (abs (- width-x width-y)))
           (display "=?")
           (display width-result)
           (newline))
          ((equal? operation mul-interval)
           (display (* width-x width-y))
           (display "=?")
           (display width-result)
           (newline))
          (else (display "fail")))
    ))
}}}


== 2.7-2.9.scm ==


{{{
(define (make-interval a b) (cons a b))

(define (upper-bound interval) (cdr interval))
(define (lower-bound interval) (car interval))

(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))

(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))

(define (div-interval x y)
  (if (or (zero? (upper-bound y)) (zero? (lower-bound y)))
      (display "Error: second interval has zero value\n")
      (mul-interval x
                    (make-interval (/ 1.0 (upper-bound y))
                                   (/ 1.0 (lower-bound y))))))

;; (define (sub-interval x y)
;;   (make-interval (- (lower-bound x) (upper-bound y))
;;                  (- (upper-bound x) (lower-bound x))))
(define (sub-interval x y)
  (add-interval x (make-interval (- (upper-bound y)) (- (lower-bound y)))))

(define (width-interval x)
  (/ (- (upper-bound x) (lower-bound x)) 2))

(define (compare-width x y operation)
  (let ((width-x (width-interval x))
        (width-y (width-interval y))
        (width-result (width-interval (operation x y))))
    (cond ((equal? operation add-interval) 
           (display (+ width-x width-y))
           (display "=?")
           (display width-result)
           (newline))
          ((equal? operation sub-interval)
           (display (abs (- width-x width-y)))
           (display "=?")
           (display width-result)
           (newline))
          ((equal? operation mul-interval)
           (display (* width-x width-y))
           (display "=?")
           (display width-result)
           (newline))
          (else (display "fail")))
    ))
}}}


== 2.7-2.10.scm ==


{{{
(define (make-interval a b) (cons a b))

(define (upper-bound interval) (cdr interval))
(define (lower-bound interval) (car interval))

(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))

(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))

(define (div-interval x y)
  (if (or (zero? (upper-bound y)) (zero? (lower-bound y)))
      (display "Error: second interval has zero value\n")
      (mul-interval x
                    (make-interval (/ 1.0 (upper-bound y))
                                   (/ 1.0 (lower-bound y))))))

;; (define (sub-interval x y)
;;   (make-interval (- (lower-bound x) (upper-bound y))
;;                  (- (upper-bound x) (lower-bound x))))
(define (sub-interval x y)
  (add-interval x (make-interval (- (upper-bound y)) (- (lower-bound y)))))

(define (width-interval x)
  (/ (- (upper-bound x) (lower-bound x)) 2))

(define (compare-width x y operation)
  (let ((width-x (width-interval x))
        (width-y (width-interval y))
        (width-result (width-interval (operation x y))))
    (cond ((equal? operation add-interval) 
           (display (+ width-x width-y))
           (display "=?")
           (display width-result)
           (newline))
          ((equal? operation sub-interval)
           (display (abs (- width-x width-y)))
           (display "=?")
           (display width-result)
           (newline))
          ((equal? operation mul-interval)
           (display (* width-x width-y))
           (display "=?")
           (display width-result)
           (newline))
          (else (display "fail")))
    ))
}}}


== 2.11.scm ==


{{{
(define (make-interval a b) (cons a b))

(define (upper-bound interval) (cdr interval))
(define (lower-bound interval) (car interval))

(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))

; copy from Ken Dyck's Weblog
(define (mul-interval x y)
  (let* ((lx (lower-bound x))
         (ux (upper-bound x))
         (ly (lower-bound y))
         (uy (upper-bound y))
         (pos-lx? (positive? lx))
         (pos-ux? (positive? ux))
         (pos-ly? (positive? ly))
         (pos-uy? (positive? uy)))
    (cond 
      ; lx ux ly uy  example
      ; ----------------------------------
      ;  +  -  +  +  invalid interval
      ;  +  -  +  -  invalid interval
      ;  +  -  -  +  invalid interval
      ;  +  -  -  -  invalid interval
      ((and pos-lx? (not pos-ux?))
       (error "invalid interval" x))

      ;  +  +  +  -  invalid interval
      ;  -  +  +  -  invalid interval
      ;  -  -  +  -  invalid interval
      ((and pos-ly? (not pos-uy?))
       (error "invalid interval" y))
      
      ;  +  +  +  +  (1.2)(2.3) = (2.6) 
      ((and pos-lx? pos-ux? pos-ly? pos-uy?)
       (make-interval (* lx ly) (* ux uy)))
      
      ;  +  +  -  +  (1.2)(-2.3) = (-4.6)
      ((and pos-lx? pos-ux? (not pos-ly?) pos-uy?)
       (make-interval (* ux ly) (* ux uy)))
      
      ;  +  +  -  -  (1.2)(-2.-1) = (-4.-1) 
      ((and pos-lx? pos-ux? (not pos-ly?) (not pos-uy?))
       (make-interval (* ux ly) (* lx uy)))
      
      ;  -  +  +  +  (-1.2)(2.3) = (-3.6)
      ((and (not pos-lx?) pos-ux? pos-ly? pos-uy?)
       (make-interval (* lx uy) (* ux uy)))
      
      ;  -  +  -  +  (-1.2)(-2.3) = (-4.6) *
      ((and (not pos-lx?) pos-ux? (not pos-ly?) pos-uy?)
       (make-interval (min (* lx uy) (* ux ly))
                      (* ux uy)))
      
      ;  -  +  -  -  (-1.2)(-2.-1) = (-4.2)
      ((and (not pos-lx?) pos-ux? (not pos-ly?) (not pos-uy?))
       (make-interval (* ux ly) (* lx ly)))
      
      ;  -  -  +  +  (-2.-1)(2.3) = (-6.-2)
      ((and (not pos-lx?) (not pos-ux?) pos-ly? pos-uy?)
       (make-interval (* lx uy) (* ux ly)))

      ;  -  -  -  +  (-2.-1)(-2.3) = (-6, 4)
      ((and (not pos-lx?) (not pos-ux?) (not pos-ly?) pos-uy?)
       (make-interval (* lx uy) (* lx ly)))

      ;  -  -  -  -  (-2.-1)(-2.-1) = (1.4)
      ((and (not pos-lx?) (not pos-ux?) (not pos-ly?) (not pos-uy?))
       (make-interval (* ux uy) (* lx ly))))))

  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))

(define (div-interval x y)
  (if (or (zero? (upper-bound y)) (zero? (lower-bound y)))
      (display "Error: second interval has zero value\n")
      (mul-interval x
                    (make-interval (/ 1.0 (upper-bound y))
                                   (/ 1.0 (lower-bound y))))))

;; (define (sub-interval x y)
;;   (make-interval (- (lower-bound x) (upper-bound y))
;;                  (- (upper-bound x) (lower-bound x))))
(define (sub-interval x y)
  (add-interval x (make-interval (- (upper-bound y)) (- (lower-bound y)))))

(define (width-interval x)
  (/ (- (upper-bound x) (lower-bound x)) 2))

(define (compare-width x y operation)
  (let ((width-x (width-interval x))
        (width-y (width-interval y))
        (width-result (width-interval (operation x y))))
    (cond ((equal? operation add-interval) 
           (display (+ width-x width-y))
           (display "=?")
           (display width-result)
           (newline))
          ((equal? operation sub-interval)
           (display (abs (- width-x width-y)))
           (display "=?")
           (display width-result)
           (newline))
          ((equal? operation mul-interval)
           (display (* width-x width-y))
           (display "=?")
           (display width-result)
           (newline))
          (else (display "fail")))
    ))


; test cases for handling zero point
(define intv1 (make-interval 0 3))
(define intv2 (make-interval -3 0))
(define intv3 (make-interval -3 -2))
(define intv4 (make-interval 2 3))
(define intv5 (make-interval 0 0))

(mul-interval intv1 intv1)
(mul-interval intv1 intv2)
(mul-interval intv1 intv3)
(mul-interval intv1 intv4)
(mul-interval intv2 intv1)
(mul-interval intv2 intv2)
(mul-interval intv2 intv3)
(mul-interval intv2 intv4)
(mul-interval intv3 intv1)
(mul-interval intv3 intv2)
(mul-interval intv3 intv3)
(mul-interval intv3 intv4)
(mul-interval intv4 intv1)
(mul-interval intv4 intv2)
(mul-interval intv4 intv3)
(mul-interval intv4 intv4)
(mul-interval intv5 intv1)
(mul-interval intv5 intv2)
(mul-interval intv5 intv3)
(mul-interval intv5 intv4)


;; Test result:
;; guile> (0 . 9)
;; guile> (-9 . 0)
;; guile> (-9 . 0)
;; guile> (0 . 9)
;; guile> (-9 . 0)
;; guile> (0 . 9)
;; guile> (0 . 9)
;; guile> (-9 . 0)
;; guile> (-9 . 0)
;; guile> (0 . 9)
;; guile> (4 . 9)
;; guile> (-9 . -4)
;; guile> (0 . 9)
;; guile> (-9 . 0)
;; guile> (-9 . -4)
;; guile> (4 . 9)
}}}


== 2.12.scm ==


{{{
(define (make-interval a b) (cons a b))

(define (upper-bound interval) (cdr interval))
(define (lower-bound interval) (car interval))

(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))

; copy from Ken Dyck's Weblog
(define (mul-interval x y)
  (let* ((lx (lower-bound x))
         (ux (upper-bound x))
         (ly (lower-bound y))
         (uy (upper-bound y))
         (pos-lx? (positive? lx))
         (pos-ux? (positive? ux))
         (pos-ly? (positive? ly))
         (pos-uy? (positive? uy)))
    (cond 
      ; lx ux ly uy  example
      ; ----------------------------------
      ;  +  -  +  +  invalid interval
      ;  +  -  +  -  invalid interval
      ;  +  -  -  +  invalid interval
      ;  +  -  -  -  invalid interval
      ((and pos-lx? (not pos-ux?))
       (error "invalid interval" x))

      ;  +  +  +  -  invalid interval
      ;  -  +  +  -  invalid interval
      ;  -  -  +  -  invalid interval
      ((and pos-ly? (not pos-uy?))
       (error "invalid interval" y))
      
      ;  +  +  +  +  (1.2)(2.3) = (2.6) 
      ((and pos-lx? pos-ux? pos-ly? pos-uy?)
       (make-interval (* lx ly) (* ux uy)))
      
      ;  +  +  -  +  (1.2)(-2.3) = (-4.6)
      ((and pos-lx? pos-ux? (not pos-ly?) pos-uy?)
       (make-interval (* ux ly) (* ux uy)))
      
      ;  +  +  -  -  (1.2)(-2.-1) = (-4.-1) 
      ((and pos-lx? pos-ux? (not pos-ly?) (not pos-uy?))
       (make-interval (* ux ly) (* lx uy)))
      
      ;  -  +  +  +  (-1.2)(2.3) = (-3.6)
      ((and (not pos-lx?) pos-ux? pos-ly? pos-uy?)
       (make-interval (* lx uy) (* ux uy)))
      
      ;  -  +  -  +  (-1.2)(-2.3) = (-4.6) *
      ((and (not pos-lx?) pos-ux? (not pos-ly?) pos-uy?)
       (make-interval (min (* lx uy) (* ux ly))
                      (* ux uy)))
      
      ;  -  +  -  -  (-1.2)(-2.-1) = (-4.2)
      ((and (not pos-lx?) pos-ux? (not pos-ly?) (not pos-uy?))
       (make-interval (* ux ly) (* lx ly)))
      
      ;  -  -  +  +  (-2.-1)(2.3) = (-6.-2)
      ((and (not pos-lx?) (not pos-ux?) pos-ly? pos-uy?)
       (make-interval (* lx uy) (* ux ly)))

      ;  -  -  -  +  (-2.-1)(-2.3) = (-6, 4)
      ((and (not pos-lx?) (not pos-ux?) (not pos-ly?) pos-uy?)
       (make-interval (* lx uy) (* lx ly)))

      ;  -  -  -  -  (-2.-1)(-2.-1) = (1.4)
      ((and (not pos-lx?) (not pos-ux?) (not pos-ly?) (not pos-uy?))
       (make-interval (* ux uy) (* lx ly))))))

  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))

(define (div-interval x y)
  (if (or (zero? (upper-bound y)) (zero? (lower-bound y)))
      (display "Error: second interval has zero value\n")
      (mul-interval x
                    (make-interval (/ 1.0 (upper-bound y))
                                   (/ 1.0 (lower-bound y))))))

;; (define (sub-interval x y)
;;   (make-interval (- (lower-bound x) (upper-bound y))
;;                  (- (upper-bound x) (lower-bound x))))
(define (sub-interval x y)
  (add-interval x (make-interval (- (upper-bound y)) (- (lower-bound y)))))

(define (width-interval x)
  (/ (- (upper-bound x) (lower-bound x)) 2))

(define (compare-width x y operation)
  (let ((width-x (width-interval x))
        (width-y (width-interval y))
        (width-result (width-interval (operation x y))))
    (cond ((equal? operation add-interval) 
           (display (+ width-x width-y))
           (display "=?")
           (display width-result)
           (newline))
          ((equal? operation sub-interval)
           (display (abs (- width-x width-y)))
           (display "=?")
           (display width-result)
           (newline))
          ((equal? operation mul-interval)
           (display (* width-x width-y))
           (display "=?")
           (display width-result)
           (newline))
          (else (display "fail")))
    ))


(define (make-center-percent center percent)
  (make-interval (- center (* center (/ percent 100)))
                 (+ center (* center (/ percent 100)))))

(define (center interval)
  (/ (+ (upper-bound interval) (lower-bound interval)) 2))

(define (percent interval)
  (* (/ (- (upper-bound interval) (center interval))
        (center interval))
     100))
}}}


== 2.14.scm ==


{{{
;=========== 2.14 =====================
(define (make-center-percent c p)
  (let ((ratio (* c (/ p 100))))
    (make-interval (- c ratio) (+ c ratio))
    )
  )

(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2)
  )

(define (percent p)
  (* 100 (/ (- (upper-bound p) (center p))))
  )

(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y)))
  )

(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
        (make-interval (min p1 p2 p3 p4)
                       (max p1 p2 p3 p4)))
  )

(define (div-interval x y)
  (mul-interval x
                (make-interval (/ 1.0 (upper-bound y))
                               (/ 1.0 (lower-bound y))))
  )


(define (make-interval a b) (cons a b))

(define (upper-bound x) (cdr x))
(define (lower-bound x) (car x))


(define (sub-interval x y)
  (let ((p1 (- (lower-bound x) (lower-bound y)))
        (p2 (- (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2)
                   (max p1 p2)))
  )

(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))

(define (par2 r1 r2)
  (let ((one (make-interval 1 1)))
    (div-interval one
                  (add-interval (div-interval one r1)
                                (div-interval one r2)))))


(div-interval (make-center-percent 10 0.01) (make-center-percent 10 0.01))
;(9.99 10.01) / (9.99 10.01) 을 계산기로 계산하면 (0.998001 1.002002)로 계산되지만
;실행결과는 (0.9998000199980004 . 1.000200020002) 이다.
;결국 원래는 0.2%의 오차를 가져야 하는 범위 값이 0.02%의 오차를 가진다고 계산되버린다.

}}}


== 2.17.scm ==


{{{

(define (last-pair lst)
  (if (null? (cdr lst))
      lst
      (last-pair (cdr lst))))

(define (reverse lst)
  (if (null? (cdr lst))
      lst
      (append (reverse (cdr lst)) (list (car lst)))))
}}}


== 2.17-2.18.scm ==


{{{

(define (last-pair lst)
  (if (null? (cdr lst))
      lst
      (last-pair (cdr lst))))

(define (reverse lst)
  (if (null? (cdr lst))
      lst
      (append (reverse (cdr lst)) (list (car lst)))))
}}}


== 2.19.scm ==


{{{

(define (count-change amount)
  (cc amount us-coins))

(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount (except-first-denomination coin-values))
            (cc (- amount (first-denomination coin-values))
                coin-values)))))

(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))

(define (no-more? values)
  (null? values))

(define (except-first-denomination values)
  (cdr values))

(define (first-denomination values)
  (car values))
}}}


== 2.20.scm ==


{{{

(define (same-parity a . b)
  (if (even? a) (even-numbers (cons a b))
      (odd-numbers (cons a b))))

(define (even-numbers numbers)
  (cond ((null? numbers) '())
        ((even? (car numbers))
         (append (list (car numbers)) (even-numbers (cdr numbers))))
        (else
         (append (even-numbers (cdr numbers))))))

(define (odd-numbers numbers)
  (cond ((null? numbers) '())
        ((odd? (car numbers))
         (append (list (car numbers)) (odd-numbers (cdr numbers))))
        (else
         (append (odd-numbers (cdr numbers))))))

}}}


== 2.21.scm ==


{{{
(define (square-list-recur items)
  (if (null? items)
      '()
      (cons (* (car items) (car items)) (square-list (cdr items)))))
(define (square-list-map items)
  (map (lambda (x) (* x x)) items))
}}}


== 2.22.scm ==


{{{
;; (define (square-list items)
;;   (define (iter things answer)
;;     (if (null? things)
;;         answer
;;         (iter (cdr things) 
;;               (cons (square (car things)) -> new item is located first
;;                     answer))))
;;   (iter items nil))

;; (define (square-list items)
;;   (define (square x) (* x x))
;;   (define (iter things answer)
;;     (if (null? things)
;;         answer
;;         (iter (cdr things)
;;               (cons answer -> (cons list atom) is not plain list
;;                     (square (car things))))))
;;   (iter items nil))

(define (square-list items)
  (define (square x) (* x x))
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (append answer
                    (list (square (car things)))))))
  (iter items nil))
}}}


== 2.23.scm ==


{{{

(define (for-each proc lst)
  (cond ((not (null? lst))
         (proc (car lst))
         (for-each proc (cdr lst)))))
        
}}}


== 2.24.scm ==


{{{
;=============== 2.24 ================
(define 2-24 (list 1 (list 2 (list 3 4))))
}}}


== 2.25.scm ==


{{{
(define ex1 (list 1 3 (list 5 7) 9))
(define ex2 (list (list 7)))
(define ex3 (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7)))))))

(define (find-seven tree)
  (display tree) (newline)
  (cond ((null? tree))
        ((and (number? tree) (equal? tree 7)) (display "found"))
        ((list? tree)
         (find-seven (car tree)) (find-seven (cdr tree)))))

(car (cdr (car (cdr (cdr ex1)))))
(car (car ex2))
(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr ex3))))))))))))
}}}


== 2.27.scm ==


{{{

(define (reverse lst)
  (if (and (list? lst) (not (null? lst)))
      (append (reverse (cdr lst)) (list (car lst)))
      lst))

(define (deep-reverse lst)
  (display lst) (newline)
  (if (and (list? lst) (not (null? lst)))
      (append (deep-reverse (cdr lst)) (list (deep-reverse (car lst))))
      lst))
}}}


== 2.28.scm ==


{{{
(define x '(((1 2) 3) (4 (5 6))))


;; (define (fringe-body tree result)
;;   (cond ((null? tree) result)
;;         ((list? tree)
;;          (fringe-body (car tree)
;;                       (fringe-body (cdr tree) result)))
;;         (else (cons tree result))))

;; (define (fringe tree)
;;   (fringe-body tree '()))


(define (fringe tree)
  (cond ((null? tree) '())
        ((not (pair? tree)) (list tree))
        (else (append (fringe (car tree))
                      (fringe (cdr tree))))))


(fringe x)


(define (pre-travel tree)
;  (display tree) (newline)
  (cond ((null? tree))
        ((list? tree)
         (pre-travel (car tree))
         (pre-travel (cdr tree)))
        (else (display tree))))


}}}


== 2.29.d.scm ==


{{{
(define (make-mobile left right)
  (cons left right))
(define (make-branch length structure)
  (cons length structure))

(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (cdr mobile))  ; change

(define (branch-length branch)
  (car branch))
(define (branch-structure branch)
  (cdr branch))  ; change


(define x '(((1 . 2) . (3 . 4)) . ((5 . 6) . (7 . 8))))  ; change

(define (terminal-branch? branch)
  (not (pair? (cdr branch)))) ; list?->pair?

(define (total-weight mobile)
  (cond ((null? mobile) 0)
        ((terminal-branch? mobile) 
         (branch-structure mobile))
        (else
         (+ (total-weight (left-branch mobile))
            (total-weight (right-branch mobile))))))

(define (branch-torque branch)
  (* (branch-length branch) (branch-structure branch)))

(define (mobile-torque mobile)
  (cond ((null? mobile) 0)
        ((terminal-branch? mobile) (branch-torque mobile))
        (else
         (+ (mobile-torque (left-branch mobile))
            (mobile-torque (right-branch mobile))))))

(define (balanced-mobile? mobile)
  (equal? (mobile-torque (left-branch mobile))
          (mobile-torque (right-branch mobile))))



}}}


== 2.29.scm ==


{{{
(define (make-mobile left right)
  (list left right))
(define (make-branch length structure)
  (list length structure))

(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (car (cdr mobile)))

(define (branch-length branch)
  (car branch))
(define (branch-structure branch)
  (car (cdr branch)))

(define (terminal-branch? branch)
  (not (list? (car branch))))

(define x '(((1 2) (3 4)) ((5 6) (7 8))))

(define (total-weight mobile)
  (cond ((null? mobile) 0)
        ((terminal-branch? mobile) 
         (display (cdr mobile)) (branch-structure mobile))
        (else
         (+ (total-weight (left-branch mobile))
            (total-weight (right-branch mobile))))))

(define (branch-torque branch)
  (* (branch-length branch) (branch-structure branch)))

(define (mobile-torque mobile)
  (cond ((null? mobile) 0)
        ((terminal-branch? mobile) (branch-torque mobile))
        (else
         (+ (mobile-torque (left-branch mobile))
            (mobile-torque (right-branch mobile))))))

(define (balanced-mobile? mobile)
  (equal? (mobile-torque (left-branch mobile))
          (mobile-torque (right-branch mobile))))



}}}


== 2.30.scm ==


{{{
(define (square-tree tree)
  (cond ((null? tree) '())
        ((not (pair? tree)) (* tree tree))
        (else 
         (cons (square-tree (car tree))
               (square-tree (cdr tree))))))

(define (square-tree-with-map tree)
  (map (lambda (sub-tree)
         (if (pair? sub-tree) (square-tree-with-map sub-tree)
             (* sub-tree sub-tree)))
       tree))


(square-tree '(1 (2 (3 4) 5) (6 7)))
(square-tree-with-map '(1 (2 (3 4) 5) (6 7)))


}}}


== 2.31.scm ==


{{{


(define (square x) (* x x))

(define (tree-map procedure tree)
  (map (lambda (sub-tree)
         (if (pair? sub-tree) (tree-map procedure sub-tree)
             (procedure sub-tree)))
       tree))

(define (square-tree tree) (tree-map square tree))

(square-tree '(1 (2 (3 4) 5) (6 7)))
}}}


== 2.32.scm ==


{{{
(define (subsets s)
  (if (null? s)
      (list '())
      (let ((rest (subsets (cdr s))))
        (append rest (map (lambda (x) (cons (car s) x)) rest)))))

(subsets '(1 2 3 4))




}}}


== 2.33.scm ==


{{{
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (map-ex p sequence)
  (accumulate (lambda (x y) (cons (p x) y)) '() sequence))

(define (square x)
  (* x x))
(define (append-ex seq1 seq2)
  (accumulate cons seq2 seq1))
(define (length-ex sequence)
  (accumulate (lambda (x y) (+ 1 y)) 0 sequence))
}}}


== 2.34.scm ==


{{{
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (honer-eval x coefficient-sequence)
  (accumulate 
   (lambda (this-coeff higher-terms) 
     (+ this-coeff (* x higher-terms)))
   0
   coefficient-sequence))

(honer-eval 2 '(1 3 1 5 1 1))












                      
}}}


== 2.35.scm ==


{{{
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (enumerate-tree tree)
  (cond ((null? tree) '())
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))

(define (count-leaves t)
  (accumulate +
              0
              (map (lambda (x) 1) (enumerate-tree t))))

(count-leaves '((((1 2) (3 4))) ((5 6))))

;; copy from solution of scheme-wiki
;; I don't understand this
(define (count-leaves-recursive t) 
  (accumulate + 0 (map (lambda (node) 
                         (if (pair? node) 
                             (count-leaves-recursive node) 
                             1)) 
                       t))) 

(count-leaves-recursive '((((1 2) (3 4))) ((5 6))))
}}}


== 2.36.scm ==


{{{
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      '()
      (cons (accumulate op init (map (lambda (x) (car x)) seqs))
            (accumulate-n op init (map (lambda (x) (cdr x)) seqs))
            )))

(define s '((1 2 3) (4 5 6) (7 8 9) (10 11 12)))
(accumulate-n + 0 s)
}}}


== 2.37.scm ==


{{{
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      '()
      (cons (accumulate op init (map (lambda (x) (car x)) seqs))
            (accumulate-n op init (map (lambda (x) (cdr x)) seqs))
            )))

(define v1 '((1 2 3 4) (4 5 6 7) (6 7 8 9)))
(define v2 '((10 20 30 40) (40 50 60 70) (60 70 80 90)))


(define (dot-product v w)
  (accumulate + 0 (map * v w)))

(define (matrix-*-vector m v)
  (map (lambda (x) (dot-product x v)) m))
(define (transpose mat)
  (accumulate-n (lambda (a b) (cons a b)) '() mat))
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map (lambda (mi) (matrix-*-vector n mi)) m)))

(dot-product (car v1) (car v2))
(matrix-*-vector v1 (car v1))
(transpose v1)
(transpose v2)
(matrix-*-matrix v1 v2)
}}}


== 2.38.scm ==


{{{
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define fold-right accumulate)

(fold-right / 1 (list 1 2 3))
(fold-left / 1 (list 1 2 3))
(fold-right list '() (list 1 2 3))
(fold-left list '() (list 1 2 3))

(fold-right + 1 (list 1 2 3))
(fold-left + 1 (list 1 2 3))
(fold-right * 1 (list 1 2 3))
(fold-left * 1 (list 1 2 3))
}}}


== 2.39.scm ==


{{{
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define fold-right accumulate)

(define s '(1 2 3 4 5))

(define (reverse-ex sequence)
  (fold-right (lambda (x y) (append y (list x))) '() sequence))
(reverse-ex s)

(define (reverse-ex2 sequence)
  (fold-left (lambda (x y) (cons y x)) '() sequence))
(reverse-ex2 s)
}}}


== 2.40.scm ==


{{{

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (enumerate-interval low high)
  (if (> low high)
      '()
      (cons low (enumerate-interval (+ low 1) high))))

(define (filter predicate sequence)
  (cond ((null? sequence) '())
        ((predicate (car sequence))
         (cons (car sequence) (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
                    
(define (flatmap proc seq)
  (accumulate append '() (map proc seq)))

(flatmap (lambda (i)
           (map (lambda (j) (list i j))
                (enumerate-interval 1 (- i 1))))
         (enumerate-interval 1 10))


(define (check-no-zero num-list)
;  (display num-list) (newline)
  (cond ((null? num-list) #t)
        ((= (car num-list) 0) #f)
        (else  (check-no-zero (cdr num-list)))))
(check-no-zero '(1 2 3))
(check-no-zero '(1 0 2))

(define (prime? n)
  (check-no-zero 
   (map (lambda (i) (remainder n i)) (enumerate-interval 2 (- n 1)))))

(prime? 2)
(prime? 3)
(prime? 4)
(prime? 5)
(prime? 6)
(prime? 7)
(prime? 8)
(prime? 9)
(prime? 10)

(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))

(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))

(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
               (flatmap
                (lambda (i)
                  (map (lambda (j) (list i j))
                       (enumerate-interval 1 (- i 1))))
                (enumerate-interval 1 n)))))

(prime-sum-pairs 4)

(define (unique-pairs n)
  (flatmap (lambda (i)
             (map (lambda (j) (list i j))
                  (enumerate-interval 1 (- i 1))))
         (enumerate-interval 1 n)))

(unique-pairs 4)


(define (prime-sum-pairs-ex n)
  (map make-pair-sum
       (filter prime-sum?
               (unique-pairs n))))

(prime-sum-pairs-ex 4)
}}}


== 2.41.scm ==


{{{

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (enumerate-interval low high)
  (if (> low high)
      '()
      (cons low (enumerate-interval (+ low 1) high))))

(define (filter predicate sequence)
  (cond ((null? sequence) '())
        ((predicate (car sequence))
         (cons (car sequence) (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
                    
(define (flatmap proc seq)
  (accumulate append '() (map proc seq)))

(flatmap (lambda (i)
           (map (lambda (j) (list i j))
                (enumerate-interval 1 (- i 1))))
         (enumerate-interval 1 10))


(define (check-no-zero num-list)
;  (display num-list) (newline)
  (cond ((null? num-list) #t)
        ((= (car num-list) 0) #f)
        (else  (check-no-zero (cdr num-list)))))
(check-no-zero '(1 2 3))
(check-no-zero '(1 0 2))

(define (prime? n)
  (check-no-zero 
   (map (lambda (i) (remainder n i)) (enumerate-interval 2 (- n 1)))))

(prime? 2)
(prime? 3)
(prime? 4)
(prime? 5)
(prime? 6)
(prime? 7)
(prime? 8)
(prime? 9)
(prime? 10)

(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))

(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))

(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
               (flatmap
                (lambda (i)
                  (map (lambda (j) (list i j))
                       (enumerate-interval 1 (- i 1))))
                (enumerate-interval 1 n)))))

(prime-sum-pairs 4)

(define (unique-pairs n)
  (flatmap (lambda (i)
             (map (lambda (j) (list i j))
                  (enumerate-interval 1 (- i 1))))
         (enumerate-interval 1 n)))

(unique-pairs 4)


(define (prime-sum-pairs-ex n)
  (map make-pair-sum
       (filter prime-sum?
               (unique-pairs n))))

(prime-sum-pairs-ex 4)


(define (generate-triple max)
  (flatmap (lambda (i) ; first number 
             (flatmap (lambda (j) ; second number
                        (map (lambda (k) (list i j k)) ; 3rd number
                             (enumerate-interval 1 i))) ; 3rd number pool
                      (enumerate-interval 1 i))) ; second number pool
           (enumerate-interval 1 max))) ; first number pool

(generate-triple 5)

(define (ex2-41 n s)
  (filter (lambda (t) 
            (if (= (+ (car t) (cadr t) (caddr t)) s) #t
                #f))
          (generate-triple n)))
(ex2-41 5 10)
}}}


== 2.42.scm ==


{{{

;;------------------------------------------------
;;
;; I failed to solve 2.32!
;; This code is not working.
;;
;;------------------------------------------------


(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (enumerate-interval low high)
  (if (> low high)
      '()
      (cons low (enumerate-interval (+ low 1) high))))

(define (filter predicate sequence)
  (cond ((null? sequence) '())
        ((predicate (car sequence))
         (cons (car sequence) (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
                    
(define (flatmap proc seq)
  (accumulate append '() (map proc seq)))

(define (check-no-zero num-list)
  (cond ((null? num-list) #t)
        ((= (car num-list) 0) #f)
        (else  (check-no-zero (cdr num-list)))))

(define (prime? n)
  (check-no-zero 
   (map (lambda (i) (remainder n i)) (enumerate-interval 2 (- n 1)))))

(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))

(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))

(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
               (flatmap
                (lambda (i)
                  (map (lambda (j) (list i j))
                       (enumerate-interval 1 (- i 1))))
                (enumerate-interval 1 n)))))

(define (unique-pairs n)
  (flatmap (lambda (i)
             (map (lambda (j) (list i j))
                  (enumerate-interval 1 (- i 1))))
         (enumerate-interval 1 n)))


(define (prime-sum-pairs-ex n)
  (map make-pair-sum
       (filter prime-sum?
               (unique-pairs n))))

;;================  ex2.42 ===================

(define success-case '((0 5) (1 2) (2 0) (3 6) (4 4) (5 7) (6 1) (7 3)))
(define fail-case1 '((0 5) (1 2) (1 0) (3 6) (4 4) (5 7) (6 1) (7 3)))
(define fail-case2 '((0 5) (1 2) (2 0) (2 6) (4 4) (5 7) (6 1) (7 3)))

 
(define (adjoin-position new-row new-col other-queens)
  (cons (list new-row new-col) other-queens))

(adjoin-position 3 4 '((1 2) (2 2) (3 3)))

(define empty-board '())

(define (equal-value? value other-values)
  (cond ((null? other-values) #f)
        ((= value (car other-values)) #t)
        (else (equal-value? value (cdr other-values)))))
(equal-value? 3 '(1 2 4 5 6))
(equal-value? 3 '(1 2 3 4 5))

(define (all-different-value? values)
  (cond ((null? values) #t)
        ((equal-value? (car values) (cdr values)) #f)
        (else (all-different-value? (cdr values)))))
(all-different-value? '(1 2 3 4 5))
(all-different-value? '(1 2 3 3 5))

(define (safe-row? board-size queens)
  (let ((row-list (map (lambda (pair) (car pair)) queens)))
    (all-different-value? row-list)))
(safe-row? 8 success-case)

(define (same-diagonal? queen1 queen2)
  (= (abs (- (car queen1) (car queen2)))
          (abs (- (cadr queen1) (cadr queen2)))))
(same-diagonal? '(1 2) '(4 5))
(same-diagonal? '(4 5) '(1 2))
(same-diagonal? '(1 2) '(4 3))

(define (safe-diagonal? board-size queens)
  (cond ((null? queens) #t)
        ((same-diagonal? (car queens) (cadr queens)) #f)
        (else (safe-diagonal? board-size queens))))
(safe-diagonal? 8 success-case)

(define (safe? board-size queens)
  (and (safe-row? board-size queens)
       (safe-diagonal? board-size queens)))

(define (queens board-size)
  (define (queen-cols k)  
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
}}}


== 2.44.scm ==


{{{
(define (flipped-pairs painter)
  (let ((painter2 (beside painter (flip-vert painter))))
    (below painter2 painter2)))

(define (right-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (right-split painter (- n 1))))
        (beside painter (below smaller smaller)))))

(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ((up (up-split painter (- n 1)))
            (right (right-split painter (- n 1))))
        (let ((top-left (beside up up))
              (botton-right (below right right))
              (corner (corner-split painter (- n 1))))
          (beside (below painter top-left)
                  (below bottom-right corner))))))

(define (square-limit painter n)
  (let ((quarter (corner-split painter n)))
    (let ((half (deside (flip-horiz quarter) quarter)))
      (below (flip-vert half) half))))

(define (up-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (up-split painter (- n 1))))
        (below painter (beside smaller smaller)))))

              
            
}}}


== 2.53.scm ==


{{{

(define (memq item x)
  (cond ((null? x) #f)
        ((eq? item (car x)) x)
        (else (memq item (cdr x)))))

(list 'a 'b 'c)
(list (list 'george))
(cdr '((x1 x2) (y1 y2)))
(cadr '((x1 x2) (y1 y2)))
(pair? (car '(a short list)))
(memq 'red '((red shoes) (blue socks)))
(memq 'red '(red shoes blue socks))
}}}


== 2.54.scm ==


{{{



(define (equal-ex? list1 list2)
  (cond ((and (null? list1) (null? list2)) #t)
        ((and (pair? (car list1)) (pair? (car list2)))
         (and (equal-ex? (car list1) (car list2))
              (equal-ex? (cdr list1) (cdr list2))))
        ((not (eq? (car list1) (car list2))) #f)
        (else (equal-ex? (cdr list1) (cdr list2)))))

(equal-ex? '(this is a list1) '(this is a list2))
(equal-ex? '(this is a list1) '(this is a list1))
(equal-ex? '(this is a list1) '(this (is a) list1))
(equal-ex? '(this (is a) list1) '(this (is the) list1))
(equal-ex? '(this is a list1) '(this (is a) list1))
(equal-ex? '(this (is a) list1) '(this (is a) list1))
(equal-ex? '(this (is (a or the)) list1) '(this (is (a or the)) list1))
(equal-ex? '(this (is (a or the)) list1) '(this (is (an or the)) list1))
}}}


== 2.56.scm ==


{{{
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
;;(define (make-sum a1 a2) (list '+ a1 a2))
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list '+ a1 a2))))
(define (=number? exp num)
  (and (number? exp) (= exp num)))

;;(define (make-product m1 m2) (list '* m1 m2))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))

(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))
(define (addend s) (cadr s))
(define (augend s) (caddr s))
(define (product? x)
  (and (pair? x) (eq? (car x) '*)))
(define (multiplier p) (cadr p))
(define (multiplicand p) (caddr p))

(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(* (* x y) (+ x 3)) 'x)


;;---- ex 2.56 ---------
(define (exponentiation? exp)
  (and (pair? exp) (eq? (car exp) '**)))
(define (base s) (cadr s))
(define (exponent s) (caddr s))
(define (make-exponentiation b e)
  (cond ((=number? e 0) 1)
        ((=number? e 1) b)
        ((and (number? b) (number? e)) (expt b e))
        (else (list '** b e))))

(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        ((exponentiation? exp)
         (make-product
          (make-product (exponent exp)
                        (make-exponentiation (base exp)
                                             (- (exponent exp) 1)))
          (deriv (base exp) var)))
        (else
         (error "unknown expression type -- DERIV" exp))))

(exponentiation? '(** x 3))
(base '(** x 3))
(exponent '(** x 3))
(make-exponentiation 'x 3)
(deriv '(** x 3) 'x)
(deriv '(** y 3) 'x)
(deriv '(** 3 3) 'x)
;;(deriv '(** x y) 'x) exponent must be the number
(deriv '(** x 0) 'x)
(deriv '(** x 1) 'x)

}}}


== 2.57.scm ==


{{{
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
;;(define (make-sum a1 a2) (list '+ a1 a2))
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list '+ a1 a2))))
(define (=number? exp num)
  (and (number? exp) (= exp num)))

;;(define (make-product m1 m2) (list '* m1 m2))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))


(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))
(define (addend s) (cadr s))
;;(define (augend s) (caddr s))

(define (product? x)
  (and (pair? x) (eq? (car x) '*)))
(define (multiplier p) (cadr p))

;;(define (multiplicand p) (caddr p))


(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(* (* x y) (+ x 3)) 'x)

(define (exponentiation? exp)
  (and (pair? exp) (eq? (car exp) '**)))
(define (base s) (cadr s))
(define (exponent s) (caddr s))
(define (make-exponentiation b e)
  (cond ((=number? e 0) 1)
        ((=number? e 1) b)
        ((and (number? b) (number? e)) (expt b e))
        (else (list '** b e))))

(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        ((exponentiation? exp)
         (make-product
          (make-product (exponent exp)
                        (make-exponentiation (base exp)
                                             (- (exponent exp) 1)))
          (deriv (base exp) var)))
        (else
         (error "unknown expression type -- DERIV" exp))))

(exponentiation? '(** x 3))
(base '(** x 3))
(exponent '(** x 3))
(make-exponentiation 'x 3)
(deriv '(** x 3) 'x)
(deriv '(** y 3) 'x)
(deriv '(** 3 3) 'x)
;;(deriv '(** x y) 'x) exponent must be the number
(deriv '(** x 0) 'x)
(deriv '(** x 1) 'x)

;;---- ex 2.57 ---------
(define (augend s) 
  (if (null? (cdddr s)) (caddr s)
      (cons '+ (cddr s))))

(define (multiplicand p)
  (if (null? (cdddr p)) (caddr p)
      (cons '* (cddr p))))

(deriv '(+ x y 3) 'x)
(deriv '(+ x (+ x y 3)) 'x)
(deriv '(+ (+ x y) (+ x x (+ y 3))) 'x)

(deriv '(* x y 3) 'x)
(deriv '(* x y (+ x 3)) 'x)

}}}


== 2.58.a.scm ==


{{{
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list a1 '+ a2))))
(define (=number? exp num)
  (and (number? exp) (= exp num)))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list m1 '* m2))))

(define (sum? x)
  (and (pair? x) (eq? (cadr x) '+)))
(define (addend s) (car s))
(define (augend s) (caddr s))

(define (product? x)
  (and (pair? x) (eq? (cadr x) '*)))
(define (multiplier p) (car p))
(define (multiplicand p) (caddr p))

(define (exponentiation? exp)
  (and (pair? exp) (eq? (cadr exp) '**)))
(define (base s) (car s))
(define (exponent s) (caddr s))
(define (make-exponentiation b e)
  (cond ((=number? e 0) 1)
        ((=number? e 1) b)
        ((and (number? b) (number? e)) (expt b e))
        (else (list b '** e))))

(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        ((exponentiation? exp)
         (make-product
          (make-product (exponent exp)
                        (make-exponentiation (base exp)
                                             (- (exponent exp) 1)))
          (deriv (base exp) var)))
        (else
         (error "unknown expression type -- DERIV" exp))))


(deriv '(x + 3) 'x)
(deriv '(x * y) 'x)
(deriv '((x * y) * (x + 3)) 'x) ;; (x+3)y + xy

}}}


== 2.59.scm ==


{{{

(define (element-of-set? x set)
  (cond ((null? set) #f)
        ((equal? x (car set)) #t)
        (else (element-of-set? x (cdr set)))))

(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))

(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) '())
        ((element-of-set? (car set1) set2)
         (cons (car set1)
               (intersection-set (cdr set1) set2)))
        (else (intersection-set (cdr set1) set2))))

(define (union-set set1 set2)
  (cond ((null? set1) set2)
        ((element-of-set? (car set1) set2)
         (union-set (cdr set1) set2))
        (else (cons (car set1)
                    (union-set (cdr set1) set2)))))

(element-of-set? 'a '(g a e h))
(element-of-set? 'f '(g a e h))
(intersection-set '(a b c d e) '(f g a e h))
(union-set '(a b c d e) '(f g a e h))
}}}


== 2.60.scm ==


{{{

(define (element-of-set? x set)
  (cond ((null? set) #f)
        ((equal? x (car set)) #t)
        (else (element-of-set? x (cdr set)))))

(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))

(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) '())
        ((element-of-set? (car set1) set2)
         (cons (car set1)
               (intersection-set (cdr set1) set2)))
        (else (intersection-set (cdr set1) set2))))

(define (union-set set1 set2)
  (cond ((null? set1) set2)
;; do not check duplicated elements
;        ((element-of-set? (car set1) set2)
;         (union-set (cdr set1) set2))
        (else (cons (car set1)
                    (union-set (cdr set1) set2)))))

(intersection-set '(a e b a c d e) '(f g a e h))
(union-set '(a b c d e) '(f g a e h))
}}}


== 2.61.scm ==


{{{

(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (car set)) #t)
        ((< x (car set)) #f)
        (else (element-of-set? x (cdr set)))))

;; O(n/2)?
(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((= x (car set)) set)
        ((< x (car set)) (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))

(adjoin-set 1 '(2 4 6 8))
(adjoin-set 3 '(2 4 6 8))
(adjoin-set 5 '(2 4 6 8))
(adjoin-set 7 '(2 4 6 8))
(adjoin-set 9 '(2 4 6 8))
(adjoin-set 4 '(2 4 6 8))

(define (intersection-set set1 set2)
  (if (or (null? set1) (null? set2)) '()
      (let ((x1 (car set1)) (x2 (car set2)))
        (cond ((= x1 x2)
               (cons x1
                     (intersection-set (cdr set1)
                                       (cdr set2))))
              ((< x1 x2)
               (intersection-set (cdr set1) set2))
              ((< x2 x1)
               (intersection-set set1 (cdr set2)))))))


(intersection-set '(1 3 5 7 9) '(2 5 7 8))

}}}


== 2.62.scm ==


{{{

(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (car set)) #t)
        ((< x (car set)) #f)
        (else (element-of-set? x (cdr set)))))

;; O(n/2)?
(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((= x (car set)) set)
        ((< x (car set)) (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))

(adjoin-set 1 '(2 4 6 8))
(adjoin-set 3 '(2 4 6 8))
(adjoin-set 5 '(2 4 6 8))
(adjoin-set 7 '(2 4 6 8))
(adjoin-set 9 '(2 4 6 8))
(adjoin-set 4 '(2 4 6 8))

(define (intersection-set set1 set2)
  (if (or (null? set1) (null? set2)) '()
      (let ((x1 (car set1)) (x2 (car set2)))
        (cond ((= x1 x2)
               (cons x1
                     (intersection-set (cdr set1)
                                       (cdr set2))))
              ((< x1 x2)
               (intersection-set (cdr set1) set2))
              ((< x2 x1)
               (intersection-set set1 (cdr set2)))))))

(define (union-set set1 set2)
  (cond ((null? set1) set2)
        ((null? set2) set1)
        ((let ((x1 (car set1)) (x2 (car set2)))
           (cond ((= x1 x2)
                  (cons x1
                        (union-set (cdr set1)
                                   (cdr set2))))
                 ((< x1 x2)
                  (cons x1 (union-set (cdr set1) set2)))
                 ((< x2 x1)
                  (cons x2 (union-set set1 (cdr set2)))))))))


(intersection-set '(1 3 5 7 9) '(2 5 7 8))
(union-set '(1 3 5 7 9) '(2 5 7 8))
(union-set '(1 3 5) '(2 4 6 8))

}}}


== 2.63.scm ==


{{{

(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))

(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (entry set)) #t)
        ((< x (entry set))
         (element-of-set? x (left-branch set)))
        ((> x (entry set))
         (element-of-set? x (right-branch set)))))

(define (adjoin-set x set)
  (cond ((null? set) (make-tree x '() '()))
        ((= x (entry set)) set)
        ((< x (entry set))
         (make-tree (entry set)
                    (adjoin-set x (left-branch set))
                    (right-branch set)))
        ((> x (entry set))
         (make-tree (entry set)
                    (left-branch set)
                    (adjoin-set x (right-branch set))))))

(define test1-tree '())
(define test1-tree (adjoin-set 7 test1-tree))
(define test1-tree (adjoin-set 3 test1-tree))
(define test1-tree (adjoin-set 9 test1-tree))
(define test1-tree (adjoin-set 1 test1-tree))
(define test1-tree (adjoin-set 5 test1-tree))
(define test1-tree (adjoin-set 11 test1-tree))
test1-tree

(define test2-tree '(3 (1 () ()) 
                       (7 (5 () ()) (9 () (11 () ())))))

(define (tree->list-1 tree)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree)
                    (tree->list-1 (right-branch tree))))))

(tree->list-1 test1-tree)
(tree->list-1 test2-tree)

(define (tree->list-2 tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree)
                            (copy-to-list (right-branch tree)
                                          result-list)))))
  (copy-to-list tree '()))

(tree->list-2 test1-tree)
(tree->list-2 test2-tree)
}}}


== 2.66.scm ==


{{{

(define (lookup given-key set-of-records)
  (cond ((null? set-of-records) #f)
        ((equal? given-key (car set-of-records))
         (car set-of-records))
        (else (lookup given-key (cdr set-of-records)))))

(lookup 11 '(1 2 3 11 12 13))

(define test2-tree '(3 (1 () ()) 
                       (7 (5 () ()) (9 () (11 () ())))))

(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))

(define (tree->list-1 tree)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree)
                    (tree->list-1 (right-branch tree))))))

(define (lookup-btree-1 given-key bin-tree)
  (lookup given-key (tree->list-1 bin-tree)))

(lookup-btree-1 9 test2-tree)

(define (lookup-btree-2 given-key bin-tree)
  (cond ((null? bin-tree) #f)
        ((equal? given-key (entry bin-tree))
         (entry bin-tree))
        (else
         (or (lookup-btree-2 given-key (left-branch bin-tree))
             (lookup-btree-2 given-key (right-branch bin-tree))))))

(lookup-btree-2 3 test2-tree)
(lookup-btree-2 1 test2-tree)
(lookup-btree-2 7 test2-tree)
(lookup-btree-2 5 test2-tree)
(lookup-btree-2 9 test2-tree)
(lookup-btree-2 11 test2-tree)
(lookup-btree-2 13 test2-tree)
}}}


== 2.67.scm ==


{{{

(define (make-leaf symbol weight)
  (list 'leaf symbol weight))

(define (leaf? object)
  (eq? (car object) 'leaf))

(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))

;; example of code-tree
;; ((leaf a 1) (leaf b 2) ab 3)
(define (make-code-tree left right)
  (list left
        right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))))

(define (left-branch tree) (car tree))
(define (right-branch tree) (cadr tree))


(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree)) ; leaf?
      (caddr tree))) ; code-tree?

(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree) ; weigh of leaf
      (cadddr tree))) ; weight of code-tree

(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch
               (choose-branch (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch)
                    (decode-1 (cdr bits) tree)) ; start next decoding
              (decode-1 (cdr bits) next-branch))))) ; next branch
  (decode-1 bits tree))

(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else
         (error "bad bit -- CHOOSE-BRANCH" bit))))

(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x) (weight (car set))) (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))

(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs))) ; make leaf and insert it into the set
        (adjoin-set (make-leaf (car pair) (cadr pair))
                    (make-leaf-set (cdr pairs))))))

(make-code-tree (make-leaf 'D 1)
                (make-leaf 'C 1))

(make-code-tree (make-leaf 'B 2)
                (make-code-tree (make-leaf 'D 1)
                                (make-leaf 'C 1)))

(define sample-tree
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree
                   (make-leaf 'B 2)
                   (make-code-tree (make-leaf 'D 1)
                                   (make-leaf 'C 1)))))
(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))


(decode sample-message sample-tree)





















}}}


== 2.68.scm ==


{{{

(define (make-leaf symbol weight)
  (list 'leaf symbol weight))

(define (leaf? object)
  (eq? (car object) 'leaf))

(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))

;; example of code-tree
;; ((leaf a 1) (leaf b 2) ab 3)
(define (make-code-tree left right)
  (list left
        right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))))

(define (left-branch tree) (car tree))
(define (right-branch tree) (cadr tree))


(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree)) ; leaf?
      (caddr tree))) ; code-tree?

(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree) ; weigh of leaf
      (cadddr tree))) ; weight of code-tree

(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch
               (choose-branch (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch)
                    (decode-1 (cdr bits) tree)) ; start next decoding
              (decode-1 (cdr bits) next-branch))))) ; next branch
  (decode-1 bits tree))

(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else
         (error "bad bit -- CHOOSE-BRANCH" bit))))

(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x) (weight (car set))) (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))

(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs))) ; make leaf and insert it into the set
        (adjoin-set (make-leaf (car pair) (cadr pair))
                    (make-leaf-set (cdr pairs))))))

(make-code-tree (make-leaf 'D 1)
                (make-leaf 'C 1))

(make-code-tree (make-leaf 'B 2)
                (make-code-tree (make-leaf 'D 1)
                                (make-leaf 'C 1)))

(define sample-tree
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree
                   (make-leaf 'B 2)
                   (make-code-tree (make-leaf 'D 1)
                                   (make-leaf 'C 1)))))
(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))

(define (encode message tree)
;;  (display message) (newline)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree)
              (encode (cdr message) tree))))

(define (encode-symbol data tree)
  (define (is-tree? sub-tree)
    (pair? sub-tree))
  (define (encode-symbol-body data sub-tree bits)
;;    (display sub-tree) (newline)
    (cond ((not (is-tree? sub-tree)) (error "Unknown data"))
          ((and (leaf? sub-tree) (equal? (list data) (symbols sub-tree)))
           bits)
          ((and (not (leaf? sub-tree)) (equal? (symbols (left-branch sub-tree)) (list data)))
           (append bits '(0)))
          (else
           (encode-symbol-body data
                               (right-branch sub-tree)
                               (append bits '(1))))))
  (encode-symbol-body data tree '()))

(encode-symbol 'A sample-tree)
(encode-symbol 'B sample-tree)
(encode-symbol 'C sample-tree)
(encode-symbol 'D sample-tree)
(encode-symbol 'E sample-tree)

(if (equal? (encode (decode sample-message sample-tree) sample-tree) sample-message)
    (display "SUCCESS\n")
    (display "FAIL\n"))

}}}


== 2.69.scm ==


{{{


(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x) (weight (car set))) (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))

(define (make-leaf symbol weight)
  (list 'leaf symbol weight))

(define (leaf? object)
  (eq? (car object) 'leaf))

(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))

;; example of code-tree
;; ((leaf a 1) (leaf b 2) ab 3)
(define (make-code-tree left right)
  (list left
        right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))))

(define (left-branch tree) (car tree))
(define (right-branch tree) (cadr tree))


(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree)) ; leaf?
      (caddr tree))) ; code-tree?

(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree) ; weigh of leaf
      (cadddr tree))) ; weight of code-tree

(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs))) ; make leaf and insert it into the set
        (adjoin-set (make-leaf (car pair) (cadr pair))
                    (make-leaf-set (cdr pairs))))))

(define (encode message tree)
;;  (display message) (newline)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree)
              (encode (cdr message) tree))))

(define (encode-symbol data tree)
  (define (is-tree? sub-tree)
    (pair? sub-tree))
  (define (encode-symbol-body data sub-tree bits)
;;    (display sub-tree) (newline)
    (cond ((not (is-tree? sub-tree)) (error "Unknown data"))
          ((and (leaf? sub-tree) (equal? (list data) (symbols sub-tree)))
           bits)
          ((and (not (leaf? sub-tree)) (equal? (symbols (left-branch sub-tree)) (list data)))
           (append bits '(0)))
          (else
           (encode-symbol-body data
                               (right-branch sub-tree)
                               (append bits '(1))))))
  (encode-symbol-body data tree '()))

(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))


;; In result tree, most high and left branch must be E
(define (successive-merge leaves)
  (define (successive-merge-body right-branch remain-leaves)
;;    (display remain-leaves) (display "-") (display right-branch) (newline)
    (if (null? remain-leaves) right-branch
        (successive-merge-body (make-code-tree (car remain-leaves) right-branch)
                               (cdr remain-leaves))))
  (successive-merge-body (car leaves) (cdr leaves)))

(define sample-pairs 
  '((C 3) (A 5) (B 4) (D 1)))
(define sample-tree (generate-huffman-tree sample-pairs))

;; test successive-merge with encode
(encode-symbol 'A sample-tree)
(encode-symbol 'B sample-tree)
(encode-symbol 'C sample-tree)
(encode-symbol 'D sample-tree)

(encode '(A B C D) sample-tree)
(encode '(A C A B B D A) sample-tree)
(encode '(A B C D A E D B) (successive-merge sample-pairs))
}}}


== 2.70.scm ==


{{{


(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x) (weight (car set))) (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))

(define (make-leaf symbol weight)
  (list 'leaf symbol weight))

(define (leaf? object)
  (eq? (car object) 'leaf))

(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))

;; example of code-tree
;; ((leaf a 1) (leaf b 2) ab 3)
(define (make-code-tree left right)
  (list left
        right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))))

(define (left-branch tree) (car tree))
(define (right-branch tree) (cadr tree))


(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree)) ; leaf?
      (caddr tree))) ; code-tree?

(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree) ; weigh of leaf
      (cadddr tree))) ; weight of code-tree

(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs))) ; make leaf and insert it into the set
        (adjoin-set (make-leaf (car pair) (cadr pair))
                    (make-leaf-set (cdr pairs))))))

(define (encode message tree)
;;  (display message) (newline)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree)
              (encode (cdr message) tree))))

(define (encode-symbol data tree)
  (define (is-tree? sub-tree)
    (pair? sub-tree))
  (define (encode-symbol-body data sub-tree bits)
;;    (display sub-tree) (newline)
    (cond ((not (is-tree? sub-tree)) (error "Unknown data"))
          ((and (leaf? sub-tree) (equal? (list data) (symbols sub-tree)))
           bits)
          ((and (not (leaf? sub-tree)) (equal? (symbols (left-branch sub-tree)) (list data)))
           (append bits '(0)))
          (else
           (encode-symbol-body data
                               (right-branch sub-tree)
                               (append bits '(1))))))
  (encode-symbol-body data tree '()))

(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))


;; In result tree, most high and left branch must be E
(define (successive-merge leaves)
  (define (successive-merge-body right-branch remain-leaves)
;;    (display remain-leaves) (display "-") (display right-branch) (newline)
    (if (null? remain-leaves) right-branch
        (successive-merge-body (make-code-tree (car remain-leaves) right-branch)
                               (cdr remain-leaves))))
  (successive-merge-body (car leaves) (cdr leaves)))

(define sample-pairs 
  '((A 2)
    (NA 16)
    (BOOM 1)
    (SHA 3)
    (GET 2)
    (YIP 9)
    (JOB 2)
    (WAH 1)))
(define sample-tree (generate-huffman-tree sample-pairs))

;; test successive-merge with encode
(encode-symbol 'A sample-tree)
(encode-symbol 'NA sample-tree)
(encode-symbol 'BOOM sample-tree)
(encode-symbol 'SHA sample-tree)
(encode-symbol 'GET sample-tree)
(encode-symbol 'YIP sample-tree)
(encode-symbol 'JOB sample-tree)
(encode-symbol 'WAH sample-tree)

(encode '(GET A JOB SHA NA NA NA NA NA NA NA NA WAH YIP YIP YIP YIP YIP YIP YIP YIP YIP YIP) sample-tree)
}}}


== 2.73.scm ==


{{{


;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;;-------------------------------------------------------------

;;---------------------------------------------------------
;; ch 2.3.2
;;---------------------------------------------------------
(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (addend s) (car s))
(define (augend s) (cadr s))
(define (multiplier p) (car p))
(define (multiplicand p) (cadr p))
(define (=number? exp num)
  (and (number? exp) (= exp num)))
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list '+ a1 a2))))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))

(define (exponentiation? exp)
  (and (pair? exp) (eq? (car exp) '**)))
(define (base s) (car s))
(define (exponent s) (cadr s))
(define (make-exponentiation b e)
  (cond ((=number? e 0) 1)
        ((=number? e 1) b)
        ((and (number? b) (number? e)) (expt b e))
        (else (list '** b e))))
;;---------------------------------------------------------

;; ex2.73 (b)
(define (deriv-add exp var)
  (make-sum (deriv (addend exp) var)
            (deriv (augend exp) var)))
(define (deriv-mul exp var)
  (make-sum
   (make-product (multiplier exp)
                 (deriv (multiplicand exp) var))
   (make-product (deriv (multiplier exp) var)
                 (multiplicand exp))))
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        (else
         ((get 'deriv (operator exp)) (operands exp) var))))

(define (operator exp) (car exp))
(define (operands exp) (cdr exp))

(put 'deriv '+ deriv-add)
(put 'deriv '* deriv-mul)


(deriv '(+ x y) 'x)
(deriv '(* x y) 'x)
(deriv '(* (* x y) (+ x 3)) 'x) ;(+ (* x y) (* y (+ x 3)))

;; ex2.73 (c)
(define (deriv-expo exp var)
  (make-product
   (make-product (exponent exp)
                 (make-exponentiation (base exp)
                                      (- (exponent exp) 1)))
   (deriv (base exp) var)))

(put 'deriv '** deriv-expo)

(deriv '(** x 3) 'x)
(deriv '(** y 3) 'x)
(deriv '(** 3 3) 'x)
(deriv '(** x 0) 'x)
(deriv '(** x 1) 'x)


;; ex2.73 (d)
(define (deriv-reverse exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        (else
         ((get (operator exp) 'deriv) (operands exp) var))))

;; If put has arguments of type and operator, not operator and type,
;; it does not effect other codes.
(put '+ 'deriv deriv-add)
(deriv-reverse '(+ x y) 'x)
}}}


== 2.74.scm ==


{{{
;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;; (put <op> <type> <item>)
;; (get <op> <type>
;;------------------------------------------------


;;------------------------------------------------
;; data files
;; Each file has a division name at the first item,
;; and can have its own data format.
;;------------------------------------------------

;; file of division A
(define file-of-division-a
  '(division-a ; division name
  ;;;name, salary, phone
    (name-a-1 111 1111)
    (name-a-2 222 2222)
    (name-a-3 333 3333)))

;; file of division B
(define file-of-division-b
  '(division-b
  ;; phone, name, addr, salary
    (3333 name-b-1 aaaa 333)
    (4444 name-b-2 bbbb 444)
    (5555 name-b-3 cccc 555)))

;; file of division C
(define file-of-division-c
  '(division-c
  ;; name, salary
    (name-c-1 666)
    (name-c-2 777)
    (name-c-3 888)
    (name-c-4 999)))


;;------------------------------------------------
;; Methods for each division
;; Employee name must be unique so that it can be used as key.
;; Every method must have one argument that employee name
;; and return result value at success case,
;; otherwise false.
;;------------------------------------------------


(define (install-division-a)
  ;;; methods

  ;; get record of name or return false
  (define (get-record name)
    (define (get-name-from-record record)
      (car record))
    (define (find-record-by-name records name)
      (cond ((null? records) #f)
            ((eq? name (get-name-from-record (car records)))
             (car records))
            (else
             (find-record-by-name (cdr records) name))))
    (find-record-by-name (cdr file-of-division-a) name))

  ;; get salary of name or return false
  (define (get-salary name)
    (if (get-record name) (cadr (get-record name))
        #f))

  ;;; install methods
  (put 'get-record 'division-a get-record)
  (put 'get-salary 'division-a get-salary)

  'done)

(install-division-a)

(define (install-division-b)
  ;;; methods
  ;; get record of name or return false
  (define (get-record name)
    (define (get-name-from-record record)
      (cadr record))
    (define (find-record-by-name records name)
      (cond ((null? records) #f)
            ((eq? name (get-name-from-record (car records)))
             (car records))
            (else
             (find-record-by-name (cdr records) name))))
    (find-record-by-name (cdr file-of-division-b) name))

  ;; get salary of name or return false
  (define (get-salary name)
    (if (get-record name) (cadddr (get-record name))
        #f))

  ;;; install methods
  (put 'get-record 'division-b get-record)
  (put 'get-salary 'division-b get-salary)
  'done)

(define (install-division-c)
  ;;; methods
  ;; get record of name or return false
  (define (get-record name)
    (define (get-name-from-record record)
      (car record))
    (define (find-record-by-name records name)
      (cond ((null? records) #f)
            ((eq? name (get-name-from-record (car records)))
             (car records))
            (else
             (find-record-by-name (cdr records) name))))
    (find-record-by-name (cdr file-of-division-c) name))

  ;; get salary of name or return false
  (define (get-salary name)
    (if (get-record name) (cadr (get-record name))
        #f))

  ;;; install methods
  (put 'get-record 'division-c get-record)
  (put 'get-salary 'division-c get-salary)

  'done)

(install-division-b)
(install-division-c)

;; simple version of apply-generic
;; (define (apply-generic op name)
;;   (cond (((get op 'division-a) name) ((get op 'division-a) name));try file-of-division-a
;;         (((get op 'division-b) name) ((get op 'division-b) name))
;;         (((get op 'division-c) name) ((get op 'division-c) name))
;;         (else #f)))

(define (apply-generic op name)
  (let ((result-division-a ((get op 'division-a) name)))
    (if result-division-a result-division-a
        (let ((result-division-b ((get op 'division-b) name)))
          (if result-division-b result-division-b
              (let ((result-division-c ((get op 'division-c) name)))
                (if result-division-c result-division-c
                    (display "fail"))))))))
  
;;-------------------------
;; generic functions
;;-------------------------
(define (get-record name) (apply-generic 'get-record name))
(define (get-salary name) (apply-generic 'get-salary name))

;; test
(get-record 'name-a-1)
(get-record 'name-a-2)
(get-record 'name-b-2)
(get-record 'name-c-3)

(get-record 'a)

(get-salary 'name-a-1)
(get-salary 'name-a-2)
(get-salary 'name-b-2)
(get-salary 'name-c-3)

(get-salary 'a)
}}}


== 2.75.scm ==


{{{



(define (make-from-real-imag x y)
  (define (dispatch op)
    (cond ((eq? op 'real-part) x)
          ((eq? op 'imag-part) y)
          ((eq? op 'magnitude)
           (sqrt (+ (square x) (square y))))
          ((eq? op 'angle) (atan y x))
          (else
           (error "Unknown op -- MAKE-FROM-REAL-IMAG" op))))
  dispatch)

(define (apply-generic op arg) (arg op))

;; This is the same with
;; ((make-from-real-imag 3 4) 'real-part)
(apply-generic 'real-part (make-from-real-imag 3 4))


;;ex 2.75
(define (make-from-mag-ang r a)
  (define (dispatch op)
    (cond ((eq? op 'real-part) (* r (cos a)))
          ((eq? op 'imag-part) (* r (sin a)))
          ((eq? op 'magnitude) r)
          ((eq? op 'angle) a)
          (else
           (error "Unknown op -- MAKE-FROM-MAG-ANG" op))))
  dispatch)
           
(apply-generic 'angle (make-from-mag-ang 30 40))
}}}


== 2.76.scm ==


{{{


;; ex2.76
;; No code
}}}


== 2.77.scm ==


{{{
;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;; (put <op> <type> <item>)
;; (get <op> <type>
;;------------------------------------------------


;;----- GENERIC PROCEDURES -----------------

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))

(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))


(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error "Bad tagged datum -- TYPE-TAG" datum)))

(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (contents datum)
  (if (pair? datum) (cdr datum)
      (error "Bad tagged datum -- CONTENTS" datum)))

(define (apply-generic op . args)
  (let ((type-tags (map type-tag args))) ;; extract tags of each arguments
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args)) ;; extract data
          (error
            "No method for these types -- APPLY-GENERIC"
            (list op type-tags))))))


;;---- INSTALL NUMBER_SYSTEM --------------

;; 태그가 2개인 이유 
;; 모든 연산자의 인자는 2개이고 하나의 인자마다 하나의 태그를 가지고 있다.
;; 따라서 (apply-generic) 함수에서 type-tags 변수는 인자들의 태그들의 리스트이므로
;; 2개의 태그 '(scheme-number scheme-number)가 된다.
;; 따라서 테이블에 연산자를 입력할 때 2개의 태그를 타입으로 입력해야 
;; 연산자의 인자들이 연산자에 맞는 인자인지를 알아낼 수 있다.
;; 만약, add 함수에 일반 정수와 유리수를 인자로 넘기면
;; type-tags 변수가 '(scheme-number rational)이 되서 데이터 타입에 오류가 있다는 것을
;; 알아낼 수 있다.


;; normal number
;; eg) (add (make-scheme-number 3) (make-scheme-number 4))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))

  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  'done)


(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

;; rational number
;; eg) (add (make-rational 3 4) (make-rational 3 4))
(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  ;; interface to rest of the system
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))

  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))


(define (square a) (* a a))

;; real + imaginary number
;; 3 + 4i = (rectangular 3 . 4)
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

;; mag + angle number
;; 3 + 45' = (polar 3 . 45)
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

;; complex number
(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
                         (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))

  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))

  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))

  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

  'done)

;; complex 숫자들은 2개의 태그를 가진다.
;; make-comple-from-real-imag에서 'complex라는 태그를 추가해주고 
;; make-from-real-imag에서 'rectangular라는 태그를 추가해서
;; (complex rectangular 3 . 4) 와 같은 형태가 된다.
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))


;; MUST INSTALL!!
(install-scheme-number-package)
(install-rational-package)
(install-polar-package)
(install-rectangular-package)
(install-complex-package)



(make-complex-from-real-imag 3 4) ;; == (complex rectangular 3 . 4)
(add (make-complex-from-real-imag 3 4) (make-complex-from-real-imag 3 4))
;; executing flow
;; generic 함수를 호출할때마다 apply-generic 함수가 태그를 하나씩 없애고 타입에 맞는 함수를 찾아서 실행시킴
;; 하지만 각 함수 패키지에서는 연산 결과에 태그를 붙이므로, 최종 결과에서 태그는 그대로 유지됨.
;;
;; => (cons 'complex (add-complex (((get 'make-from-real-imag 'rectangular) 3 4)
;;                                 ((get 'make-from-real-imag 'rectangular) 3 4))))
;; => (cons 'complex (add-complex (rectangular 3 . 4) (rectangular 3 . 4))
;; => (cons 'complex (cons 'rectangular (make-from-real-imag ((+ (real-part z1) (real-part z2))
;;                                                            (+ (imag-part z1) (imag-part z2))))
;; => (real-part (rectangular 3 . 4)) -> (apply-generic 'real-part (rectangular 3 . 4))
;;                                    -> type-tags=rectangular, proc=(get 'real-part '(rectangular))
;;                                    -> (car '(3 . 4))
;;                                    -> apply-generic 함수는 태그 rectangular를 없애고 '(3 . 4)인자만 전달시킴
;; => (cons 'complex (cons 'rectangular (make-from-real-imag ((+ 3 3) (+ 4 4)))))
;; => (complex rectangular 6 8)

;; ex 2.77
(magnitude (make-complex-from-real-imag 3 4))
;; (make-complex-from-real-imag 3 4) == (cons 'complex (cons 'rectangular (cons 3 4)))
;; (magnitude '(complex rectangular 3 . 4))
;; => type-tags = complex, proc = (get 'magnitude '(complex)) = magnitude of complex package -> 1번!
;; => (magnitude '(rectangular 3 . 4)) complex 패키지에는 magnitude함수의 정의가 없으므로 그대로 다시 실행됨
;; => type-tags = rectangular, proc = (get 'magnitude '(rectangular)) = magnitude of rectangular package -> 2번!
;; => 5.0
}}}


== 2.78.scm ==


{{{
;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;; (put <op> <type> <item>)
;; (get <op> <type>
;;------------------------------------------------


;;----- GENERIC PROCEDURES -----------------

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))

(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))


(define (apply-generic op . args)
  (let ((type-tags (map type-tag args))) ;; extract tags of each arguments
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args)) ;; extract data
          (error
            "No method for these types -- APPLY-GENERIC"
            (list op type-tags))))))


;;---- INSTALL NUMBER_SYSTEM --------------

;; 태그가 2개인 이유 
;; 모든 연산자의 인자는 2개이고 하나의 인자마다 하나의 태그를 가지고 있다.
;; 따라서 (apply-generic) 함수에서 type-tags 변수는 인자들의 태그들의 리스트이므로
;; 2개의 태그 '(scheme-number scheme-number)가 된다.
;; 따라서 테이블에 연산자를 입력할 때 2개의 태그를 타입으로 입력해야 
;; 연산자의 인자들이 연산자에 맞는 인자인지를 알아낼 수 있다.
;; 만약, add 함수에 일반 정수와 유리수를 인자로 넘기면
;; type-tags 변수가 '(scheme-number rational)이 되서 데이터 타입에 오류가 있다는 것을
;; 알아낼 수 있다.


;; normal number
;; eg) (add (make-scheme-number 3) (make-scheme-number 4))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))

  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  'done)


(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))


;; MUST INSTALL!!
(install-scheme-number-package)


;;-------- ex 2.78 ---------------

;; (define (type-tag datum)
;;   (if (pair? datum)
;;       (car datum)
;;       (error "Bad tagged datum -- TYPE-TAG" datum)))

(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
        (error "Bad tagged datum -- TYPE-TAG" datum)))

(define (attach-tag type-tag contents)
  (cons type-tag contents))

;; (define (contents datum)
;;   (if (pair? datum) (cdr datum)
;;       (error "Bad tagged datum -- CONTENTS" datum)))

(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (error "Bad tagged datum -- CONTENTS" datum)))

; test
(if (and (eq? (cdr (add 1 2)) 3) (eq? (car (add 1 2)) 'scheme-number)) '#t
    (display "FAIL TO SOLVE EX2.78"))

(add 3 (add (make-scheme-number 3) (make-scheme-number 4)))
}}}


== 2.79.scm ==


{{{
;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;; (put <op> <type> <item>)
;; (get <op> <type>
;;------------------------------------------------


;;----- GENERIC PROCEDURES -----------------

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))

;; ex 2.29
(define (ex-equ? x y) (apply-generic 'ex-equ? x y))

(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))


;; (define (type-tag datum)
;;   (if (pair? datum)
;;       (car datum)
;;       (error "Bad tagged datum -- TYPE-TAG" datum)))

;; (define (attach-tag type-tag contents)
;;   (cons type-tag contents))

;; (define (contents datum)
;;   (if (pair? datum) (cdr datum)
;;       (error "Bad tagged datum -- CONTENTS" datum)))

;; ex 2.28
(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
        (error "Bad tagged datum -- TYPE-TAG" datum)))

(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (error "Bad tagged datum -- CONTENTS" datum)))

(define (apply-generic op . args)
  (let ((type-tags (map type-tag args))) ;; extract tags of each arguments
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args)) ;; extract data
          (error
            "No method for these types -- APPLY-GENERIC"
            (list op type-tags))))))


;;---- INSTALL NUMBER_SYSTEM --------------

;; 태그가 2개인 이유 
;; 모든 연산자의 인자는 2개이고 하나의 인자마다 하나의 태그를 가지고 있다.
;; 따라서 (apply-generic) 함수에서 type-tags 변수는 인자들의 태그들의 리스트이므로
;; 2개의 태그 '(scheme-number scheme-number)가 된다.
;; 따라서 테이블에 연산자를 입력할 때 2개의 태그를 타입으로 입력해야 
;; 연산자의 인자들이 연산자에 맞는 인자인지를 알아낼 수 있다.
;; 만약, add 함수에 일반 정수와 유리수를 인자로 넘기면
;; type-tags 변수가 '(scheme-number rational)이 되서 데이터 타입에 오류가 있다는 것을
;; 알아낼 수 있다.


;; normal number
;; eg) (add (make-scheme-number 3) (make-scheme-number 4))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))

  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))

  ;; ex2.79
  (put 'ex-equ? '(scheme-number scheme-number)
       (lambda (x y) (= x y)))

  'done)


(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

;; rational number
;; eg) (add (make-rational 3 4) (make-rational 3 4))
(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))

  ;; ex2.79
  (define (ex-equ? x y)
    (and (= (numer x) (numer y))
         (= (denom x) (denom y))))

  ;; interface to rest of the system
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))

  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))

  (put 'ex-equ? '(rational rational) ex-equ?)

  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))


(define (square a) (* a a))

;; real + imaginary number
;; 3 + 4i = (rectangular 3 . 4)
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))

  'done)

;; mag + angle number
;; 3 + 45' = (polar 3 . 45)
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

;; complex number
(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
                         (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))

  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))

  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))

  ;;ex2.79
  (put 'ex-equ? '(complex complex)
       (lambda (z1 z2) (and (equal? (real-part z1) (real-part z2))
                            (equal? (imag-part z1) (imag-part z2)))))

  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

  'done)

;; complex 숫자들은 2개의 태그를 가진다.
;; make-comple-from-real-imag에서 'complex라는 태그를 추가해주고 
;; make-from-real-imag에서 'rectangular라는 태그를 추가해서
;; (complex rectangular 3 . 4) 와 같은 형태가 된다.
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))


;; MUST INSTALL!!
(install-scheme-number-package)
(install-rational-package)
(install-polar-package)
(install-rectangular-package)
(install-complex-package)








;; test
(ex-equ? (make-scheme-number 3) (make-scheme-number 3))
(ex-equ? (make-scheme-number 3) (make-scheme-number 4))

(ex-equ? (make-rational 3 4) (make-rational 3 4))
(ex-equ? (make-rational 3 4) (make-rational 3 5))

(ex-equ? (make-complex-from-real-imag 3 4) (make-complex-from-real-imag 3 4))
(ex-equ? (make-complex-from-real-imag 3 4) (make-complex-from-real-imag 3 3))
(ex-equ? (make-complex-from-mag-ang 3 4) (make-complex-from-mag-ang 3 4))
(ex-equ? (make-complex-from-mag-ang 3 4) (make-complex-from-mag-ang 3 3))





}}}


== 2.80.scm ==


{{{
;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;; (put <op> <type> <item>)
;; (get <op> <type>
;;------------------------------------------------


;;----- GENERIC PROCEDURES -----------------

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))

;; ex2.79
(define (ex-equ? x y) (apply-generic 'ex-equ? x y))

;; ex2.80
(define (ex-zero? x) (apply-generic 'ex-zero? x))


(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))


;; (define (type-tag datum)
;;   (if (pair? datum)
;;       (car datum)
;;       (error "Bad tagged datum -- TYPE-TAG" datum)))

;; (define (attach-tag type-tag contents)
;;   (cons type-tag contents))

;; (define (contents datum)
;;   (if (pair? datum) (cdr datum)
;;       (error "Bad tagged datum -- CONTENTS" datum)))

;; ex 2.28
(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
        (error "Bad tagged datum -- TYPE-TAG" datum)))

(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (error "Bad tagged datum -- CONTENTS" datum)))

(define (apply-generic op . args)
  (let ((type-tags (map type-tag args))) ;; extract tags of each arguments
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args)) ;; extract data
          (error
            "No method for these types -- APPLY-GENERIC"
            (list op type-tags))))))


;;---- INSTALL NUMBER_SYSTEM --------------

;; 태그가 2개인 이유 
;; 모든 연산자의 인자는 2개이고 하나의 인자마다 하나의 태그를 가지고 있다.
;; 따라서 (apply-generic) 함수에서 type-tags 변수는 인자들의 태그들의 리스트이므로
;; 2개의 태그 '(scheme-number scheme-number)가 된다.
;; 따라서 테이블에 연산자를 입력할 때 2개의 태그를 타입으로 입력해야 
;; 연산자의 인자들이 연산자에 맞는 인자인지를 알아낼 수 있다.
;; 만약, add 함수에 일반 정수와 유리수를 인자로 넘기면
;; type-tags 변수가 '(scheme-number rational)이 되서 데이터 타입에 오류가 있다는 것을
;; 알아낼 수 있다.


;; normal number
;; eg) (add (make-scheme-number 3) (make-scheme-number 4))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))

  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))

  ;; ex2.79
  (put 'ex-equ? '(scheme-number scheme-number)
       (lambda (x y) (= x y)))

  ;; ex2.80
  (put 'ex-zero? '(scheme-number)
       (lambda (x) (= x 0)))

  'done)


(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

;; rational number
;; eg) (add (make-rational 3 4) (make-rational 3 4))
(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))

  ;; ex2.79
  (define (ex-equ? x y)
    (and (= (numer x) (numer y))
         (= (denom x) (denom y))))

  ;; ex2.80
  (define (ex-zero? x)
    (= (numer x) 0))

  ;; interface to rest of the system
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))

  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))

  ;; ex2.79
  (put 'ex-equ? '(rational rational) ex-equ?)
  
  ;; ex2.80
  (put 'ex-zero? '(rational) ex-zero?)

  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))


(define (square a) (* a a))

;; real + imaginary number
;; 3 + 4i = (rectangular 3 . 4)
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))

  'done)

;; mag + angle number
;; 3 + 45' = (polar 3 . 45)
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

;; complex number
(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
                         (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))

  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))

  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))

  ;;ex2.79
  (put 'ex-equ? '(complex complex)
       (lambda (z1 z2) (and (equal? (real-part z1) (real-part z2))
                            (equal? (imag-part z1) (imag-part z2)))))

  ;;ex2.80
  (put 'ex-zero? '(complex)
       (lambda (z1) (and (equal? (real-part z1) 0)
                         (equal? (imag-part z1) 0))))

  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

  

  'done)

;; complex 숫자들은 2개의 태그를 가진다.
;; make-comple-from-real-imag에서 'complex라는 태그를 추가해주고 
;; make-from-real-imag에서 'rectangular라는 태그를 추가해서
;; (complex rectangular 3 . 4) 와 같은 형태가 된다.
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))


;; MUST INSTALL!!
(install-scheme-number-package)
(install-rational-package)
(install-polar-package)
(install-rectangular-package)
(install-complex-package)








;; test
(ex-zero? (make-scheme-number 0))
(ex-zero? (make-scheme-number 1))

(ex-zero? (make-rational 3 4))
(ex-zero? (make-rational 0 4))


(ex-zero? (make-complex-from-real-imag  0 0))
(ex-zero? (make-complex-from-real-imag 0 4))
(ex-zero? (make-complex-from-real-imag 3 0))

(ex-zero? (make-complex-from-mag-ang 0 0))
(ex-zero? (make-complex-from-mag-ang 0 4)) ;; zero
(ex-zero? (make-complex-from-mag-ang 3 0))

}}}


== 2.81.scm ==


{{{
;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;; (put <op> <type> <item>)
;; (get <op> <type>
;;------------------------------------------------


;;----- GENERIC PROCEDURES -----------------

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (ex-equ? x y) (apply-generic 'ex-equ? x y))
(define (ex-zero? x) (apply-generic 'ex-zero? x))


;; ex2.81
(define (exp x y) (apply-generic 'exp x y))


(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))

(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
        (error "Bad tagged datum -- TYPE-TAG" datum)))

(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (error "Bad tagged datum -- CONTENTS" datum)))

;; (define (apply-generic op . args)
;;   (let ((type-tags (map type-tag args))) ;; extract tags of each arguments
;;     (let ((proc (get op type-tags)))
;;       (if proc
;;           (apply proc (map contents args)) ;; extract data
;;           (error
;;             "No method for these types -- APPLY-GENERIC"
;;             (list op type-tags))))))


(define get-coercion get)
(define put-coercion put)



(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (let ((t1->t2 (get-coercion type1 type2))
                      (t2->t1 (get-coercion type2 type1)))
                  (cond (t1->t2
                         (apply-generic op (t1->t2 a1) a2))
                        (t2->t1
                         (apply-generic op a1 (t2->t1 a2)))
                        (else
                         (error "No method for these types (different types)"
                                (list op type-tags))))))
              (error "No method for these types"
                     (list op type-tags)))))))


;;---- INSTALL NUMBER_SYSTEM --------------

;; 태그가 2개인 이유 
;; 모든 연산자의 인자는 2개이고 하나의 인자마다 하나의 태그를 가지고 있다.
;; 따라서 (apply-generic) 함수에서 type-tags 변수는 인자들의 태그들의 리스트이므로
;; 2개의 태그 '(scheme-number scheme-number)가 된다.
;; 따라서 테이블에 연산자를 입력할 때 2개의 태그를 타입으로 입력해야 
;; 연산자의 인자들이 연산자에 맞는 인자인지를 알아낼 수 있다.
;; 만약, add 함수에 일반 정수와 유리수를 인자로 넘기면
;; type-tags 변수가 '(scheme-number rational)이 되서 데이터 타입에 오류가 있다는 것을
;; 알아낼 수 있다.


;; normal number
;; eg) (add (make-scheme-number 3) (make-scheme-number 4))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))

  ;; ex2.81
  (define (scheme-number->complex x)
    (make-complex-from-real-imag (cdr x) 0))

  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  (put 'ex-equ? '(scheme-number scheme-number)
       (lambda (x y) (= x y)))
  (put 'ex-zero? '(scheme-number)
       (lambda (x) (= x 0)))

  ;; ex2.81
  (put-coercion 'scheme-number 'complex
                scheme-number->complex)

  (put 'exp '(scheme-number scheme-number)
       (lambda (x y) (tag (expt x y))))

  'done)


(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

;; rational number
;; eg) (add (make-rational 3 4) (make-rational 3 4))
(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  (define (ex-equ? x y)
    (and (= (numer x) (numer y))
         (= (denom x) (denom y))))
  (define (ex-zero? x)
    (= (numer x) 0))

  ;; interface to rest of the system
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'ex-equ? '(rational rational) ex-equ?)
  (put 'ex-zero? '(rational) ex-zero?)

  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))


(define (square a) (* a a))

;; real + imaginary number
;; 3 + 4i = (rectangular 3 . 4)
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))

  'done)

;; mag + angle number
;; 3 + 45' = (polar 3 . 45)
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

;; complex number
(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
                         (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))

  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))

  ;; ex2.81
  (define (scheme-number->scheme-number n) n)
  (define (complex->complex z) z)


  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'ex-equ? '(complex complex)
       (lambda (z1 z2) (and (equal? (real-part z1) (real-part z2))
                            (equal? (imag-part z1) (imag-part z2)))))
  (put 'ex-zero? '(complex)
       (lambda (z1) (and (equal? (real-part z1) 0)
                         (equal? (imag-part z1) 0))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)


  ;; ex2.81
  (put-coercion 'scheme-number 'scheme-number
                scheme-number->scheme-number)
  (put-coercion 'complex 'complex complex->complex)

  'done)

;; complex 숫자들은 2개의 태그를 가진다.
;; make-comple-from-real-imag에서 'complex라는 태그를 추가해주고 
;; make-from-real-imag에서 'rectangular라는 태그를 추가해서
;; (complex rectangular 3 . 4) 와 같은 형태가 된다.
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))


;; MUST INSTALL!!
(install-scheme-number-package)
(install-rational-package)
(install-polar-package)
(install-rectangular-package)
(install-complex-package)




;; test
(add (make-scheme-number 2) (make-complex-from-real-imag 2 3))
(exp 2 3)

}}}


== 2.82.scm ==


{{{
;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;; (put <op> <type> <item>)
;; (get <op> <type>
;;------------------------------------------------


;;----- GENERIC PROCEDURES -----------------

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (ex-equ? x y) (apply-generic 'ex-equ? x y))
(define (ex-zero? x) (apply-generic 'ex-zero? x))
(define (exp x y) (apply-generic 'exp x y))
(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))


;; ex2.82
(define (add-3 a b c) (apply-generic 'add-3 a b c))


(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
        (error "Bad tagged datum -- TYPE-TAG" datum)))

(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (error "Bad tagged datum -- CONTENTS" datum)))

;; (define (apply-generic op . args)
;;   (let ((type-tags (map type-tag args))) ;; extract tags of each arguments
;;     (let ((proc (get op type-tags)))
;;       (if proc
;;           (apply proc (map contents args)) ;; extract data
;;           (error
;;             "No method for these types -- APPLY-GENERIC"
;;             (list op type-tags))))))


(define get-coercion get)
(define put-coercion put)



(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (let ((t1->t2 (get-coercion type1 type2))
                      (t2->t1 (get-coercion type2 type1)))
                  (cond (t1->t2
                         (apply-generic op (t1->t2 a1) a2))
                        (t2->t1
                         (apply-generic op a1 (t2->t1 a2)))
                        (else
                         (error "No method for these types (two-types)"
                                (list op type-tags))))))
              (if (= (length args) 3)
                  (let ((type1 (car type-tags))
                        (type2 (cadr type-tags))
                        (type3 (caddr type-tags))
                        (a1 (car args))
                        (a2 (cadr args))
                        (a3 (caddr args)))
                    (let ((t2->t1 (get-coercion type2 type1))
                          (t3->t1 (get-coercion type3 type1))
                          (t1->t2 (get-coercion type1 type2))
                          (t3->t2 (get-coercion type3 type2))
                          (t1->t3 (get-coercion type1 type3))
                          (t2->t3 (get-coercion type2 type3)))
                      (cond ((and t2->t1 t3->t1)
                             (apply-generic op a1 (t2->t1 a2) (t3->t1 a3)))
                            ((and t1->t2 t3->t2)
                             (apply-generic op (t1->t2 a1) a2 (t3->t2 a3)))
                            ((and t1->t3 t2->t3)
                             (apply-generic op (t1->t3 a1) (t2->t3 a2) a3))
                            (else
                             (error "No method for these types (three-types)"
                                    (list op type-tags))))))
                  (error "No method for these types"
                         (list op type-tags))))))))


;;---- INSTALL NUMBER_SYSTEM --------------

;; 태그가 2개인 이유 
;; 모든 연산자의 인자는 2개이고 하나의 인자마다 하나의 태그를 가지고 있다.
;; 따라서 (apply-generic) 함수에서 type-tags 변수는 인자들의 태그들의 리스트이므로
;; 2개의 태그 '(scheme-number scheme-number)가 된다.
;; 따라서 테이블에 연산자를 입력할 때 2개의 태그를 타입으로 입력해야 
;; 연산자의 인자들이 연산자에 맞는 인자인지를 알아낼 수 있다.
;; 만약, add 함수에 일반 정수와 유리수를 인자로 넘기면
;; type-tags 변수가 '(scheme-number rational)이 되서 데이터 타입에 오류가 있다는 것을
;; 알아낼 수 있다.


;; normal number
;; eg) (add (make-scheme-number 3) (make-scheme-number 4))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))
  (define (scheme-number->complex x)
    (make-complex-from-real-imag (cdr x) 0))
  (define (scheme-number->rational x)
    (make-rational (cdr x) 1))

  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  (put 'ex-equ? '(scheme-number scheme-number)
       (lambda (x y) (= x y)))
  (put 'ex-zero? '(scheme-number)
       (lambda (x) (= x 0)))


  (put 'add-3 '(scheme-number scheme-number scheme-number)
       (lambda (a b c) (tag (+ a b c))))

  (put-coercion 'scheme-number 'complex
                scheme-number->complex)
  (put-coercion 'scheme-number 'rational
                scheme-number->rational)

  (put 'exp '(scheme-number scheme-number)
       (lambda (x y) (tag (expt x y))))

  'done)


(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

;; rational number
;; eg) (add (make-rational 3 4) (make-rational 3 4))
(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  (define (ex-equ? x y)
    (and (= (numer x) (numer y))
         (= (denom x) (denom y))))
  (define (ex-zero? x)
    (= (numer x) 0))

  ;; interface to rest of the system
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'ex-equ? '(rational rational) ex-equ?)
  (put 'ex-zero? '(rational) ex-zero?)

  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))


(define (square a) (* a a))

;; real + imaginary number
;; 3 + 4i = (rectangular 3 . 4)
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))

  'done)

;; mag + angle number
;; 3 + 45' = (polar 3 . 45)
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

;; complex number
(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
                         (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))

  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))

  (define (scheme-number->scheme-number n) n)
  (define (complex->complex z) z)


  ;; ex2.82
  (define (add-complex-3 z1 z2 z3)
    (make-from-real-imag (+ (real-part z1) (real-part z2) (real-part z3))
                         (+ (imag-part z1) (imag-part z2) (imag-part z3))))

  (put 'add-3 '(complex complex complex)
       (lambda (z1 z2 z3) (tag (add-complex-3 z1 z2 z3))))


  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'ex-equ? '(complex complex)
       (lambda (z1 z2) (and (equal? (real-part z1) (real-part z2))
                            (equal? (imag-part z1) (imag-part z2)))))
  (put 'ex-zero? '(complex)
       (lambda (z1) (and (equal? (real-part z1) 0)
                         (equal? (imag-part z1) 0))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

  (put-coercion 'scheme-number 'scheme-number
                scheme-number->scheme-number)
  (put-coercion 'complex 'complex complex->complex)

  'done)

;; complex 숫자들은 2개의 태그를 가진다.
;; make-comple-from-real-imag에서 'complex라는 태그를 추가해주고 
;; make-from-real-imag에서 'rectangular라는 태그를 추가해서
;; (complex rectangular 3 . 4) 와 같은 형태가 된다.
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))


;; MUST INSTALL!!
(install-scheme-number-package)
(install-rational-package)
(install-polar-package)
(install-rectangular-package)
(install-complex-package)




;; test
(add-3 1 2 3)
(add-3 (make-complex-from-real-imag 1 2) (make-complex-from-real-imag 1 2) (make-complex-from-real-imag 1 2))
(add-3 (make-complex-from-real-imag 1 2) (make-scheme-number 2) (make-scheme-number 3))
(add-3 (make-scheme-number 1) (make-complex-from-real-imag 2 3) (make-scheme-number 4))
(add-3 (make-scheme-number 1) (make-scheme-number 2) (make-complex-from-real-imag 3 4))

(add (make-scheme-number 1) (make-rational 1 2)) ; ex2.81?
}}}


== 2.83.scm ==


{{{
;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;; (put <op> <type> <item>)
;; (get <op> <type>
;;------------------------------------------------


;;----- GENERIC PROCEDURES -----------------

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (ex-equ? x y) (apply-generic 'ex-equ? x y))
(define (ex-zero? x) (apply-generic 'ex-zero? x))
(define (exp x y) (apply-generic 'exp x y))
(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))
(define (add-3 a b c) (apply-generic 'add-3 a b c))

(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
        (error "Bad tagged datum -- TYPE-TAG" datum)))

(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (error "Bad tagged datum -- CONTENTS" datum)))


;; ex2.83
(define (raise x) (apply-generic 'raise x))


(define (apply-generic op . args)
  (let ((type-tags (map type-tag args))) ;; extract tags of each arguments
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args)) ;; extract data
          (error
            "No method for these types -- APPLY-GENERIC"
            (list op type-tags))))))


;;---- INSTALL NUMBER_SYSTEM --------------

;; 태그가 2개인 이유 
;; 모든 연산자의 인자는 2개이고 하나의 인자마다 하나의 태그를 가지고 있다.
;; 따라서 (apply-generic) 함수에서 type-tags 변수는 인자들의 태그들의 리스트이므로
;; 2개의 태그 '(scheme-number scheme-number)가 된다.
;; 따라서 테이블에 연산자를 입력할 때 2개의 태그를 타입으로 입력해야 
;; 연산자의 인자들이 연산자에 맞는 인자인지를 알아낼 수 있다.
;; 만약, add 함수에 일반 정수와 유리수를 인자로 넘기면
;; type-tags 변수가 '(scheme-number rational)이 되서 데이터 타입에 오류가 있다는 것을
;; 알아낼 수 있다.


;; normal number
;; eg) (add (make-scheme-number 3) (make-scheme-number 4))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))
  (define (scheme-number->complex x)
    (make-complex-from-real-imag (cdr x) 0))

  ;; ex2.83
  (define (scheme-number->rational x)
    (make-rational x 1))

  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  (put 'ex-equ? '(scheme-number scheme-number)
       (lambda (x y) (= x y)))
  (put 'ex-zero? '(scheme-number)
       (lambda (x) (= x 0)))
  (put 'add-3 '(scheme-number scheme-number scheme-number)
       (lambda (a b c) (tag (+ a b c))))
  (put 'exp '(scheme-number scheme-number)
       (lambda (x y) (tag (expt x y))))

  ;; ex2.83
  (put 'raise '(scheme-number) scheme-number->rational)
       
  'done)


(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

;; rational number
;; eg) (add (make-rational 3 4) (make-rational 3 4))
(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  (define (ex-equ? x y)
    (and (= (numer x) (numer y))
         (= (denom x) (denom y))))
  (define (ex-zero? x)
    (= (numer x) 0))

  ;; ex2.83
  (define (rational->complex x)
    (make-complex-from-real-imag (tag x) 0))

  ;; interface to rest of the system
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'ex-equ? '(rational rational) ex-equ?)
  (put 'ex-zero? '(rational) ex-zero?)


  ;; ex2.83
  (put 'raise '(rational) rational->complex)

  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))






;; real + imaginary number
;; 3 + 4i = (rectangular 3 . 4)
(define (square a) (* a a))
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))

  'done)

;; mag + angle number
;; 3 + 45' = (polar 3 . 45)
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

;; complex number
(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
                         (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))
  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))

  (define (add-complex-3 z1 z2 z3)
    (make-from-real-imag (+ (real-part z1) (real-part z2) (real-part z3))
                         (+ (imag-part z1) (imag-part z2) (imag-part z3))))

  (put 'add-3 '(complex complex complex)
       (lambda (z1 z2 z3) (tag (add-complex-3 z1 z2 z3))))

  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'ex-equ? '(complex complex)
       (lambda (z1 z2) (and (equal? (real-part z1) (real-part z2))
                            (equal? (imag-part z1) (imag-part z2)))))
  (put 'ex-zero? '(complex)
       (lambda (z1) (and (equal? (real-part z1) 0)
                         (equal? (imag-part z1) 0))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

  'done)

;; complex 숫자들은 2개의 태그를 가진다.
;; make-comple-from-real-imag에서 'complex라는 태그를 추가해주고 
;; make-from-real-imag에서 'rectangular라는 태그를 추가해서
;; (complex rectangular 3 . 4) 와 같은 형태가 된다.
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)

;; MUST INSTALL!!
(install-scheme-number-package)
(install-rational-package)
(install-polar-package)
(install-rectangular-package)
(install-complex-package)




;; test
(raise (make-scheme-number 3)) ;(rational 3 . 1)
(raise 3) ;(rational 3 . 1)
(raise (make-rational 3 4)) ;(complex rectangular (rational 3 . 4) . 0)
}}}


== 2.84.scm ==


{{{
;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;; (put <op> <type> <item>)
;; (get <op> <type>
;;------------------------------------------------


;;----- GENERIC PROCEDURES -----------------

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (ex-equ? x y) (apply-generic 'ex-equ? x y))
(define (ex-zero? x) (apply-generic 'ex-zero? x))
(define (exp x y) (apply-generic 'exp x y))
(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))
(define (add-3 a b c) (apply-generic 'add-3 a b c))

(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
        (error "Bad tagged datum -- TYPE-TAG" datum)))

(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (error "Bad tagged datum -- CONTENTS" datum)))


;; ex2.83
(define (raise x) (apply-generic 'raise x))


(define (install-get-higher-system)
  (put 'scheme-number 'rational 'rational)
  (put 'scheme-number 'complex 'complex)
  (put 'rational 'scheme-number 'rational)
  (put 'rational 'complex 'complex)
  (put 'complex 'scheme-number 'complex)
  (put 'complex 'rational 'complex))
(install-get-higher-system)       

(define (former-is-higher-system? type1 type2)
  (cond ((eq? type1 type2) #f)
        ((and (eq? type1 'rational) (eq? type2 'scheme-number)) #t)
        ((eq? type1 'complex) #t)
        (else #f)))

(define (apply-generic op . args)
  (let ((type-tags (map type-tag args))) ;; extract tags of each arguments
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args)) ;; extract data
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (if (former-is-higher-system? type1 type2)
                    (apply-generic op (car args) (raise (cadr args)))
                    (apply-generic op (raise (car args)) (cadr args))))
              (error
               "No method for these types -- APPLY-GENERIC"
               (list op type-tags)))))))


;;---- INSTALL NUMBER_SYSTEM --------------

;; 태그가 2개인 이유 
;; 모든 연산자의 인자는 2개이고 하나의 인자마다 하나의 태그를 가지고 있다.
;; 따라서 (apply-generic) 함수에서 type-tags 변수는 인자들의 태그들의 리스트이므로
;; 2개의 태그 '(scheme-number scheme-number)가 된다.
;; 따라서 테이블에 연산자를 입력할 때 2개의 태그를 타입으로 입력해야 
;; 연산자의 인자들이 연산자에 맞는 인자인지를 알아낼 수 있다.
;; 만약, add 함수에 일반 정수와 유리수를 인자로 넘기면
;; type-tags 변수가 '(scheme-number rational)이 되서 데이터 타입에 오류가 있다는 것을
;; 알아낼 수 있다.


;; normal number
;; eg) (add (make-scheme-number 3) (make-scheme-number 4))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))
  (define (scheme-number->complex x)
    (make-complex-from-real-imag (cdr x) 0))

  ;; ex2.83
  (define (scheme-number->rational x)
    (make-rational x 1))

  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  (put 'ex-equ? '(scheme-number scheme-number)
       (lambda (x y) (= x y)))
  (put 'ex-zero? '(scheme-number)
       (lambda (x) (= x 0)))
  (put 'add-3 '(scheme-number scheme-number scheme-number)
       (lambda (a b c) (tag (+ a b c))))
  (put 'exp '(scheme-number scheme-number)
       (lambda (x y) (tag (expt x y))))

  ;; ex2.83
  (put 'raise '(scheme-number) scheme-number->rational)
       
  'done)


(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

;; rational number
;; eg) (add (make-rational 3 4) (make-rational 3 4))
(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  (define (ex-equ? x y)
    (and (= (numer x) (numer y))
         (= (denom x) (denom y))))
  (define (ex-zero? x)
    (= (numer x) 0))

  ;; ex2.83
  (define (rational->complex x)
    (make-complex-from-real-imag (/ (numer x) (denom x)) 0))

  ;; interface to rest of the system
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'ex-equ? '(rational rational) ex-equ?)
  (put 'ex-zero? '(rational) ex-zero?)


  ;; ex2.83
  (put 'raise '(rational) rational->complex)

  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))



;; real + imaginary number
;; 3 + 4i = (rectangular 3 . 4)
(define (square a) (* a a))
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))

  'done)

;; mag + angle number
;; 3 + 45' = (polar 3 . 45)
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

;; complex number
(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures

  ;; ex2.83
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
                         (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))
  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))

  (define (add-complex-3 z1 z2 z3)
    (make-from-real-imag (+ (real-part z1) (real-part z2) (real-part z3))
                         (+ (imag-part z1) (imag-part z2) (imag-part z3))))

  (put 'add-3 '(complex complex complex)
       (lambda (z1 z2 z3) (tag (add-complex-3 z1 z2 z3))))

  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'ex-equ? '(complex complex)
       (lambda (z1 z2) (and (equal? (real-part z1) (real-part z2))
                            (equal? (imag-part z1) (imag-part z2)))))
  (put 'ex-zero? '(complex)
       (lambda (z1) (and (equal? (real-part z1) 0)
                         (equal? (imag-part z1) 0))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

  'done)

;; complex 숫자들은 2개의 태그를 가진다.
;; make-comple-from-real-imag에서 'complex라는 태그를 추가해주고 
;; make-from-real-imag에서 'rectangular라는 태그를 추가해서
;; (complex rectangular 3 . 4) 와 같은 형태가 된다.
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)

;; MUST INSTALL!!
(install-scheme-number-package)
(install-rational-package)
(install-polar-package)
(install-rectangular-package)
(install-complex-package)




;; test
(add (make-rational 3 4) (make-scheme-number 2)) ; (rational 11 . 4)
(add (make-scheme-number 2) (make-rational 3 4)) ;

(add (make-complex-from-real-imag 3 4) (make-scheme-number 2))
(add (make-scheme-number 2) (make-complex-from-real-imag 3 4))

(add (make-complex-from-real-imag 1 2) (make-rational 3 4))
(add (make-rational 3 4) (make-complex-from-real-imag 1 2))


(sub (make-rational 3 4) (make-scheme-number 2))
(sub (make-scheme-number 2) (make-rational 3 4)) ;

(sub (make-complex-from-real-imag 3 4) (make-scheme-number 2))
(sub (make-scheme-number 2) (make-complex-from-real-imag 3 4))

(sub (make-complex-from-real-imag 1 2) (make-rational 3 4))
(sub (make-rational 3 4) (make-complex-from-real-imag 1 2))


(mul (make-rational 3 4) (make-scheme-number 2))
(mul (make-scheme-number 2) (make-rational 3 4)) ;

(mul (make-complex-from-real-imag 3 4) (make-scheme-number 2))
(mul (make-scheme-number 2) (make-complex-from-real-imag 3 4))

(mul (make-complex-from-real-imag 1 2) (make-rational 3 4))
(mul (make-rational 3 4) (make-complex-from-real-imag 1 2))


(div (make-rational 3 4) (make-scheme-number 2))
(div (make-scheme-number 2) (make-rational 3 4)) ;

(div (make-complex-from-real-imag 3 4) (make-scheme-number 2))
(div (make-scheme-number 2) (make-complex-from-real-imag 3 4))

(div (make-complex-from-real-imag 1 2) (make-rational 3 4))
(div (make-rational 3 4) (make-complex-from-real-imag 1 2))

}}}


== 2.85.scm ==


{{{
;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;; (put <op> <type> <item>)
;; (get <op> <type>
;;------------------------------------------------


;;----- GENERIC PROCEDURES -----------------

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (ex-equ? x y) (apply-generic 'ex-equ? x y))
(define (ex-zero? x) (apply-generic 'ex-zero? x))
(define (exp x y) (apply-generic 'exp x y))
(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))
(define (add-3 a b c) (apply-generic 'add-3 a b c))

(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
        (error "Bad tagged datum -- TYPE-TAG" datum)))

(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (error "Bad tagged datum -- CONTENTS" datum)))


(define (raise x) (apply-generic 'raise x))

;; ex2.85
(define (project z)
  (apply-generic 'project z))



(define (install-get-higher-system)
  (put 'scheme-number 'rational 'rational)
  (put 'scheme-number 'complex 'complex)
  (put 'rational 'scheme-number 'rational)
  (put 'rational 'complex 'complex)
  (put 'complex 'scheme-number 'complex)
  (put 'complex 'rational 'complex))
(install-get-higher-system)       

(define (former-is-higher-system? type1 type2)
  (cond ((eq? type1 type2) #f)
        ((and (eq? type1 'rational) (eq? type2 'scheme-number)) #t)
        ((eq? type1 'complex) #t)
        (else #f)))


;;---- INSTALL NUMBER_SYSTEM --------------

;; 태그가 2개인 이유 
;; 모든 연산자의 인자는 2개이고 하나의 인자마다 하나의 태그를 가지고 있다.
;; 따라서 (apply-generic) 함수에서 type-tags 변수는 인자들의 태그들의 리스트이므로
;; 2개의 태그 '(scheme-number scheme-number)가 된다.
;; 따라서 테이블에 연산자를 입력할 때 2개의 태그를 타입으로 입력해야 
;; 연산자의 인자들이 연산자에 맞는 인자인지를 알아낼 수 있다.
;; 만약, add 함수에 일반 정수와 유리수를 인자로 넘기면
;; type-tags 변수가 '(scheme-number rational)이 되서 데이터 타입에 오류가 있다는 것을
;; 알아낼 수 있다.


;; normal number
;; eg) (add (make-scheme-number 3) (make-scheme-number 4))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))
  (define (scheme-number->complex x)
    (make-complex-from-real-imag (cdr x) 0))
  (define (scheme-number->rational x)
    (make-rational x 1))

  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  (put 'ex-equ? '(scheme-number scheme-number)
       (lambda (x y) (= x y)))
  (put 'ex-zero? '(scheme-number)
       (lambda (x) (= x 0)))
  (put 'add-3 '(scheme-number scheme-number scheme-number)
       (lambda (a b c) (tag (+ a b c))))
  (put 'exp '(scheme-number scheme-number)
       (lambda (x y) (tag (expt x y))))

  (put 'raise '(scheme-number) scheme-number->rational)
       
  'done)


(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

;; rational number
;; eg) (add (make-rational 3 4) (make-rational 3 4))
(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  (define (ex-equ? x y)
    (and (= (numer x) (numer y))
         (= (denom x) (denom y))))
  (define (ex-zero? x)
    (= (numer x) 0))

  (define (rational->complex x)
    (make-complex-from-real-imag (round (/ (numer x) (denom x))) 0))

  (define (tag x) (attach-tag 'rational x))


  ;; ex2.85
  (define (project-rational x) ; rational -> scheme-number
    (make-scheme-number (round (/ (numer x) (denom x)))))

  ;; interface to rest of the system
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'ex-equ? '(rational rational) ex-equ?)
  (put 'ex-zero? '(rational) ex-zero?)
  (put 'raise '(rational) rational->complex)

  ;; ex2.85
  (put 'project '(rational) project-rational)

  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))



;; real + imaginary number
;; 3 + 4i = (rectangular 3 . 4)
(define (square a) (* a a))
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))

  'done)

;; mag + angle number
;; 3 + 45' = (polar 3 . 45)
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

;; complex number
(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
                         (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))
  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))

  (define (add-complex-3 z1 z2 z3)
    (make-from-real-imag (+ (real-part z1) (real-part z2) (real-part z3))
                         (+ (imag-part z1) (imag-part z2) (imag-part z3))))


  ;; ex2.85
  (define (project-complex z)
    (make-rational (round (real-part z)) 1))

  (put 'add-3 '(complex complex complex)
       (lambda (z1 z2 z3) (tag (add-complex-3 z1 z2 z3))))

  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'ex-equ? '(complex complex)
       (lambda (z1 z2) (and (equal? (real-part z1) (real-part z2))
                            (equal? (imag-part z1) (imag-part z2)))))
  (put 'ex-zero? '(complex)
       (lambda (z1) (and (equal? (real-part z1) 0)
                         (equal? (imag-part z1) 0))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

  ;; ex2.85
  (put 'project '(complex) project-complex)

  'done)

;; complex 숫자들은 2개의 태그를 가진다.
;; make-comple-from-real-imag에서 'complex라는 태그를 추가해주고 
;; make-from-real-imag에서 'rectangular라는 태그를 추가해서
;; (complex rectangular 3 . 4) 와 같은 형태가 된다.
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)

;; MUST INSTALL!!
(install-scheme-number-package)
(install-rational-package)
(install-polar-package)
(install-rectangular-package)
(install-complex-package)


;; ex2.85
(define (drop x)
  (cond ((eq? (type-tag x) 'scheme-number) x)
        ((ex-equ? (raise (project x)) x) (drop (project x)))
        (else x)))


;; ex2.85

;; fail to make new apply-generic which is applied with drop procedure
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args))) ;; extract tags of each arguments
    (let ((proc (get op type-tags)))
      (if proc
          ;; I tried (drop (apply proc (map contents args))),
          ;; but it generated Stack-Overflow.
          ;; I failed to make new apply-generic procedure.
          (apply proc (map contents args)) ;; extract data
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (if (former-is-higher-system? type1 type2)
                    (apply-generic op (car args) (raise (cadr args)))
                    (apply-generic op (raise (car args)) (cadr args))))
              (error
               "No method for these types -- APPLY-GENERIC"
               (list op type-tags)))))))


;; test
(project (make-rational 3 4))
(project (make-rational 4 3))
(project (make-rational 4 1))
(project (make-complex-from-real-imag 3 4))
(project (make-complex-from-real-imag 3 0))

(raise (make-rational 3 1))

(drop (make-complex-from-real-imag 3 0))
(drop (make-complex-from-real-imag 3 1))
(drop (make-rational 4 1))
(drop (make-rational 2 2))
(drop (add (make-rational 1 2) (make-rational 1 2)))
(drop (add (make-complex-from-real-imag 3 4) (make-complex-from-real-imag 3 -4)))
(drop (add (make-scheme-number 3) (make-complex-from-real-imag 3 0)))
(project (add (make-rational 1 2) (make-complex-from-real-imag 4 0)))
(drop (add (make-rational 1 2) (make-complex-from-real-imag 4 0)))


(add (make-rational 1 2) (make-rational 1 2))

}}}


== 2.86.scm ==


{{{
;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;; (put <op> <type> <item>)
;; (get <op> <type>
;;------------------------------------------------


;;----- GENERIC PROCEDURES -----------------

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (ex-equ? x y) (apply-generic 'ex-equ? x y))
(define (ex-zero? x) (apply-generic 'ex-zero? x))
(define (exp x y) (apply-generic 'exp x y))
(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))
(define (add-3 a b c) (apply-generic 'add-3 a b c))

(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
        (error "Bad tagged datum -- TYPE-TAG" datum)))

(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (error "Bad tagged datum -- CONTENTS" datum)))

(define (raise x) (apply-generic 'raise x))

(define (project z)
  (apply-generic 'project z))

(define (install-get-higher-system)
  (put 'scheme-number 'rational 'rational)
  (put 'scheme-number 'complex 'complex)
  (put 'rational 'scheme-number 'rational)
  (put 'rational 'complex 'complex)
  (put 'complex 'scheme-number 'complex)
  (put 'complex 'rational 'complex))
(install-get-higher-system)       

(define (former-is-higher-system? type1 type2)
  (cond ((eq? type1 type2) #f)
        ((and (eq? type1 'rational) (eq? type2 'scheme-number)) #t)
        ((eq? type1 'complex) #t)
        (else #f)))

;; ex2.86
(define (sine x) (apply-generic 'sine x))


;;---- INSTALL NUMBER_SYSTEM --------------

;; 태그가 2개인 이유 
;; 모든 연산자의 인자는 2개이고 하나의 인자마다 하나의 태그를 가지고 있다.
;; 따라서 (apply-generic) 함수에서 type-tags 변수는 인자들의 태그들의 리스트이므로
;; 2개의 태그 '(scheme-number scheme-number)가 된다.
;; 따라서 테이블에 연산자를 입력할 때 2개의 태그를 타입으로 입력해야 
;; 연산자의 인자들이 연산자에 맞는 인자인지를 알아낼 수 있다.
;; 만약, add 함수에 일반 정수와 유리수를 인자로 넘기면
;; type-tags 변수가 '(scheme-number rational)이 되서 데이터 타입에 오류가 있다는 것을
;; 알아낼 수 있다.


;; normal number
;; eg) (add (make-scheme-number 3) (make-scheme-number 4))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))
  (define (scheme-number->complex x)
    (make-complex-from-real-imag (cdr x) 0))
  (define (scheme-number->rational x)
    (make-rational x 1))

  ; ex2.86
  ;;(define (sine-scheme-number x)) ;;????????????????

  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  (put 'ex-equ? '(scheme-number scheme-number)
       (lambda (x y) (= x y)))
  (put 'ex-zero? '(scheme-number)
       (lambda (x) (= x 0)))
  (put 'add-3 '(scheme-number scheme-number scheme-number)
       (lambda (a b c) (tag (+ a b c))))
  (put 'exp '(scheme-number scheme-number)
       (lambda (x y) (tag (expt x y))))

  (put 'raise '(scheme-number) scheme-number->rational)
       
  ; ex2.86
  (put 'sine '(scheme-number) sine-scheme-number)

  'done)


(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

;; rational number
;; eg) (add (make-rational 3 4) (make-rational 3 4))
(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  (define (ex-equ? x y)
    (and (= (numer x) (numer y))
         (= (denom x) (denom y))))
  (define (ex-zero? x)
    (= (numer x) 0))

  (define (rational->complex x)
    (make-complex-from-real-imag (round (/ (numer x) (denom x))) 0))

  (define (tag x) (attach-tag 'rational x))

  (define (project-rational x) ; rational -> scheme-number
    (make-scheme-number (round (/ (numer x) (denom x)))))

  ;; ex2.86
  ;;(define (sine-rational x)) ;;??????????????????????

  ;; interface to rest of the system
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'ex-equ? '(rational rational) ex-equ?)
  (put 'ex-zero? '(rational) ex-zero?)
  (put 'raise '(rational) rational->complex)
  (put 'project '(rational) project-rational)

  ;; ex2.86
  (put 'sine '(rational) 'sine-rational)

  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))



;; real + imaginary number
;; 3 + 4i = (rectangular 3 . 4)
(define (square a) (* a a))
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))

  'done)

;; mag + angle number
;; 3 + 45' = (polar 3 . 45)
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

;; complex number
(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures

  ;; ex2.86
  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
                         (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))
  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))

  (define (add-complex-3 z1 z2 z3)
    (make-from-real-imag (+ (real-part z1) (real-part z2) (real-part z3))
                         (+ (imag-part z1) (imag-part z2) (imag-part z3))))

  (define (project-complex z)
    (make-rational (round (real-part z)) 1))

  (put 'add-3 '(complex complex complex)
       (lambda (z1 z2 z3) (tag (add-complex-3 z1 z2 z3))))

  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'ex-equ? '(complex complex)
       (lambda (z1 z2) (and (equal? (real-part z1) (real-part z2))
                            (equal? (imag-part z1) (imag-part z2)))))
  (put 'ex-zero? '(complex)
       (lambda (z1) (and (equal? (real-part z1) 0)
                         (equal? (imag-part z1) 0))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

  (put 'project '(complex) project-complex)

  'done)

;; complex 숫자들은 2개의 태그를 가진다.
;; make-comple-from-real-imag에서 'complex라는 태그를 추가해주고 
;; make-from-real-imag에서 'rectangular라는 태그를 추가해서
;; (complex rectangular 3 . 4) 와 같은 형태가 된다.
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)

;; MUST INSTALL!!
(install-scheme-number-package)
(install-rational-package)
(install-polar-package)
(install-rectangular-package)
(install-complex-package)


(define (drop x)
  (cond ((eq? (type-tag x) 'scheme-number) x)
        ((ex-equ? (raise (project x)) x) (drop (project x)))
        (else x)))


;; fail to make new apply-generic which is applied with drop procedure
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args))) ;; extract tags of each arguments
    (let ((proc (get op type-tags)))
      (if proc
          ;; I tried (drop (apply proc (map contents args))),
          ;; but it generated Stack-Overflow.
          ;; I failed to make new apply-generic procedure.
          (apply proc (map contents args)) ;; extract data
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (if (former-is-higher-system? type1 type2)
                    (apply-generic op (car args) (raise (cadr args)))
                    (apply-generic op (raise (car args)) (cadr args))))
              (error
               "No method for these types -- APPLY-GENERIC"
               (list op type-tags)))))))


;; test
;; FAIL to solve ex2.86


}}}


== 2.87.scm ==


{{{
;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;; (put <op> <type> <item>)
;; (get <op> <type>
;;------------------------------------------------


;;----- GENERIC PROCEDURES -----------------

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (ex-equ? x y) (apply-generic 'ex-equ? x y))
(define (ex-zero? x) (apply-generic 'ex-zero? x))
(define (exp x y) (apply-generic 'exp x y))
(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))
(define (add-3 a b c) (apply-generic 'add-3 a b c))

(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
        (error "Bad tagged datum -- TYPE-TAG" datum)))

(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (error "Bad tagged datum -- CONTENTS" datum)))

(define (raise x) (apply-generic 'raise x))

(define (project z)
  (apply-generic 'project z))

(define (install-get-higher-system)
  (put 'scheme-number 'rational 'rational)
  (put 'scheme-number 'complex 'complex)
  (put 'rational 'scheme-number 'rational)
  (put 'rational 'complex 'complex)
  (put 'complex 'scheme-number 'complex)
  (put 'complex 'rational 'complex))
(install-get-higher-system)       

(define (former-is-higher-system? type1 type2)
  (cond ((eq? type1 type2) #f)
        ((and (eq? type1 'rational) (eq? type2 'scheme-number)) #t)
        ((eq? type1 'complex) #t)
        (else #f)))

(define (drop x)
  (cond ((eq? (type-tag x) 'scheme-number) x)
        ((ex-equ? (raise (project x)) x) (drop (project x)))
        (else x)))


;; fail to make new apply-generic which is applied with drop procedure
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args))) ;; extract tags of each arguments
    (let ((proc (get op type-tags)))
      (if proc
          ;; I tried (drop (apply proc (map contents args))),
          ;; but it generated Stack-Overflow.
          ;; I failed to make new apply-generic procedure.
          (apply proc (map contents args)) ;; extract data
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (if (former-is-higher-system? type1 type2)
                    (apply-generic op (car args) (raise (cadr args)))
                    (apply-generic op (raise (car args)) (cadr args))))
              (error
               "No method for these types -- APPLY-GENERIC"
               (list op type-tags)))))))


;;------ Number Systems ----------------------

;; normal number
;; eg) (add (make-scheme-number 3) (make-scheme-number 4))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))
  (define (scheme-number->complex x)
    (make-complex-from-real-imag (cdr x) 0))
  (define (scheme-number->rational x)
    (make-rational x 1))


  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  (put 'ex-equ? '(scheme-number scheme-number)
       (lambda (x y) (= x y)))
  (put 'ex-zero? '(scheme-number)
       (lambda (x) (= x 0)))
  (put 'add-3 '(scheme-number scheme-number scheme-number)
       (lambda (a b c) (tag (+ a b c))))
  (put 'exp '(scheme-number scheme-number)
       (lambda (x y) (tag (expt x y))))

  (put 'raise '(scheme-number) scheme-number->rational)
       

  'done)


(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

;; rational number
;; eg) (add (make-rational 3 4) (make-rational 3 4))
(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  (define (ex-equ? x y)
    (and (= (numer x) (numer y))
         (= (denom x) (denom y))))
  (define (ex-zero? x)
    (= (numer x) 0))

  (define (rational->complex x)
    (make-complex-from-real-imag (round (/ (numer x) (denom x))) 0))

  (define (tag x) (attach-tag 'rational x))

  (define (project-rational x) ; rational -> scheme-number
    (make-scheme-number (round (/ (numer x) (denom x)))))


  ;; interface to rest of the system
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'ex-equ? '(rational rational) ex-equ?)
  (put 'ex-zero? '(rational) ex-zero?)
  (put 'raise '(rational) rational->complex)
  (put 'project '(rational) project-rational)


  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))



;; real + imaginary number
;; 3 + 4i = (rectangular 3 . 4)
(define (square a) (* a a))
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))

  'done)

;; mag + angle number
;; 3 + 45' = (polar 3 . 45)
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

;; complex number
(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures

  ;; ex2.86
  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
                         (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))
  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))

  (define (add-complex-3 z1 z2 z3)
    (make-from-real-imag (+ (real-part z1) (real-part z2) (real-part z3))
                         (+ (imag-part z1) (imag-part z2) (imag-part z3))))

  (define (project-complex z)
    (make-rational (round (real-part z)) 1))

  (put 'add-3 '(complex complex complex)
       (lambda (z1 z2 z3) (tag (add-complex-3 z1 z2 z3))))

  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'ex-equ? '(complex complex)
       (lambda (z1 z2) (and (equal? (real-part z1) (real-part z2))
                            (equal? (imag-part z1) (imag-part z2)))))
  (put 'ex-zero? '(complex)
       (lambda (z1) (and (equal? (real-part z1) 0)
                         (equal? (imag-part z1) 0))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

  (put 'project '(complex) project-complex)

  'done)

;; complex 숫자들은 2개의 태그를 가진다.
;; make-comple-from-real-imag에서 'complex라는 태그를 추가해주고 
;; make-from-real-imag에서 'rectangular라는 태그를 추가해서
;; (complex rectangular 3 . 4) 와 같은 형태가 된다.
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)



;;---------- ch2.5.3 -------------------------------

(define (install-polynomial-package)
  ;; from ch2.3.2
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))

  (define (make-poly variable term-list)
    (cons variable term-list))

  (define (variable p) (car p))
  (define (term-list p) (cdr p))

  ;; ex2.87
  (define (zero-termlist? terms)
    (cond ((empty-termlist? terms)
           #t)
          ((zero? (coeff (first-term terms)))
           (zero-termlist? (rest-term terms)))
          (else
           #f)))


  (define (adjoin-term term term-list)
    (if (ex-zero? (coeff term))
        term-list
        (cons term term-list)))

  (define (the-empty-termlist) '())
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))

  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))


  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1))
                 (t2 (first-term L2)))
             (cond ((> (order t1) (order t2))
                    (adjoin-term t1
                                 (add-terms (rest-terms L1) L2)))
                   ((< (order t1) (order t2))
                    (adjoin-term t2
                                 (add-terms L1 (rest-terms L2))))
                   (else
                    (adjoin-term
                     (make-term (order t1)
                                (add (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))
                     
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
             
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ((t2 (first-term L)))
          (adjoin-term
           (make-term (+ (order t1) (order t2)) ; order of term
                      (mul (coeff t1) (coeff t2))) ; coeff of term
           (mul-term-by-all-terms t1 (rest-terms L))))))



  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- ADD-POLY" (list p1 p2))))

  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (mul-terms (term-list p1)
                             (term-list p2)))
        (error "Polys not in same var -- MUL-POLY" (list p1 p2))))

  (define (tag p) (attach-tag 'polynomial p))

  ;; install operations
  (put 'add '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2) (tag (mul-poly p2 p1))))
  (put 'make 'polynomial
       (lambda (var terms) (tag (make-poly var terms))))

  ;; ex2.87
  (put 'ex-zero? '(polynomial) 
       (lambda (terms) (zero-termlist? (term-list terms))))

  'done)

(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))
                 
;;--------- test ----------------

;; MUST INSTALL!!
(install-scheme-number-package)
(install-rational-package)
(install-polar-package)
(install-rectangular-package)
(install-complex-package)
(install-polynomial-package)


(define test-termlist (make-polynomial 'x '((100 1) (2 2) (0 1))))
(ex-zero? test-termlist)
(ex-zero? (make-polynomial 'x '((100 0) (2 0) (0 0))))
(ex-zero? (make-polynomial 'x '((100 0) (2 0) (0 1))))
}}}


== 2.88.scm ==


{{{
;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;; (put <op> <type> <item>)
;; (get <op> <type>
;;------------------------------------------------


;;----- GENERIC PROCEDURES -----------------

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (ex-equ? x y) (apply-generic 'ex-equ? x y))
(define (ex-zero? x) (apply-generic 'ex-zero? x))
(define (exp x y) (apply-generic 'exp x y))
(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))
(define (add-3 a b c) (apply-generic 'add-3 a b c))

;; ex2.88
(define (negation x) (apply-generic 'negation x))

(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
        (error "Bad tagged datum -- TYPE-TAG" datum)))

(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (error "Bad tagged datum -- CONTENTS" datum)))

(define (raise x) (apply-generic 'raise x))

(define (project z)
  (apply-generic 'project z))

(define (install-get-higher-system)
  (put 'scheme-number 'rational 'rational)
  (put 'scheme-number 'complex 'complex)
  (put 'rational 'scheme-number 'rational)
  (put 'rational 'complex 'complex)
  (put 'complex 'scheme-number 'complex)
  (put 'complex 'rational 'complex))
(install-get-higher-system)       

(define (former-is-higher-system? type1 type2)
  (cond ((eq? type1 type2) #f)
        ((and (eq? type1 'rational) (eq? type2 'scheme-number)) #t)
        ((eq? type1 'complex) #t)
        (else #f)))

(define (drop x)
  (cond ((eq? (type-tag x) 'scheme-number) x)
        ((ex-equ? (raise (project x)) x) (drop (project x)))
        (else x)))


;; fail to make new apply-generic which is applied with drop procedure
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args))) ;; extract tags of each arguments
    (let ((proc (get op type-tags)))
      (if proc
          ;; I tried (drop (apply proc (map contents args))),
          ;; but it generated Stack-Overflow.
          ;; I failed to make new apply-generic procedure.
          (apply proc (map contents args)) ;; extract data
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (if (former-is-higher-system? type1 type2)
                    (apply-generic op (car args) (raise (cadr args)))
                    (apply-generic op (raise (car args)) (cadr args))))
              (error
               "No method for these types -- APPLY-GENERIC"
               (list op type-tags)))))))


;;------ Number Systems ----------------------

;; normal number
;; eg) (add (make-scheme-number 3) (make-scheme-number 4))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))
  (define (scheme-number->complex x)
    (make-complex-from-real-imag (cdr x) 0))
  (define (scheme-number->rational x)
    (make-rational x 1))


  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  (put 'ex-equ? '(scheme-number scheme-number)
       (lambda (x y) (= x y)))
  (put 'ex-zero? '(scheme-number)
       (lambda (x) (= x 0)))
  (put 'add-3 '(scheme-number scheme-number scheme-number)
       (lambda (a b c) (tag (+ a b c))))
  (put 'exp '(scheme-number scheme-number)
       (lambda (x y) (tag (expt x y))))

  (put 'raise '(scheme-number) scheme-number->rational)


  ;; ex2.88
  (put 'negation '(scheme-number)
       (lambda (x) (tag (- x))))

  'done)


(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

;; rational number
;; eg) (add (make-rational 3 4) (make-rational 3 4))
(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  (define (ex-equ? x y)
    (and (= (numer x) (numer y))
         (= (denom x) (denom y))))
  (define (ex-zero? x)
    (= (numer x) 0))

  (define (rational->complex x)
    (make-complex-from-real-imag (round (/ (numer x) (denom x))) 0))

  (define (tag x) (attach-tag 'rational x))

  (define (project-rational x) ; rational -> scheme-number
    (make-scheme-number (round (/ (numer x) (denom x)))))


  ;; interface to rest of the system
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'ex-equ? '(rational rational) ex-equ?)
  (put 'ex-zero? '(rational) ex-zero?)
  (put 'raise '(rational) rational->complex)
  (put 'project '(rational) project-rational)

  (put 'negation '(rational)
       (lambda (x) (tag (make-rat ( - (numer x))
                                  (denom x)))))

  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))



;; real + imaginary number
;; 3 + 4i = (rectangular 3 . 4)
(define (square a) (* a a))
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))

  'done)

;; mag + angle number
;; 3 + 45' = (polar 3 . 45)
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

;; complex number
(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures

  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
                         (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))
  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))

  (define (add-complex-3 z1 z2 z3)
    (make-from-real-imag (+ (real-part z1) (real-part z2) (real-part z3))
                         (+ (imag-part z1) (imag-part z2) (imag-part z3))))

  (define (project-complex z)
    (make-rational (round (real-part z)) 1))

  (put 'add-3 '(complex complex complex)
       (lambda (z1 z2 z3) (tag (add-complex-3 z1 z2 z3))))

  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'ex-equ? '(complex complex)
       (lambda (z1 z2) (and (equal? (real-part z1) (real-part z2))
                            (equal? (imag-part z1) (imag-part z2)))))
  (put 'ex-zero? '(complex)
       (lambda (z1) (and (equal? (real-part z1) 0)
                         (equal? (imag-part z1) 0))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

  (put 'project '(complex) project-complex)

  (put 'negation '(complex)
       (lambda (z) (display "귀찮아서 안만듬")))

  'done)

;; complex 숫자들은 2개의 태그를 가진다.
;; make-comple-from-real-imag에서 'complex라는 태그를 추가해주고 
;; make-from-real-imag에서 'rectangular라는 태그를 추가해서
;; (complex rectangular 3 . 4) 와 같은 형태가 된다.
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)



;;---------- ch2.5.3 -------------------------------

(define (install-polynomial-package)
  ;; from ch2.3.2
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))

  (define (make-poly variable term-list)
    (cons variable term-list))

  (define (variable p) (car p))
  (define (term-list p) (cdr p))

  (define (zero-termlist? terms)
    (cond ((empty-termlist? terms)
           #t)
          ((zero? (coeff (first-term terms)))
           (zero-termlist? (rest-term terms)))
          (else
           #f)))


  (define (adjoin-term term term-list)
    (if (ex-zero? (coeff term))
        term-list
        (cons term term-list)))

  (define (the-empty-termlist) '())
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))

  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))


  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1))
                 (t2 (first-term L2)))
             (cond ((> (order t1) (order t2))
                    (adjoin-term t1
                                 (add-terms (rest-terms L1) L2)))
                   ((< (order t1) (order t2))
                    (adjoin-term t2
                                 (add-terms L1 (rest-terms L2))))
                   (else
                    (adjoin-term
                     (make-term (order t1)
                                (add (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))
                     
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
             
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ((t2 (first-term L)))
          (adjoin-term
           (make-term (+ (order t1) (order t2)) ; order of term
                      (mul (coeff t1) (coeff t2))) ; coeff of term
           (mul-term-by-all-terms t1 (rest-terms L))))))



  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- ADD-POLY" (list p1 p2))))

  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (mul-terms (term-list p1)
                             (term-list p2)))
        (error "Polys not in same var -- MUL-POLY" (list p1 p2))))

  
  ;; ex2.88
  (define (negation-termlist termlist)
    (if (empty-termlist? termlist) '()
        (adjoin-term 
         (make-term (order (first-term termlist))
                    ; use negation again that can handle any type of coeff
                    (negation (coeff (first-term termlist))))
         (negation-termlist (rest-terms termlist)))))


  (define (tag p) (attach-tag 'polynomial p))

  ;; install operations
  (put 'add '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2) (tag (mul-poly p2 p1))))
  (put 'make 'polynomial
       (lambda (var terms) (tag (make-poly var terms))))

  ;; term-list를 반드시 호출해야
  ;; 변수가 없어지고 각 term을 곧바로 처리할 수 있게 된다.
  (put 'ex-zero? '(polynomial) 
       (lambda (terms) (zero-termlist? (term-list terms))))

  ;; ex2.88
  ;; 
  (put 'negation '(polynomial)
       (lambda (termlist)
         (tag (make-poly (variable termlist)
                         (negation-termlist (term-list termlist))))))

  (put 'sub '(polynomial polynomial)
       (lambda (p1 p2) (add (tag p1)
                            (negation (tag p2)))))
  ; negation은 generic이므로 호출을 위해서는 태그가 필요하다.
  ; 하지만 sub가 호출되면서 태그가 벗겨지므로 다시 태그를 붙여준다.
  ; 그리고 p1도 태그를 다시 붙여줘야 generic한 add를 호출할 수 있다.
  ; p1에 태그를 안붙이고 negation 결과에 태그를 붙여서
  ; add-poly를 호출해도 된다.

  'done)

(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))




                 
;;--------- test ----------------

;; MUST INSTALL!!
(install-scheme-number-package)
(install-rational-package)
(install-polar-package)
(install-rectangular-package)
(install-complex-package)
(install-polynomial-package)


(define test-termlist (make-polynomial 'x '((100 1) (2 2) (0 1))))
(add test-termlist test-termlist)
(mul test-termlist test-termlist)

(negation test-termlist)
(ex-zero? (add test-termlist (negation test-termlist)))
(sub test-termlist test-termlist)
}}}


== 2.89.scm ==


{{{
;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;; (put <op> <type> <item>)
;; (get <op> <type>
;;------------------------------------------------


;;----- GENERIC PROCEDURES -----------------

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (ex-equ? x y) (apply-generic 'ex-equ? x y))
(define (ex-zero? x) (apply-generic 'ex-zero? x))
(define (exp x y) (apply-generic 'exp x y))
(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))
(define (add-3 a b c) (apply-generic 'add-3 a b c))

;; ex2.88
(define (negation x) (apply-generic 'negation x))

(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
        (error "Bad tagged datum -- TYPE-TAG" datum)))

(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (error "Bad tagged datum -- CONTENTS" datum)))

(define (raise x) (apply-generic 'raise x))

(define (project z)
  (apply-generic 'project z))

(define (install-get-higher-system)
  (put 'scheme-number 'rational 'rational)
  (put 'scheme-number 'complex 'complex)
  (put 'rational 'scheme-number 'rational)
  (put 'rational 'complex 'complex)
  (put 'complex 'scheme-number 'complex)
  (put 'complex 'rational 'complex))
(install-get-higher-system)       

(define (former-is-higher-system? type1 type2)
  (cond ((eq? type1 type2) #f)
        ((and (eq? type1 'rational) (eq? type2 'scheme-number)) #t)
        ((eq? type1 'complex) #t)
        (else #f)))

(define (drop x)
  (cond ((eq? (type-tag x) 'scheme-number) x)
        ((ex-equ? (raise (project x)) x) (drop (project x)))
        (else x)))


;; fail to make new apply-generic which is applied with drop procedure
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args))) ;; extract tags of each arguments
    (let ((proc (get op type-tags)))
      (if proc
          ;; I tried (drop (apply proc (map contents args))),
          ;; but it generated Stack-Overflow.
          ;; I failed to make new apply-generic procedure.
          (apply proc (map contents args)) ;; extract data
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (if (former-is-higher-system? type1 type2)
                    (apply-generic op (car args) (raise (cadr args)))
                    (apply-generic op (raise (car args)) (cadr args))))
              (error
               "No method for these types -- APPLY-GENERIC"
               (list op type-tags)))))))


;;------ Number Systems ----------------------

;; normal number
;; eg) (add (make-scheme-number 3) (make-scheme-number 4))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))
  (define (scheme-number->complex x)
    (make-complex-from-real-imag (cdr x) 0))
  (define (scheme-number->rational x)
    (make-rational x 1))


  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  (put 'ex-equ? '(scheme-number scheme-number)
       (lambda (x y) (= x y)))
  (put 'ex-zero? '(scheme-number)
       (lambda (x) (= x 0)))
  (put 'add-3 '(scheme-number scheme-number scheme-number)
       (lambda (a b c) (tag (+ a b c))))
  (put 'exp '(scheme-number scheme-number)
       (lambda (x y) (tag (expt x y))))

  (put 'raise '(scheme-number) scheme-number->rational)


  ;; ex2.88
  (put 'negation '(scheme-number)
       (lambda (x) (tag (- x))))

  'done)


(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

;; rational number
;; eg) (add (make-rational 3 4) (make-rational 3 4))
(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  (define (ex-equ? x y)
    (and (= (numer x) (numer y))
         (= (denom x) (denom y))))
  (define (ex-zero? x)
    (= (numer x) 0))

  (define (rational->complex x)
    (make-complex-from-real-imag (round (/ (numer x) (denom x))) 0))

  (define (tag x) (attach-tag 'rational x))

  (define (project-rational x) ; rational -> scheme-number
    (make-scheme-number (round (/ (numer x) (denom x)))))


  ;; interface to rest of the system
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'ex-equ? '(rational rational) ex-equ?)
  (put 'ex-zero? '(rational) ex-zero?)
  (put 'raise '(rational) rational->complex)
  (put 'project '(rational) project-rational)

  (put 'negation '(rational)
       (lambda (x) (tag (make-rat ( - (numer x))
                                  (denom x)))))

  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))



;; real + imaginary number
;; 3 + 4i = (rectangular 3 . 4)
(define (square a) (* a a))
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))

  'done)

;; mag + angle number
;; 3 + 45' = (polar 3 . 45)
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

;; complex number
(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures

  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
                         (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))
  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))

  (define (add-complex-3 z1 z2 z3)
    (make-from-real-imag (+ (real-part z1) (real-part z2) (real-part z3))
                         (+ (imag-part z1) (imag-part z2) (imag-part z3))))

  (define (project-complex z)
    (make-rational (round (real-part z)) 1))

  (put 'add-3 '(complex complex complex)
       (lambda (z1 z2 z3) (tag (add-complex-3 z1 z2 z3))))

  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'ex-equ? '(complex complex)
       (lambda (z1 z2) (and (equal? (real-part z1) (real-part z2))
                            (equal? (imag-part z1) (imag-part z2)))))
  (put 'ex-zero? '(complex)
       (lambda (z1) (and (equal? (real-part z1) 0)
                         (equal? (imag-part z1) 0))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

  (put 'project '(complex) project-complex)

  (put 'negation '(complex)
       (lambda (z) (display "귀찮아서 안만듬")))

  'done)

;; complex 숫자들은 2개의 태그를 가진다.
;; make-comple-from-real-imag에서 'complex라는 태그를 추가해주고 
;; make-from-real-imag에서 'rectangular라는 태그를 추가해서
;; (complex rectangular 3 . 4) 와 같은 형태가 된다.
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)



;;---------- ch2.5.3 -------------------------------

(define (install-polynomial-package)
  ;; from ch2.3.2
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))

  (define (make-poly variable term-list)
    (cons variable term-list))

  (define (variable p) (car p))
  (define (term-list p) (cdr p))

  (define (zero-termlist? terms)
    (cond ((empty-termlist? terms)
           #t)
          ((zero? (coeff (first-term terms)))
           (zero-termlist? (rest-terms terms)))
          (else
           #f)))


  (define (adjoin-term term term-list)
    (if (ex-zero? (coeff term))
        term-list
        (cons term term-list)))

  (define (the-empty-termlist) '())
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))

  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))


  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1))
                 (t2 (first-term L2)))
             (cond ((> (order t1) (order t2))
                    (adjoin-term t1
                                 (add-terms (rest-terms L1) L2)))
                   ((< (order t1) (order t2))
                    (adjoin-term t2
                                 (add-terms L1 (rest-terms L2))))
                   (else
                    (adjoin-term
                     (make-term (order t1)
                                (add (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))
                     
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
             
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ((t2 (first-term L)))
          (adjoin-term
           (make-term (+ (order t1) (order t2)) ; order of term
                      (mul (coeff t1) (coeff t2))) ; coeff of term
           (mul-term-by-all-terms t1 (rest-terms L))))))



  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- ADD-POLY" (list p1 p2))))

  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (mul-terms (term-list p1)
                             (term-list p2)))
        (error "Polys not in same var -- MUL-POLY" (list p1 p2))))

  
  ;; ex2.88
  (define (negation-termlist termlist)
    (if (empty-termlist? termlist) '()
        (adjoin-term 
         (make-term (order (first-term termlist))
                    ; use negation again that can handle any type of coeff
                    (negation (coeff (first-term termlist))))
         (negation-termlist (rest-terms termlist)))))


  (define (tag p) (attach-tag 'polynomial p))



  ;; ex2.89
  (define (make-dense-from-sparse sparse-termlist)
    (if (empty-termlist? sparse-termlist) '()
        (make-dense-from-sparse-body (order (first-term sparse-termlist))
                                     sparse-termlist
                                     '())))
  (define (make-dense-from-sparse-body current-order termlist newlist)
    (cond ((< current-order 0) newlist)
          ((empty-termlist? termlist)
           (make-dense-from-sparse-body
            (- current-order 1)
            termlist
            (append newlist (list 0))))
          ((= current-order (order (first-term termlist)))
           (make-dense-from-sparse-body
            (- current-order 1)
            (rest-terms termlist)
            (append newlist (list (coeff (first-term termlist))))))
          (else
           (make-dense-from-sparse-body
            (- current-order 1)
            termlist
            (append newlist (list 0))))))


  ;; install operations
  (put 'add '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2) (tag (mul-poly p2 p1))))
  (put 'make 'polynomial
       (lambda (var terms) (tag (make-poly var terms))))

  ;; term-list를 반드시 호출해야
  ;; 변수가 없어지고 각 term을 곧바로 처리할 수 있게 된다.
  (put 'ex-zero? '(polynomial) 
       (lambda (terms) (zero-termlist? (term-list terms))))

  ;; ex2.88
  ;; 
  (put 'negation '(polynomial)
       (lambda (termlist)
         (tag (make-poly (variable termlist)
                         (negation-termlist (term-list termlist))))))

  (put 'sub '(polynomial polynomial)
       (lambda (p1 p2) (add (tag p1)
                            (negation (tag p2)))))
  ; negation은 generic이므로 호출을 위해서는 태그가 필요하다.
  ; 하지만 sub가 호출되면서 태그가 벗겨지므로 다시 태그를 붙여준다.
  ; 그리고 p1도 태그를 다시 붙여줘야 generic한 add를 호출할 수 있다.
  ; p1에 태그를 안붙이고 negation 결과에 태그를 붙여서
  ; add-poly를 호출해도 된다.


  (put 'make-dense-from-sparse '(polynomial) 
       (lambda (x) (tag (make-poly (variable x)
                                   (make-dense-from-sparse (term-list x))))))
       

  'done)

(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))




                 
;;--------- test ----------------

;; MUST INSTALL!!
(install-scheme-number-package)
(install-rational-package)
(install-polar-package)
(install-rectangular-package)
(install-complex-package)
(install-polynomial-package)


(define test-termlist (make-polynomial 'x '((100 1) (2 2) (0 1))))
(add test-termlist test-termlist)
(mul test-termlist test-termlist)

(define (make-dense-from-sparse x)
  (apply-generic 'make-dense-from-sparse x))
                                      
(make-dense-from-sparse test-termlist)
(make-dense-from-sparse (make-polynomial 'x '((100 1))))

;; both of followings should be the same
(make-dense-from-sparse (make-polynomial 'x '((100 0))))
(make-dense-from-sparse (make-polynomial 'x '()))
}}}


== 2.90.scm ==


{{{
;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;; (put <op> <type> <item>)
;; (get <op> <type>
;;------------------------------------------------


;;----- GENERIC PROCEDURES -----------------

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (ex-equ? x y) (apply-generic 'ex-equ? x y))
(define (ex-zero? x) (apply-generic 'ex-zero? x))
(define (exp x y) (apply-generic 'exp x y))
(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))
(define (add-3 a b c) (apply-generic 'add-3 a b c))

(define (negation x) (apply-generic 'negation x))

(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
        (error "Bad tagged datum -- TYPE-TAG" datum)))

(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (error "Bad tagged datum -- CONTENTS" datum)))

(define (raise x) (apply-generic 'raise x))

(define (project z)
  (apply-generic 'project z))

(define (install-get-higher-system)
  (put 'scheme-number 'rational 'rational)
  (put 'scheme-number 'complex 'complex)
  (put 'rational 'scheme-number 'rational)
  (put 'rational 'complex 'complex)
  (put 'complex 'scheme-number 'complex)
  (put 'complex 'rational 'complex))
(install-get-higher-system)       

(define (former-is-higher-system? type1 type2)
  (cond ((eq? type1 type2) #f)
        ((and (eq? type1 'rational) (eq? type2 'scheme-number)) #t)
        ((eq? type1 'complex) #t)
        (else #f)))

(define (drop x)
  (cond ((eq? (type-tag x) 'scheme-number) x)
        ((ex-equ? (raise (project x)) x) (drop (project x)))
        (else x)))


;; fail to make new apply-generic which is applied with drop procedure
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args))) ;; extract tags of each arguments
    (let ((proc (get op type-tags)))
      (if proc
          ;; I tried (drop (apply proc (map contents args))),
          ;; but it generated Stack-Overflow.
          ;; I failed to make new apply-generic procedure.
          (apply proc (map contents args)) ;; extract data
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (if (former-is-higher-system? type1 type2)
                    (apply-generic op (car args) (raise (cadr args)))
                    (apply-generic op (raise (car args)) (cadr args))))
              (error
               "No method for these types -- APPLY-GENERIC"
               (list op type-tags)))))))


;;------ Number Systems ----------------------

;; normal number
;; eg) (add (make-scheme-number 3) (make-scheme-number 4))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))
  (define (scheme-number->complex x)
    (make-complex-from-real-imag (cdr x) 0))
  (define (scheme-number->rational x)
    (make-rational x 1))


  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  (put 'ex-equ? '(scheme-number scheme-number)
       (lambda (x y) (= x y)))
  (put 'ex-zero? '(scheme-number)
       (lambda (x) (= x 0)))
  (put 'add-3 '(scheme-number scheme-number scheme-number)
       (lambda (a b c) (tag (+ a b c))))
  (put 'exp '(scheme-number scheme-number)
       (lambda (x y) (tag (expt x y))))

  (put 'raise '(scheme-number) scheme-number->rational)

  (put 'negation '(scheme-number)
       (lambda (x) (tag (- x))))

  'done)


(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

;; rational number
;; eg) (add (make-rational 3 4) (make-rational 3 4))
(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  (define (ex-equ? x y)
    (and (= (numer x) (numer y))
         (= (denom x) (denom y))))
  (define (ex-zero? x)
    (= (numer x) 0))

  (define (rational->complex x)
    (make-complex-from-real-imag (round (/ (numer x) (denom x))) 0))

  (define (tag x) (attach-tag 'rational x))

  (define (project-rational x) ; rational -> scheme-number
    (make-scheme-number (round (/ (numer x) (denom x)))))


  ;; interface to rest of the system
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'ex-equ? '(rational rational) ex-equ?)
  (put 'ex-zero? '(rational) ex-zero?)
  (put 'raise '(rational) rational->complex)
  (put 'project '(rational) project-rational)

  (put 'negation '(rational)
       (lambda (x) (tag (make-rat ( - (numer x))
                                  (denom x)))))

  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))



;; real + imaginary number
;; 3 + 4i = (rectangular 3 . 4)
(define (square a) (* a a))
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))

  'done)

;; mag + angle number
;; 3 + 45' = (polar 3 . 45)
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

;; complex number
(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures

  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
                         (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))
  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))

  (define (add-complex-3 z1 z2 z3)
    (make-from-real-imag (+ (real-part z1) (real-part z2) (real-part z3))
                         (+ (imag-part z1) (imag-part z2) (imag-part z3))))

  (define (project-complex z)
    (make-rational (round (real-part z)) 1))

  (put 'add-3 '(complex complex complex)
       (lambda (z1 z2 z3) (tag (add-complex-3 z1 z2 z3))))

  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'ex-equ? '(complex complex)
       (lambda (z1 z2) (and (equal? (real-part z1) (real-part z2))
                            (equal? (imag-part z1) (imag-part z2)))))
  (put 'ex-zero? '(complex)
       (lambda (z1) (and (equal? (real-part z1) 0)
                         (equal? (imag-part z1) 0))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

  (put 'project '(complex) project-complex)

  (put 'negation '(complex)
       (lambda (z) (display "귀찮아서 안만듬")))

  'done)

;; complex 숫자들은 2개의 태그를 가진다.
;; make-comple-from-real-imag에서 'complex라는 태그를 추가해주고 
;; make-from-real-imag에서 'rectangular라는 태그를 추가해서
;; (complex rectangular 3 . 4) 와 같은 형태가 된다.
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)



;;-------------- ex2.90 ----------------------------------------
;;
;; 1. make install-sparse-polynomial-package
;; 2. make install-dense-polynomial-package
;; 3. make install-polynomial-package
;; 4. make-polynomial-from-termlist, make-polynomial-from-coefflist
;; 5. make-dense-polynomial-from-sparse, make-sparse-polynomial-from-dense
;; 6. generic add,mul,sub


;; sparse polynomial : variable and list of (order coeff)
;; eg) ('x ((100 2) (2 4) (0 5)))
(define (install-sparse-polynomial-package)
  ;; from ch2.3.2
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))

  (define (make-poly variable term-list)
    (cons variable term-list))

  (define (variable p) (car p))
  (define (term-list p) (cdr p))

  (define (zero-termlist? terms)
    (cond ((empty-termlist? terms)
           #t)
          ((zero? (coeff (first-term terms)))
           (zero-termlist? (rest-terms terms)))
          (else
           #f)))

  (define (adjoin-term term term-list)
    (if (ex-zero? (coeff term))
        term-list
        (cons term term-list)))

  (define (the-empty-termlist) '())
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))

  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))

  ;; tag = sparse
  (define (tag p) (attach-tag 'sparse p))

  (define (make-dense-from-sparse sparse-termlist)
    (if (empty-termlist? sparse-termlist) '()
        (make-dense-from-sparse-body (order (first-term sparse-termlist))
                                     sparse-termlist
                                     '())))
  (define (make-dense-from-sparse-body current-order termlist newlist)
    (cond ((< current-order 0) newlist)
          ((empty-termlist? termlist)
           (make-dense-from-sparse-body
            (- current-order 1)
            termlist
            (append newlist (list 0))))
          ((= current-order (order (first-term termlist)))
           (make-dense-from-sparse-body
            (- current-order 1)
            (rest-terms termlist)
            (append newlist (list (coeff (first-term termlist))))))
          (else
           (make-dense-from-sparse-body
            (- current-order 1)
            termlist
            (append newlist (list 0))))))


  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1))
                 (t2 (first-term L2)))
             (cond ((> (order t1) (order t2))
                    (adjoin-term t1
                                 (add-terms (rest-terms L1) L2)))
                   ((< (order t1) (order t2))
                    (adjoin-term t2
                                 (add-terms L1 (rest-terms L2))))
                   (else
                    (adjoin-term
                     (make-term (order t1)
                                (add (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))
                     
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
             
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ((t2 (first-term L)))
          (adjoin-term
           (make-term (+ (order t1) (order t2)) ; order of term
                      (mul (coeff t1) (coeff t2))) ; coeff of term
           (mul-term-by-all-terms t1 (rest-terms L))))))

  (define (negation-termlist termlist)
    (if (empty-termlist? termlist) '()
        (adjoin-term 
         (make-term (order (first-term termlist))
                    ; use negation again that can handle any type of coeff
                    (negation (coeff (first-term termlist))))
         (negation-termlist (rest-terms termlist)))))


  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- ADD-POLY" (list p1 p2))))

  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (mul-terms (term-list p1)
                             (term-list p2)))
        (error "Polys not in same var -- MUL-POLY" (list p1 p2))))


  (put 'make 'sparse
       (lambda (var terms) (tag (make-poly var terms))))

  ;; term-list를 반드시 호출해야
  ;; 변수가 없어지고 각 term을 곧바로 처리할 수 있게 된다.
  (put 'ex-zero? '(sparse) 
       (lambda (terms) (zero-termlist? (term-list terms))))

  (put 'negation '(sparse)
       (lambda (termlist)
         (tag (make-poly (variable termlist)
                         (negation-termlist (term-list termlist))))))

  (put 'make-dense-from-sparse '(sparse) 
       (lambda (x)
         (attach-tag 'dense
                     (make-poly (variable x)
                                (make-dense-from-sparse (term-list x))))))


  ;; install operations
  (put 'add '(sparse sparse)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(sparse sparse)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))
       
  'done)

;; dense polynomial : variable and list of coeff (1 0 0 2 0 4)
;; eg) ('x (1 0 0 2 0 4))
(define (install-dense-polynomial-package)
  ;; from ch2.3.2
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  (define (make-poly variable coeff-list)
    (cons variable coeff-list))
  (define (variable p) (car p))
  (define (coeff-list p) (cdr p))
  (define (the-empty-termlist) '())
  (define (highest-coeff coeff-list)
    (car coeff-list)) ;; first-term -> highest-coeff
  (define (rest-coeffs coeff-list)
    (cdr coeff-list))   ;; rest-terms -> rest-coeffs
  (define (empty-coefflist? coeff-list)
    (null? coeff-list)) ;; empty-termlist? -> empty-coefflist?

  (define (zero-coefflist? coefflist)
    (cond ((empty-coefflist? coefflist)
           #t)
          ((zero? (highest-coeff coefflist)))
           (zero-coefflist? (rest-coeffs coefflist)))
          (else
           #f))

  (define (adjoin-coeff coeff coeff-list)
    (cons coeff coeff-list))

  (define (negation-coefflist coefflist)
    (if (empty-coefflist? coefflist) '()
        (adjoin-coeff (negation (highest-coeff coefflist))
                      (negation-coefflist (rest-coeffs coefflist)))))

  (define (tag p) (attach-tag 'dense p))

  ;; make-sparse-from-dense HERE!
  (define (make-sparse-from-dense coefflist)
    (if (empty-coefflist? coefflist) '()
        (make-sparse-from-dense-body (- (length coefflist) 1) coefflist)))

  (define (make-sparse-from-dense-body curr-order coefflist)
    (cond ((< curr-order 0) '())
          ((ex-zero? (highest-coeff coefflist))
           (make-sparse-from-dense-body (- curr-order 1)
                                        (rest-coeffs coefflist)))
          (else
           (cons (list curr-order (highest-coeff coefflist))
                 (make-sparse-from-dense-body (- curr-order 1)
                                              (rest-coeffs coefflist))))))

  ;; install operations
  (put 'make 'dense
       (lambda (var coeffs) (tag (make-poly var coeffs))))

  (put 'ex-zero? '(dense) 
       (lambda (coeffs) (zero-coefflist? (coeff-list coeffs))))

  (put 'negation '(dense)
       (lambda (coefflist)
         (tag (make-poly (variable coefflist)
                         (negation-coefflist (coeff-list coefflist))))))

  (put 'make-sparse-from-dense '(dense)
       (lambda (x)
         (attach-tag 'sparse
                     (make-poly (variable x)
                                (make-sparse-from-dense (coeff-list x))))))

  'done)



;; install generic procedure used for both of two types of polynomial
(define (install-polynomial-package)

  (define (tag p) (attach-tag 'polynomial p))
  (define (coeff-list p) (cdr p))
  (define (term-list p) (cdr p))

  ;; call procedure in each package
  (define (make-from-termlist v t)
    ((get 'make 'sparse) v t))
  (define (make-from-coefflist v c)
    ((get 'make 'dense) v c))

  (define (make-dense-from-sparse x)
    (apply-generic 'make-dense-from-sparse x))
  (define (make-sparse-from-dense x)
    (apply-generic 'make-sparse-from-dense x))

  (define (get-type p) (car p))

  (define (add-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (add p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (add p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (add (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (add (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC ADD for " p1 p2)))))

  (define (mul-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (mul p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (mul p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (mul (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (mul (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC ADD for " p1 p2)))))


  (put 'make-polynomial-from-termlist 'polynomial
       (lambda (v t) (tag (make-from-termlist v t))))
  (put 'make-polynomial-from-coefflist 'polynomial
       (lambda (v c) (tag (make-from-coefflist v c))))

  ;; apply-generic으로 호출된 make-dense-polynomial-from-sparse함수는
  ;; (polynomial) 태그는 없어졌지만 (sparse)태그는 없어지지 않았다.
  ;; 따라서 다시한번 apply-generic 으로 make-dense-from-sparse를
  ;; 호출하면 최종 패키지에서는 태그가 없고
  ;; 변수와 리스트만 있는 데이터가 전달된다.
  (put 'make-dense-polynomial-from-sparse '(polynomial)
       (lambda (x) (tag (make-dense-from-sparse x))))
  (put 'make-sparse-polynomial-from-dense '(polynomial)
       (lambda (x) (tag (make-sparse-from-dense x))))


  (put 'add '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))

  ;; no need to make another procedure for sub, but use add & negation
  (put 'sub '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 (negation p2)))))
  (put 'negation '(polynomial)
       (lambda (p) (tag (negation p))))
  

  'done)


(define (make-polynomial-from-termlist var termlist)
  ((get 'make-polynomial-from-termlist 'polynomial) var termlist))
(define (make-polynomial-from-coefflist var coefflist)
  ((get 'make-polynomial-from-coefflist 'polynomial) var coefflist))

(define (make-dense-polynomial-from-sparse sparselist)
  (apply-generic 'make-dense-polynomial-from-sparse sparselist))
(define (make-sparse-polynomial-from-dense denselist)
  (apply-generic 'make-sparse-polynomial-from-dense denselist))

                 
;;--------- test ----------------

;; MUST INSTALL!!
(install-scheme-number-package)
(install-rational-package)
(install-polar-package)
(install-rectangular-package)
(install-complex-package)
(install-sparse-polynomial-package)
(install-dense-polynomial-package)
(install-polynomial-package)

(define test-sparselist
  (make-polynomial-from-termlist 'x '((5 1) (2 2) (0 3))))
(define test-denselist
  (make-polynomial-from-coefflist 'x '(2 0 0 4 0 6)))

(make-dense-polynomial-from-sparse test-sparselist)
(make-sparse-polynomial-from-dense test-denselist)

(add test-sparselist test-sparselist)
(add test-sparselist test-denselist)
(add test-denselist test-sparselist)
(add test-denselist test-denselist)

(mul test-sparselist test-sparselist)
(mul test-sparselist test-denselist)
(mul test-denselist test-sparselist)
(mul test-denselist test-denselist)

(negation test-sparselist)
(negation test-denselist)

(sub test-sparselist test-sparselist)
(sub test-sparselist test-denselist)
(sub test-denselist test-sparselist)
(sub test-denselist test-denselist)

}}}


== 2.91.scm ==


{{{
;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;; (put <op> <type> <item>)
;; (get <op> <type>
;;------------------------------------------------


;;----- GENERIC PROCEDURES -----------------

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (ex-equ? x y) (apply-generic 'ex-equ? x y))
(define (ex-zero? x) (apply-generic 'ex-zero? x))
(define (exp x y) (apply-generic 'exp x y))
(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))
(define (add-3 a b c) (apply-generic 'add-3 a b c))

(define (negation x) (apply-generic 'negation x))

(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
        (error "Bad tagged datum -- TYPE-TAG" datum)))

(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (error "Bad tagged datum -- CONTENTS" datum)))

(define (raise x) (apply-generic 'raise x))

(define (project z)
  (apply-generic 'project z))

(define (install-get-higher-system)
  (put 'scheme-number 'rational 'rational)
  (put 'scheme-number 'complex 'complex)
  (put 'rational 'scheme-number 'rational)
  (put 'rational 'complex 'complex)
  (put 'complex 'scheme-number 'complex)
  (put 'complex 'rational 'complex))
(install-get-higher-system)       

(define (former-is-higher-system? type1 type2)
  (cond ((eq? type1 type2) #f)
        ((and (eq? type1 'rational) (eq? type2 'scheme-number)) #t)
        ((eq? type1 'complex) #t)
        (else #f)))

(define (drop x)
  (cond ((eq? (type-tag x) 'scheme-number) x)
        ((ex-equ? (raise (project x)) x) (drop (project x)))
        (else x)))


;; fail to make new apply-generic which is applied with drop procedure
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args))) ;; extract tags of each arguments
    (let ((proc (get op type-tags)))
      (if proc
          ;; I tried (drop (apply proc (map contents args))),
          ;; but it generated Stack-Overflow.
          ;; I failed to make new apply-generic procedure.
          (apply proc (map contents args)) ;; extract data
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (if (former-is-higher-system? type1 type2)
                    (apply-generic op (car args) (raise (cadr args)))
                    (apply-generic op (raise (car args)) (cadr args))))
              (error
               "No method for these types -- APPLY-GENERIC"
               (list op type-tags)))))))


;;------ Number Systems ----------------------

;; normal number
;; eg) (add (make-scheme-number 3) (make-scheme-number 4))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))

  (define (scheme-number->complex x)
    (make-complex-from-real-imag (cdr x) 0))
  (define (scheme-number->rational x)
    (make-rational x 1))

  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (+ x y)))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (- x y)))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (* x y)))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (/ x y)))

  (put 'negation '(scheme-number)
       (lambda (x) (- x)))


  ;;
  ;; remove tag because it make number look dirty
  ;;

  ;; (put 'add '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (+ x y))))
  ;; (put 'sub '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (- x y))))
  ;; (put 'mul '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (* x y))))
  ;; (put 'div '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (/ x y))))
  ;; (put 'negation '(scheme-number)
  ;;     (lambda (x) (tag (- x))))

  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  (put 'ex-equ? '(scheme-number scheme-number)
       (lambda (x y) (= x y)))
  (put 'ex-zero? '(scheme-number)
       (lambda (x) (= x 0)))
  (put 'add-3 '(scheme-number scheme-number scheme-number)
       (lambda (a b c) (tag (+ a b c))))
  (put 'exp '(scheme-number scheme-number)
       (lambda (x y) (tag (expt x y))))

  (put 'raise '(scheme-number) scheme-number->rational)

  'done)


(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

;; rational number
;; eg) (add (make-rational 3 4) (make-rational 3 4))
(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  (define (ex-equ? x y)
    (and (= (numer x) (numer y))
         (= (denom x) (denom y))))
  (define (ex-zero? x)
    (= (numer x) 0))

  (define (rational->complex x)
    (make-complex-from-real-imag (round (/ (numer x) (denom x))) 0))

  (define (tag x) (attach-tag 'rational x))

  (define (project-rational x) ; rational -> scheme-number
    (make-scheme-number (round (/ (numer x) (denom x)))))


  ;; interface to rest of the system
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'ex-equ? '(rational rational) ex-equ?)
  (put 'ex-zero? '(rational) ex-zero?)
  (put 'raise '(rational) rational->complex)
  (put 'project '(rational) project-rational)

  (put 'negation '(rational)
       (lambda (x) (tag (make-rat ( - (numer x))
                                  (denom x)))))

  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))



;; real + imaginary number
;; 3 + 4i = (rectangular 3 . 4)
(define (square a) (* a a))
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))

  'done)

;; mag + angle number
;; 3 + 45' = (polar 3 . 45)
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

;; complex number
(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures

  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
                         (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))
  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))

  (define (add-complex-3 z1 z2 z3)
    (make-from-real-imag (+ (real-part z1) (real-part z2) (real-part z3))
                         (+ (imag-part z1) (imag-part z2) (imag-part z3))))

  (define (project-complex z)
    (make-rational (round (real-part z)) 1))

  (put 'add-3 '(complex complex complex)
       (lambda (z1 z2 z3) (tag (add-complex-3 z1 z2 z3))))

  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'ex-equ? '(complex complex)
       (lambda (z1 z2) (and (equal? (real-part z1) (real-part z2))
                            (equal? (imag-part z1) (imag-part z2)))))
  (put 'ex-zero? '(complex)
       (lambda (z1) (and (equal? (real-part z1) 0)
                         (equal? (imag-part z1) 0))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

  (put 'project '(complex) project-complex)

  (put 'negation '(complex)
       (lambda (z) (display "귀찮아서 안만듬")))

  'done)

;; complex 숫자들은 2개의 태그를 가진다.
;; make-comple-from-real-imag에서 'complex라는 태그를 추가해주고 
;; make-from-real-imag에서 'rectangular라는 태그를 추가해서
;; (complex rectangular 3 . 4) 와 같은 형태가 된다.
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)



;;-------------- ex2.90 ----------------------------------------
;;
;; 1. make install-sparse-polynomial-package
;; 2. make install-dense-polynomial-package
;; 3. make install-polynomial-package
;; 4. make-polynomial-from-termlist, make-polynomial-from-coefflist
;; 5. make-dense-polynomial-from-sparse, make-sparse-polynomial-from-dense
;; 6. generic add,mul,sub


;; sparse polynomial : variable and list of (order coeff)
;; eg) ('x ((100 2) (2 4) (0 5)))
(define (install-sparse-polynomial-package)
  ;; from ch2.3.2
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))

  (define (make-poly variable term-list)
    (cons variable term-list))

  (define (variable p) (car p))
  (define (term-list p) (cdr p))

  (define (zero-termlist? terms)
    (cond ((empty-termlist? terms)
           #t)
          ((zero? (coeff (first-term terms)))
           (zero-termlist? (rest-terms terms)))
          (else
           #f)))

  (define (adjoin-term term term-list)
    (if (ex-zero? (coeff term))
        term-list
        (cons term term-list)))

  (define (the-empty-termlist) '())
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))

  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))

  ;; tag = sparse
  (define (tag p) (attach-tag 'sparse p))

  (define (make-dense-from-sparse sparse-termlist)
    (if (empty-termlist? sparse-termlist) '()
        (make-dense-from-sparse-body (order (first-term sparse-termlist))
                                     sparse-termlist
                                     '())))
  (define (make-dense-from-sparse-body current-order termlist newlist)
    (cond ((< current-order 0) newlist)
          ((empty-termlist? termlist)
           (make-dense-from-sparse-body
            (- current-order 1)
            termlist
            (append newlist (list 0))))
          ((= current-order (order (first-term termlist)))
           (make-dense-from-sparse-body
            (- current-order 1)
            (rest-terms termlist)
            (append newlist (list (coeff (first-term termlist))))))
          (else
           (make-dense-from-sparse-body
            (- current-order 1)
            termlist
            (append newlist (list 0))))))


  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1))
                 (t2 (first-term L2)))
             (cond ((> (order t1) (order t2))
                    (adjoin-term t1
                                 (add-terms (rest-terms L1) L2)))
                   ((< (order t1) (order t2))
                    (adjoin-term t2
                                 (add-terms L1 (rest-terms L2))))
                   (else
                    (adjoin-term
                     (make-term (order t1)
                                (add (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))
                     
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
             
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ((t2 (first-term L)))
          (adjoin-term
           (make-term (+ (order t1) (order t2)) ; order of term
                      (mul (coeff t1) (coeff t2))) ; coeff of term
           (mul-term-by-all-terms t1 (rest-terms L))))))

  (define (negation-termlist termlist)
    (if (empty-termlist? termlist) '()
        (adjoin-term 
         (make-term (order (first-term termlist))
                    ; use negation again that can handle any type of coeff
                    (negation (coeff (first-term termlist))))
         (negation-termlist (rest-terms termlist)))))


  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- ADD-POLY" (list p1 p2))))

  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (mul-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- MUL-POLY" (list p1 p2))))


  ;;-------- ex2.91 ------------
  (define (div-terms L1 L2)
    (if (empty-termlist? L1)
        (list (the-empty-termlist) (the-empty-termlist))
        (let ((t1 (first-term L1))
              (t2 (first-term L2)))
          (if (> (order t2) (order t1))
              (list (the-empty-termlist) L1)  ;; L1 is remainder
              (let ((new-c (div (coeff t1) (coeff t2)))
                    (new-o (- (order t1) (order t2))))
                (let ((rest-of-result
                       ;; get next dividee
                       (div-terms (add-terms L1 
                                             (negation-termlist (mul-term-by-all-terms (list new-o new-c) L2)))
                                  L2)
                       ))
                  ;; get result
                  (list (cons (list new-o new-c) (car rest-of-result)) (cadr rest-of-result))
                  ))))))

  (define (div-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (div-terms (term-list p1) (term-list p2)))
        (error "Polys not in same var -- DIV-POLY" (list p1 p2))))

  (put 'make 'sparse
       (lambda (var terms) (tag (make-poly var terms))))

  ;; term-list를 반드시 호출해야
  ;; 변수가 없어지고 각 term을 곧바로 처리할 수 있게 된다.
  (put 'ex-zero? '(sparse) 
       (lambda (terms) (zero-termlist? (term-list terms))))

  (put 'negation '(sparse)
       (lambda (termlist)
         (tag (make-poly (variable termlist)
                         (negation-termlist (term-list termlist))))))

  (put 'make-dense-from-sparse '(sparse) 
       (lambda (x)
         (attach-tag 'dense
                     (make-poly (variable x)
                                (make-dense-from-sparse (term-list x))))))


  ;; install operations
  (put 'add '(sparse sparse)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(sparse sparse)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))

  ;; ex2.91
  (put 'div '(sparse sparse)
       (lambda (p1 p2) (tag (div-poly p1 p2))))

  'done)

;; dense polynomial : variable and list of coeff (1 0 0 2 0 4)
;; eg) ('x (1 0 0 2 0 4))
(define (install-dense-polynomial-package)
  ;; from ch2.3.2
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  (define (make-poly variable coeff-list)
    (cons variable coeff-list))
  (define (variable p) (car p))
  (define (coeff-list p) (cdr p))
  (define (the-empty-termlist) '())
  (define (highest-coeff coeff-list)
    (car coeff-list)) ;; first-term -> highest-coeff
  (define (rest-coeffs coeff-list)
    (cdr coeff-list))   ;; rest-terms -> rest-coeffs
  (define (empty-coefflist? coeff-list)
    (null? coeff-list)) ;; empty-termlist? -> empty-coefflist?

  (define (zero-coefflist? coefflist)
    (cond ((empty-coefflist? coefflist)
           #t)
          ((zero? (highest-coeff coefflist)))
           (zero-coefflist? (rest-coeffs coefflist)))
          (else
           #f))

  (define (adjoin-coeff coeff coeff-list)
    (cons coeff coeff-list))

  (define (negation-coefflist coefflist)
    (if (empty-coefflist? coefflist) '()
        (adjoin-coeff (negation (highest-coeff coefflist))
                      (negation-coefflist (rest-coeffs coefflist)))))

  (define (tag p) (attach-tag 'dense p))

  ;; make-sparse-from-dense HERE!
  (define (make-sparse-from-dense coefflist)
    (if (empty-coefflist? coefflist) '()
        (make-sparse-from-dense-body (- (length coefflist) 1) coefflist)))

  (define (make-sparse-from-dense-body curr-order coefflist)
    (cond ((< curr-order 0) '())
          ((ex-zero? (highest-coeff coefflist))
           (make-sparse-from-dense-body (- curr-order 1)
                                        (rest-coeffs coefflist)))
          (else
           (cons (list curr-order (highest-coeff coefflist))
                 (make-sparse-from-dense-body (- curr-order 1)
                                              (rest-coeffs coefflist))))))

  ;; install operations
  (put 'make 'dense
       (lambda (var coeffs) (tag (make-poly var coeffs))))

  (put 'ex-zero? '(dense) 
       (lambda (coeffs) (zero-coefflist? (coeff-list coeffs))))

  (put 'negation '(dense)
       (lambda (coefflist)
         (tag (make-poly (variable coefflist)
                         (negation-coefflist (coeff-list coefflist))))))

  (put 'make-sparse-from-dense '(dense)
       (lambda (x)
         (attach-tag 'sparse
                     (make-poly (variable x)
                                (make-sparse-from-dense (coeff-list x))))))

  'done)



;; install generic procedure used for both of two types of polynomial
(define (install-polynomial-package)

  (define (tag p) (attach-tag 'polynomial p))
  (define (coeff-list p) (cdr p))
  (define (term-list p) (cdr p))

  ;; call procedure in each package
  (define (make-from-termlist v t)
    ((get 'make 'sparse) v t))
  (define (make-from-coefflist v c)
    ((get 'make 'dense) v c))

  (define (make-dense-from-sparse x)
    (apply-generic 'make-dense-from-sparse x))
  (define (make-sparse-from-dense x)
    (apply-generic 'make-sparse-from-dense x))

  (define (get-type p) (car p))

  (define (add-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (add p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (add p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (add (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (add (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC ADD for " p1 p2)))))

  (define (mul-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (mul p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (mul p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (mul (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (mul (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC MUL for " p1 p2)))))

  ;; ex2.91
  (define (div-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (div p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (div p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (div (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (div (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC DIV for " p1 p2)))))

  (put 'make-polynomial-from-termlist 'polynomial
       (lambda (v t) (tag (make-from-termlist v t))))
  (put 'make-polynomial-from-coefflist 'polynomial
       (lambda (v c) (tag (make-from-coefflist v c))))

  ;; apply-generic으로 호출된 make-dense-polynomial-from-sparse함수는
  ;; (polynomial) 태그는 없어졌지만 (sparse)태그는 없어지지 않았다.
  ;; 따라서 다시한번 apply-generic 으로 make-dense-from-sparse를
  ;; 호출하면 최종 패키지에서는 태그가 없고
  ;; 변수와 리스트만 있는 데이터가 전달된다.
  (put 'make-dense-polynomial-from-sparse '(polynomial)
       (lambda (x) (tag (make-dense-from-sparse x))))
  (put 'make-sparse-polynomial-from-dense '(polynomial)
       (lambda (x) (tag (make-sparse-from-dense x))))

  (put 'add '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))

  ;; no need to make another procedure for sub, but use add & negation
  (put 'sub '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 (negation p2)))))
  (put 'negation '(polynomial)
       (lambda (p) (tag (negation p))))

  ;; ex2.91
  (put 'div '(polynomial polynomial)
       (lambda (p1 p2) (tag (div-poly p1 p2))))

  'done)


(define (make-polynomial-from-termlist var termlist)
  ((get 'make-polynomial-from-termlist 'polynomial) var termlist))
(define (make-polynomial-from-coefflist var coefflist)
  ((get 'make-polynomial-from-coefflist 'polynomial) var coefflist))

(define (make-dense-polynomial-from-sparse sparselist)
  (apply-generic 'make-dense-polynomial-from-sparse sparselist))
(define (make-sparse-polynomial-from-dense denselist)
  (apply-generic 'make-sparse-polynomial-from-dense denselist))

                 
;;--------- test ----------------

;; MUST INSTALL!!
(install-scheme-number-package)
(install-rational-package)
(install-polar-package)
(install-rectangular-package)
(install-complex-package)
(install-sparse-polynomial-package)
(install-dense-polynomial-package)
(install-polynomial-package)

(define test-sparselist
  (make-polynomial-from-termlist 'x '((5 1) (2 2) (0 3))))
(define test-denselist
  (make-polynomial-from-coefflist 'x '(2 0 0 4 0 6)))

;; (polynomial sparse x ((3 1) (1 1)) ((1 1) (0 -1)))
(div (make-polynomial-from-termlist 'x '((5 1) (0 -1)))
     (make-polynomial-from-termlist 'x '((2 1) (0 -1))))

(div test-sparselist test-sparselist)
(div test-denselist test-denselist)
}}}


== 2.93.scm ==


{{{
;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;; (put <op> <type> <item>)
;; (get <op> <type>
;;------------------------------------------------


;;----- GENERIC PROCEDURES -----------------

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (ex-equ? x y) (apply-generic 'ex-equ? x y))
(define (ex-zero? x) (apply-generic 'ex-zero? x))
(define (exp x y) (apply-generic 'exp x y))
(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))
(define (add-3 a b c) (apply-generic 'add-3 a b c))

(define (negation x) (apply-generic 'negation x))

(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
        (error "Bad tagged datum -- TYPE-TAG" datum)))

(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (error "Bad tagged datum -- CONTENTS" datum)))

(define (raise x) (apply-generic 'raise x))

(define (project z)
  (apply-generic 'project z))

(define (install-get-higher-system)
  (put 'scheme-number 'rational 'rational)
  (put 'scheme-number 'complex 'complex)
  (put 'rational 'scheme-number 'rational)
  (put 'rational 'complex 'complex)
  (put 'complex 'scheme-number 'complex)
  (put 'complex 'rational 'complex))
(install-get-higher-system)       

(define (former-is-higher-system? type1 type2)
  (cond ((eq? type1 type2) #f)
        ((and (eq? type1 'rational) (eq? type2 'scheme-number)) #t)
        ((eq? type1 'complex) #t)
        (else #f)))

(define (drop x)
  (cond ((eq? (type-tag x) 'scheme-number) x)
        ((ex-equ? (raise (project x)) x) (drop (project x)))
        (else x)))


;; fail to make new apply-generic which is applied with drop procedure
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args))) ;; extract tags of each arguments
    (let ((proc (get op type-tags)))
      (if proc
          ;; I tried (drop (apply proc (map contents args))),
          ;; but it generated Stack-Overflow.
          ;; I failed to make new apply-generic procedure.
          (apply proc (map contents args)) ;; extract data
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (if (former-is-higher-system? type1 type2)
                    (apply-generic op (car args) (raise (cadr args)))
                    (apply-generic op (raise (car args)) (cadr args))))
              (error
               "No method for these types -- APPLY-GENERIC"
               (list op type-tags)))))))


;;------ Number Systems ----------------------

;; normal number
;; eg) (add (make-scheme-number 3) (make-scheme-number 4))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))

  (define (scheme-number->complex x)
    (make-complex-from-real-imag (cdr x) 0))
  (define (scheme-number->rational x)
    (make-rational x 1))

  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (+ x y)))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (- x y)))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (* x y)))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (/ x y)))

  (put 'negation '(scheme-number)
       (lambda (x) (- x)))


  ;;
  ;; remove tag because it make number look dirty
  ;;

  ;; (put 'add '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (+ x y))))
  ;; (put 'sub '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (- x y))))
  ;; (put 'mul '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (* x y))))
  ;; (put 'div '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (/ x y))))
  ;; (put 'negation '(scheme-number)
  ;;     (lambda (x) (tag (- x))))

  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  (put 'ex-equ? '(scheme-number scheme-number)
       (lambda (x y) (= x y)))
  (put 'ex-zero? '(scheme-number)
       (lambda (x) (= x 0)))
  (put 'add-3 '(scheme-number scheme-number scheme-number)
       (lambda (a b c) (tag (+ a b c))))
  (put 'exp '(scheme-number scheme-number)
       (lambda (x y) (tag (expt x y))))

  (put 'raise '(scheme-number) scheme-number->rational)

  'done)


(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))



;; real + imaginary number
;; 3 + 4i = (rectangular 3 . 4)
(define (square a) (* a a))
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))

  'done)

;; mag + angle number
;; 3 + 45' = (polar 3 . 45)
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

;; complex number
(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures

  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
                         (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))
  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))

  (define (add-complex-3 z1 z2 z3)
    (make-from-real-imag (+ (real-part z1) (real-part z2) (real-part z3))
                         (+ (imag-part z1) (imag-part z2) (imag-part z3))))

  (define (project-complex z)
    (make-rational (round (real-part z)) 1))

  (put 'add-3 '(complex complex complex)
       (lambda (z1 z2 z3) (tag (add-complex-3 z1 z2 z3))))

  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'ex-equ? '(complex complex)
       (lambda (z1 z2) (and (equal? (real-part z1) (real-part z2))
                            (equal? (imag-part z1) (imag-part z2)))))
  (put 'ex-zero? '(complex)
       (lambda (z1) (and (equal? (real-part z1) 0)
                         (equal? (imag-part z1) 0))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

  (put 'project '(complex) project-complex)

  (put 'negation '(complex)
       (lambda (z) (display "귀찮아서 안만듬")))

  'done)

;; complex 숫자들은 2개의 태그를 가진다.
;; make-comple-from-real-imag에서 'complex라는 태그를 추가해주고 
;; make-from-real-imag에서 'rectangular라는 태그를 추가해서
;; (complex rectangular 3 . 4) 와 같은 형태가 된다.
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)



;;-------------- ex2.90 ----------------------------------------
;;
;; 1. make install-sparse-polynomial-package
;; 2. make install-dense-polynomial-package
;; 3. make install-polynomial-package
;; 4. make-polynomial-from-termlist, make-polynomial-from-coefflist
;; 5. make-dense-polynomial-from-sparse, make-sparse-polynomial-from-dense
;; 6. generic add,mul,sub


;; sparse polynomial : variable and list of (order coeff)
;; eg) ('x ((100 2) (2 4) (0 5)))
(define (install-sparse-polynomial-package)
  ;; from ch2.3.2
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))

  (define (make-poly variable term-list)
    (cons variable term-list))

  (define (variable p) (car p))
  (define (term-list p) (cdr p))

  (define (zero-termlist? terms)
    (cond ((empty-termlist? terms)
           #t)
          ((zero? (coeff (first-term terms)))
           (zero-termlist? (rest-terms terms)))
          (else
           #f)))

  (define (adjoin-term term term-list)
    (if (ex-zero? (coeff term))
        term-list
        (cons term term-list)))

  (define (the-empty-termlist) '())
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))

  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))

  ;; tag = sparse
  (define (tag p) (attach-tag 'sparse p))

  (define (make-dense-from-sparse sparse-termlist)
    (if (empty-termlist? sparse-termlist) '()
        (make-dense-from-sparse-body (order (first-term sparse-termlist))
                                     sparse-termlist
                                     '())))
  (define (make-dense-from-sparse-body current-order termlist newlist)
    (cond ((< current-order 0) newlist)
          ((empty-termlist? termlist)
           (make-dense-from-sparse-body
            (- current-order 1)
            termlist
            (append newlist (list 0))))
          ((= current-order (order (first-term termlist)))
           (make-dense-from-sparse-body
            (- current-order 1)
            (rest-terms termlist)
            (append newlist (list (coeff (first-term termlist))))))
          (else
           (make-dense-from-sparse-body
            (- current-order 1)
            termlist
            (append newlist (list 0))))))


  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1))
                 (t2 (first-term L2)))
             (cond ((> (order t1) (order t2))
                    (adjoin-term t1
                                 (add-terms (rest-terms L1) L2)))
                   ((< (order t1) (order t2))
                    (adjoin-term t2
                                 (add-terms L1 (rest-terms L2))))
                   (else
                    (adjoin-term
                     (make-term (order t1)
                                (add (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))
                     
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
             
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ((t2 (first-term L)))
          (adjoin-term
           (make-term (+ (order t1) (order t2)) ; order of term
                      (mul (coeff t1) (coeff t2))) ; coeff of term
           (mul-term-by-all-terms t1 (rest-terms L))))))

  (define (negation-termlist termlist)
    (if (empty-termlist? termlist) '()
        (adjoin-term 
         (make-term (order (first-term termlist))
                    ; use negation again that can handle any type of coeff
                    (negation (coeff (first-term termlist))))
         (negation-termlist (rest-terms termlist)))))


  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- ADD-POLY" (list p1 p2))))

  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (mul-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- MUL-POLY" (list p1 p2))))


  ;;-------- ex2.91 ------------
  (define (div-terms L1 L2)
    (if (empty-termlist? L1)
        (list (the-empty-termlist) (the-empty-termlist))
        (let ((t1 (first-term L1))
              (t2 (first-term L2)))
          (if (> (order t2) (order t1))
              (list (the-empty-termlist) L1)  ;; L1 is remainder
              (let ((new-c (div (coeff t1) (coeff t2)))
                    (new-o (- (order t1) (order t2))))
                (let ((rest-of-result
                       ;; get next dividee
                       (div-terms (add-terms L1 
                                             (negation-termlist (mul-term-by-all-terms (list new-o new-c) L2)))
                                  L2)
                       ))
                  ;; get result
                  (list (cons (list new-o new-c) (car rest-of-result)) (cadr rest-of-result))
                  ))))))

  (define (div-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (div-terms (term-list p1) (term-list p2)))
        (error "Polys not in same var -- DIV-POLY" (list p1 p2))))

  (put 'make 'sparse
       (lambda (var terms) (tag (make-poly var terms))))

  ;; term-list를 반드시 호출해야
  ;; 변수가 없어지고 각 term을 곧바로 처리할 수 있게 된다.
  (put 'ex-zero? '(sparse) 
       (lambda (terms) (zero-termlist? (term-list terms))))

  (put 'negation '(sparse)
       (lambda (termlist)
         (tag (make-poly (variable termlist)
                         (negation-termlist (term-list termlist))))))

  (put 'make-dense-from-sparse '(sparse) 
       (lambda (x)
         (attach-tag 'dense
                     (make-poly (variable x)
                                (make-dense-from-sparse (term-list x))))))


  ;; install operations
  (put 'add '(sparse sparse)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(sparse sparse)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))

  ;; ex2.91
  (put 'div '(sparse sparse)
       (lambda (p1 p2) (tag (div-poly p1 p2))))

  'done)

;; dense polynomial : variable and list of coeff (1 0 0 2 0 4)
;; eg) ('x (1 0 0 2 0 4))
(define (install-dense-polynomial-package)
  ;; from ch2.3.2
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  (define (make-poly variable coeff-list)
    (cons variable coeff-list))
  (define (variable p) (car p))
  (define (coeff-list p) (cdr p))
  (define (the-empty-termlist) '())
  (define (highest-coeff coeff-list)
    (car coeff-list)) ;; first-term -> highest-coeff
  (define (rest-coeffs coeff-list)
    (cdr coeff-list))   ;; rest-terms -> rest-coeffs
  (define (empty-coefflist? coeff-list)
    (null? coeff-list)) ;; empty-termlist? -> empty-coefflist?

  (define (zero-coefflist? coefflist)
    (cond ((empty-coefflist? coefflist)
           #t)
          ((zero? (highest-coeff coefflist)))
           (zero-coefflist? (rest-coeffs coefflist)))
          (else
           #f))

  (define (adjoin-coeff coeff coeff-list)
    (cons coeff coeff-list))

  (define (negation-coefflist coefflist)
    (if (empty-coefflist? coefflist) '()
        (adjoin-coeff (negation (highest-coeff coefflist))
                      (negation-coefflist (rest-coeffs coefflist)))))

  (define (tag p) (attach-tag 'dense p))

  ;; make-sparse-from-dense HERE!
  (define (make-sparse-from-dense coefflist)
    (if (empty-coefflist? coefflist) '()
        (make-sparse-from-dense-body (- (length coefflist) 1) coefflist)))

  (define (make-sparse-from-dense-body curr-order coefflist)
    (cond ((< curr-order 0) '())
          ((ex-zero? (highest-coeff coefflist))
           (make-sparse-from-dense-body (- curr-order 1)
                                        (rest-coeffs coefflist)))
          (else
           (cons (list curr-order (highest-coeff coefflist))
                 (make-sparse-from-dense-body (- curr-order 1)
                                              (rest-coeffs coefflist))))))

  ;; install operations
  (put 'make 'dense
       (lambda (var coeffs) (tag (make-poly var coeffs))))

  (put 'ex-zero? '(dense) 
       (lambda (coeffs) (zero-coefflist? (coeff-list coeffs))))

  (put 'negation '(dense)
       (lambda (coefflist)
         (tag (make-poly (variable coefflist)
                         (negation-coefflist (coeff-list coefflist))))))

  (put 'make-sparse-from-dense '(dense)
       (lambda (x)
         (attach-tag 'sparse
                     (make-poly (variable x)
                                (make-sparse-from-dense (coeff-list x))))))

  'done)



;; install generic procedure used for both of two types of polynomial
(define (install-polynomial-package)

  (define (tag p) (attach-tag 'polynomial p))
  (define (coeff-list p) (cdr p))
  (define (term-list p) (cdr p))

  ;; call procedure in each package
  (define (make-from-termlist v t)
    ((get 'make 'sparse) v t))
  (define (make-from-coefflist v c)
    ((get 'make 'dense) v c))

  (define (make-dense-from-sparse x)
    (apply-generic 'make-dense-from-sparse x))
  (define (make-sparse-from-dense x)
    (apply-generic 'make-sparse-from-dense x))

  (define (get-type p) (car p))

  (define (add-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (add p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (add p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (add (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (add (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC ADD for " p1 p2)))))

  (define (mul-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (mul p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (mul p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (mul (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (mul (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC MUL for " p1 p2)))))

  ;; ex2.91
  (define (div-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (div p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (div p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (div (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (div (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC DIV for " p1 p2)))))

  (put 'make-polynomial-from-termlist 'polynomial
       (lambda (v t) (tag (make-from-termlist v t))))
  (put 'make-polynomial-from-coefflist 'polynomial
       (lambda (v c) (tag (make-from-coefflist v c))))

  ;; apply-generic으로 호출된 make-dense-polynomial-from-sparse함수는
  ;; (polynomial) 태그는 없어졌지만 (sparse)태그는 없어지지 않았다.
  ;; 따라서 다시한번 apply-generic 으로 make-dense-from-sparse를
  ;; 호출하면 최종 패키지에서는 태그가 없고
  ;; 변수와 리스트만 있는 데이터가 전달된다.
  (put 'make-dense-polynomial-from-sparse '(polynomial)
       (lambda (x) (tag (make-dense-from-sparse x))))
  (put 'make-sparse-polynomial-from-dense '(polynomial)
       (lambda (x) (tag (make-sparse-from-dense x))))

  (put 'add '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))

  ;; no need to make another procedure for sub, but use add & negation
  (put 'sub '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 (negation p2)))))
  (put 'negation '(polynomial)
       (lambda (p) (tag (negation p))))

  ;; ex2.91
  (put 'div '(polynomial polynomial)
       (lambda (p1 p2) (tag (div-poly p1 p2))))

  'done)


(define (make-polynomial-from-termlist var termlist)
  ((get 'make-polynomial-from-termlist 'polynomial) var termlist))
(define (make-polynomial-from-coefflist var coefflist)
  ((get 'make-polynomial-from-coefflist 'polynomial) var coefflist))
(define (make-polynomial var termlist)
  ((get 'make-polynomial-from-termlist 'polynomial) var termlist))

(define (make-dense-polynomial-from-sparse sparselist)
  (apply-generic 'make-dense-polynomial-from-sparse sparselist))
(define (make-sparse-polynomial-from-dense denselist)
  (apply-generic 'make-sparse-polynomial-from-dense denselist))


;; rational number
;; eg) (add (make-rational 3 4) (make-rational 3 4))
(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))

  ;; ex2.93
  (define (make-rat n d)
      (cons n d))

  ;; ex2.93
  (define (add-rat x y)
    (make-rat (add (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
              (mul (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (sub (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
              (mul (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (mul (numer x) (numer y))
              (mul (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (mul (numer x) (denom y))
              (mul (denom x) (numer y))))


  ;; should be fixed to handle polynomial
  (define (ex-equ? x y)
    (and (= (numer x) (numer y))
         (= (denom x) (denom y))))
  (define (ex-zero? x)
    (= (numer x) 0))

  (define (rational->complex x)
    (make-complex-from-real-imag (round (/ (numer x) (denom x))) 0))

  (define (tag x) (attach-tag 'rational x))

  (define (project-rational x) ; rational -> scheme-number
    (make-scheme-number (round (/ (numer x) (denom x)))))


  ;; interface to rest of the system
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'ex-equ? '(rational rational) ex-equ?)
  (put 'ex-zero? '(rational) ex-zero?)
  (put 'raise '(rational) rational->complex)
  (put 'project '(rational) project-rational)

  (put 'negation '(rational)
       (lambda (x) (tag (make-rat ( - (numer x))
                                  (denom x)))))

  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))

                 
;;--------- test ----------------

;; MUST INSTALL!!
(install-scheme-number-package)

(install-polar-package)
(install-rectangular-package)
(install-complex-package)
(install-sparse-polynomial-package)
(install-dense-polynomial-package)
(install-polynomial-package)


(install-rational-package)

(define p1 (make-polynomial 'x '((2 1) (0 1))))
(define p2 (make-polynomial 'x '((3 1)(0 1))))
(define rf (make-rational p2 p1))

(add rf rf)
(sub rf rf)
(mul rf rf)
(div rf rf)

}}}


== 2.94.scm ==


{{{
;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;; (put <op> <type> <item>)
;; (get <op> <type>
;;------------------------------------------------


;;----- GENERIC PROCEDURES -----------------

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (ex-equ? x y) (apply-generic 'ex-equ? x y))
(define (ex-zero? x) (apply-generic 'ex-zero? x))
(define (exp x y) (apply-generic 'exp x y))
(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))
(define (add-3 a b c) (apply-generic 'add-3 a b c))

(define (negation x) (apply-generic 'negation x))

(define (greatest-common-divisor x y) (apply-generic 'greatest-common-divisor x y))



(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
        (error "Bad tagged datum -- TYPE-TAG" datum)))

(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (error "Bad tagged datum -- CONTENTS" datum)))

(define (raise x) (apply-generic 'raise x))

(define (project z)
  (apply-generic 'project z))

(define (install-get-higher-system)
  (put 'scheme-number 'rational 'rational)
  (put 'scheme-number 'complex 'complex)
  (put 'rational 'scheme-number 'rational)
  (put 'rational 'complex 'complex)
  (put 'complex 'scheme-number 'complex)
  (put 'complex 'rational 'complex))
(install-get-higher-system)       

(define (former-is-higher-system? type1 type2)
  (cond ((eq? type1 type2) #f)
        ((and (eq? type1 'rational) (eq? type2 'scheme-number)) #t)
        ((eq? type1 'complex) #t)
        (else #f)))

(define (drop x)
  (cond ((eq? (type-tag x) 'scheme-number) x)
        ((ex-equ? (raise (project x)) x) (drop (project x)))
        (else x)))


;; fail to make new apply-generic which is applied with drop procedure
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args))) ;; extract tags of each arguments
    (let ((proc (get op type-tags)))
      (if proc
          ;; I tried (drop (apply proc (map contents args))),
          ;; but it generated Stack-Overflow.
          ;; I failed to make new apply-generic procedure.
          (apply proc (map contents args)) ;; extract data
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (if (former-is-higher-system? type1 type2)
                    (apply-generic op (car args) (raise (cadr args)))
                    (apply-generic op (raise (car args)) (cadr args))))
              (error
               "No method for these types -- APPLY-GENERIC"
               (list op type-tags)))))))


;;------ Number Systems ----------------------

;; normal number
;; eg) (add (make-scheme-number 3) (make-scheme-number 4))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))

  (define (scheme-number->complex x)
    (make-complex-from-real-imag (cdr x) 0))
  (define (scheme-number->rational x)
    (make-rational x 1))


  ;; ex2.94
  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))

  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (+ x y)))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (- x y)))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (* x y)))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (/ x y)))

  (put 'negation '(scheme-number)
       (lambda (x) (- x)))


  ;;
  ;; remove tag because it make number look dirty
  ;;

  ;; (put 'add '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (+ x y))))
  ;; (put 'sub '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (- x y))))
  ;; (put 'mul '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (* x y))))
  ;; (put 'div '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (/ x y))))
  ;; (put 'negation '(scheme-number)
  ;;     (lambda (x) (tag (- x))))


  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  (put 'ex-equ? '(scheme-number scheme-number)
       (lambda (x y) (= x y)))
  (put 'ex-zero? '(scheme-number)
       (lambda (x) (= x 0)))
  (put 'add-3 '(scheme-number scheme-number scheme-number)
       (lambda (a b c) (tag (+ a b c))))
  (put 'exp '(scheme-number scheme-number)
       (lambda (x y) (tag (expt x y))))

  (put 'raise '(scheme-number) scheme-number->rational)

  ;; ex2.94
  (put 'greatest-common-divisor '(scheme-number scheme-number)
       (lambda (a b) (tag (gcd a b))))

  'done)


(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))



;; real + imaginary number
;; 3 + 4i = (rectangular 3 . 4)
(define (square a) (* a a))
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))

  'done)

;; mag + angle number
;; 3 + 45' = (polar 3 . 45)
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

;; complex number
(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures

  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
                         (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))
  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))

  (define (add-complex-3 z1 z2 z3)
    (make-from-real-imag (+ (real-part z1) (real-part z2) (real-part z3))
                         (+ (imag-part z1) (imag-part z2) (imag-part z3))))

  (define (project-complex z)
    (make-rational (round (real-part z)) 1))

  (put 'add-3 '(complex complex complex)
       (lambda (z1 z2 z3) (tag (add-complex-3 z1 z2 z3))))

  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'ex-equ? '(complex complex)
       (lambda (z1 z2) (and (equal? (real-part z1) (real-part z2))
                            (equal? (imag-part z1) (imag-part z2)))))
  (put 'ex-zero? '(complex)
       (lambda (z1) (and (equal? (real-part z1) 0)
                         (equal? (imag-part z1) 0))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

  (put 'project '(complex) project-complex)

  (put 'negation '(complex)
       (lambda (z) (display "귀찮아서 안만듬")))

  'done)

;; complex 숫자들은 2개의 태그를 가진다.
;; make-comple-from-real-imag에서 'complex라는 태그를 추가해주고 
;; make-from-real-imag에서 'rectangular라는 태그를 추가해서
;; (complex rectangular 3 . 4) 와 같은 형태가 된다.
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)



;; rational number
;; eg) (add (make-rational 3 4) (make-rational 3 4))
(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))

  ;; ex2.93
  (define (make-rat n d)
      (cons n d))

  ;; ex2.93
  (define (add-rat x y)
    (make-rat (add (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
              (mul (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (sub (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
              (mul (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (mul (numer x) (numer y))
              (mul (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (mul (numer x) (denom y))
              (mul (denom x) (numer y))))


  ;; should be fixed to handle polynomial
  (define (ex-equ? x y)
    (and (= (numer x) (numer y))
         (= (denom x) (denom y))))
  (define (ex-zero? x)
    (= (numer x) 0))

  (define (rational->complex x)
    (make-complex-from-real-imag (round (/ (numer x) (denom x))) 0))

  (define (tag x) (attach-tag 'rational x))

  (define (project-rational x) ; rational -> scheme-number
    (make-scheme-number (round (/ (numer x) (denom x)))))


  ;; interface to rest of the system
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'ex-equ? '(rational rational) ex-equ?)
  (put 'ex-zero? '(rational) ex-zero?)
  (put 'raise '(rational) rational->complex)
  (put 'project '(rational) project-rational)

  (put 'negation '(rational)
       (lambda (x) (tag (make-rat ( - (numer x))
                                  (denom x)))))

  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))



;; sparse polynomial : variable and list of (order coeff)
;; eg) ('x ((100 2) (2 4) (0 5)))
(define (install-sparse-polynomial-package)
  ;; from ch2.3.2
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))

  (define (make-poly variable term-list)
    (cons variable term-list))

  (define (variable p) (car p))
  (define (term-list p) (cdr p))

  (define (zero-termlist? terms)
    (cond ((empty-termlist? terms)
           #t)
          ((zero? (coeff (first-term terms)))
           (zero-termlist? (rest-terms terms)))
          (else
           #f)))

  (define (adjoin-term term term-list)
    (if (ex-zero? (coeff term))
        term-list
        (cons term term-list)))

  (define (the-empty-termlist) '())
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))

  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))

  ;; tag = sparse
  (define (tag p) (attach-tag 'sparse p))

  (define (make-dense-from-sparse sparse-termlist)
    (if (empty-termlist? sparse-termlist) '()
        (make-dense-from-sparse-body (order (first-term sparse-termlist))
                                     sparse-termlist
                                     '())))
  (define (make-dense-from-sparse-body current-order termlist newlist)
    (cond ((< current-order 0) newlist)
          ((empty-termlist? termlist)
           (make-dense-from-sparse-body
            (- current-order 1)
            termlist
            (append newlist (list 0))))
          ((= current-order (order (first-term termlist)))
           (make-dense-from-sparse-body
            (- current-order 1)
            (rest-terms termlist)
            (append newlist (list (coeff (first-term termlist))))))
          (else
           (make-dense-from-sparse-body
            (- current-order 1)
            termlist
            (append newlist (list 0))))))


  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1))
                 (t2 (first-term L2)))
             (cond ((> (order t1) (order t2))
                    (adjoin-term t1
                                 (add-terms (rest-terms L1) L2)))
                   ((< (order t1) (order t2))
                    (adjoin-term t2
                                 (add-terms L1 (rest-terms L2))))
                   (else
                    (adjoin-term
                     (make-term (order t1)
                                (add (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))
                     
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
             
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ((t2 (first-term L)))
          (adjoin-term
           (make-term (+ (order t1) (order t2)) ; order of term
                      (mul (coeff t1) (coeff t2))) ; coeff of term
           (mul-term-by-all-terms t1 (rest-terms L))))))

  (define (negation-termlist termlist)
    (if (empty-termlist? termlist) '()
        (adjoin-term 
         (make-term (order (first-term termlist))
                    ; use negation again that can handle any type of coeff
                    (negation (coeff (first-term termlist))))
         (negation-termlist (rest-terms termlist)))))


  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- ADD-POLY" (list p1 p2))))

  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (mul-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- MUL-POLY" (list p1 p2))))


  ;;-------- ex2.91 ------------
  (define (div-terms L1 L2)
    (if (empty-termlist? L1)
        (list (the-empty-termlist) (the-empty-termlist))
        (let ((t1 (first-term L1))
              (t2 (first-term L2)))
          (if (> (order t2) (order t1))
              (list (the-empty-termlist) L1)  ;; L1 is remainder
              (let ((new-c (div (coeff t1) (coeff t2)))
                    (new-o (- (order t1) (order t2))))
                (let ((rest-of-result
                       ;; get next dividee
                       (div-terms (add-terms L1 
                                             (negation-termlist (mul-term-by-all-terms (list new-o new-c) L2)))
                                  L2)
                       ))
                  ;; get result
                  (list (cons (list new-o new-c) (car rest-of-result)) (cadr rest-of-result))
                  ))))))

  (define (div-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (div-terms (term-list p1) (term-list p2)))
        (error "Polys not in same var -- DIV-POLY" (list p1 p2))))


  ;; ex2.94
  (define (remainder-terms p1 p2)
    (cadr (div-terms p1 p2)))

  (define (gcd-terms a b)
    (if (empty-termlist? b)
        a
        (gcd-terms b (remainder-terms a b))))

  (define (gcd-poly a b)
    (if (same-variable? (variable a) (variable b))
        (make-poly (variable a) (gcd-terms (term-list a) (term-list b)))
        (error "Polys not in same var -- MUL-POLY" (list a b))))


  (put 'make 'sparse
       (lambda (var terms) (tag (make-poly var terms))))

  ;; term-list를 반드시 호출해야
  ;; 변수가 없어지고 각 term을 곧바로 처리할 수 있게 된다.
  (put 'ex-zero? '(sparse) 
       (lambda (terms) (zero-termlist? (term-list terms))))

  (put 'negation '(sparse)
       (lambda (termlist)
         (tag (make-poly (variable termlist)
                         (negation-termlist (term-list termlist))))))

  (put 'make-dense-from-sparse '(sparse) 
       (lambda (x)
         (attach-tag 'dense
                     (make-poly (variable x)
                                (make-dense-from-sparse (term-list x))))))


  ;; install operations
  (put 'add '(sparse sparse)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(sparse sparse)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))

  ;; ex2.91
  (put 'div '(sparse sparse)
       (lambda (p1 p2) (tag (div-poly p1 p2))))

  (put 'greatest-common-divisor '(sparse sparse)
       (lambda (p1 p2) (tag (gcd-poly p1 p2))))


  'done)

;; dense polynomial : variable and list of coeff (1 0 0 2 0 4)
;; eg) ('x (1 0 0 2 0 4))
(define (install-dense-polynomial-package)
  ;; from ch2.3.2
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  (define (make-poly variable coeff-list)
    (cons variable coeff-list))
  (define (variable p) (car p))
  (define (coeff-list p) (cdr p))
  (define (the-empty-termlist) '())
  (define (highest-coeff coeff-list)
    (car coeff-list)) ;; first-term -> highest-coeff
  (define (rest-coeffs coeff-list)
    (cdr coeff-list))   ;; rest-terms -> rest-coeffs
  (define (empty-coefflist? coeff-list)
    (null? coeff-list)) ;; empty-termlist? -> empty-coefflist?

  (define (zero-coefflist? coefflist)
    (cond ((empty-coefflist? coefflist)
           #t)
          ((zero? (highest-coeff coefflist)))
           (zero-coefflist? (rest-coeffs coefflist)))
          (else
           #f))

  (define (adjoin-coeff coeff coeff-list)
    (cons coeff coeff-list))

  (define (negation-coefflist coefflist)
    (if (empty-coefflist? coefflist) '()
        (adjoin-coeff (negation (highest-coeff coefflist))
                      (negation-coefflist (rest-coeffs coefflist)))))

  (define (tag p) (attach-tag 'dense p))

  ;; make-sparse-from-dense HERE!
  (define (make-sparse-from-dense coefflist)
    (if (empty-coefflist? coefflist) '()
        (make-sparse-from-dense-body (- (length coefflist) 1) coefflist)))

  (define (make-sparse-from-dense-body curr-order coefflist)
    (cond ((< curr-order 0) '())
          ((ex-zero? (highest-coeff coefflist))
           (make-sparse-from-dense-body (- curr-order 1)
                                        (rest-coeffs coefflist)))
          (else
           (cons (list curr-order (highest-coeff coefflist))
                 (make-sparse-from-dense-body (- curr-order 1)
                                              (rest-coeffs coefflist))))))

  ;; install operations
  (put 'make 'dense
       (lambda (var coeffs) (tag (make-poly var coeffs))))

  (put 'ex-zero? '(dense) 
       (lambda (coeffs) (zero-coefflist? (coeff-list coeffs))))

  (put 'negation '(dense)
       (lambda (coefflist)
         (tag (make-poly (variable coefflist)
                         (negation-coefflist (coeff-list coefflist))))))

  (put 'make-sparse-from-dense '(dense)
       (lambda (x)
         (attach-tag 'sparse
                     (make-poly (variable x)
                                (make-sparse-from-dense (coeff-list x))))))

  'done)



;; install generic procedure used for both of two types of polynomial
(define (install-polynomial-package)

  (define (tag p) (attach-tag 'polynomial p))
  (define (coeff-list p) (cdr p))
  (define (term-list p) (cdr p))

  ;; call procedure in each package
  (define (make-from-termlist v t)
    ((get 'make 'sparse) v t))
  (define (make-from-coefflist v c)
    ((get 'make 'dense) v c))

  (define (make-dense-from-sparse x)
    (apply-generic 'make-dense-from-sparse x))
  (define (make-sparse-from-dense x)
    (apply-generic 'make-sparse-from-dense x))

  (define (get-type p) (car p))

  (define (add-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (add p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (add p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (add (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (add (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC ADD for " p1 p2)))))

  (define (mul-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (mul p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (mul p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (mul (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (mul (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC MUL for " p1 p2)))))

  ;; ex2.91
  (define (div-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (div p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (div p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (div (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (div (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC DIV for " p1 p2)))))


  ;; ex2.94
  (define (gcd-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (greatest-common-divisor p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (greatest-common-divisor p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (greatest-common-divisor (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (greatest-common-divisor (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC GREATEST-COMMON-DIVISOR for " p1 p2)))))



  (put 'make-polynomial-from-termlist 'polynomial
       (lambda (v t) (tag (make-from-termlist v t))))
  (put 'make-polynomial-from-coefflist 'polynomial
       (lambda (v c) (tag (make-from-coefflist v c))))

  ;; apply-generic으로 호출된 make-dense-polynomial-from-sparse함수는
  ;; (polynomial) 태그는 없어졌지만 (sparse)태그는 없어지지 않았다.
  ;; 따라서 다시한번 apply-generic 으로 make-dense-from-sparse를
  ;; 호출하면 최종 패키지에서는 태그가 없고
  ;; 변수와 리스트만 있는 데이터가 전달된다.
  (put 'make-dense-polynomial-from-sparse '(polynomial)
       (lambda (x) (tag (make-dense-from-sparse x))))
  (put 'make-sparse-polynomial-from-dense '(polynomial)
       (lambda (x) (tag (make-sparse-from-dense x))))

  (put 'add '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))

  ;; no need to make another procedure for sub, but use add & negation
  (put 'sub '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 (negation p2)))))
  (put 'negation '(polynomial)
       (lambda (p) (tag (negation p))))

  ;; ex2.91
  (put 'div '(polynomial polynomial)
       (lambda (p1 p2) (tag (div-poly p1 p2))))

  (put 'greatest-common-divisor '(polynomial polynomial)
       (lambda (p1 p2) (tag (gcd-poly p1 p2))))

  'done)


(define (make-polynomial-from-termlist var termlist)
  ((get 'make-polynomial-from-termlist 'polynomial) var termlist))
(define (make-polynomial-from-coefflist var coefflist)
  ((get 'make-polynomial-from-coefflist 'polynomial) var coefflist))
(define (make-polynomial var termlist)
  ((get 'make-polynomial-from-termlist 'polynomial) var termlist))

(define (make-dense-polynomial-from-sparse sparselist)
  (apply-generic 'make-dense-polynomial-from-sparse sparselist))
(define (make-sparse-polynomial-from-dense denselist)
  (apply-generic 'make-sparse-polynomial-from-dense denselist))


                 
;;--------- test ----------------

;; MUST INSTALL!!
(install-scheme-number-package)
(install-rational-package)
(install-polar-package)
(install-rectangular-package)
(install-complex-package)
(install-sparse-polynomial-package)
(install-dense-polynomial-package)
(install-polynomial-package)



(define p1 (make-polynomial 'x '((4 1) (3 -1) (2 -2) (1 2))))
(define p2 (make-polynomial 'x '((3 1) (1 -1))))


;; result -> (polynomial sparse x (2 -1) (1 1))
(greatest-common-divisor p1 p2)
}}}


== 2.95.scm ==


{{{
;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;; (put <op> <type> <item>)
;; (get <op> <type>
;;------------------------------------------------


;;----- GENERIC PROCEDURES -----------------

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (ex-equ? x y) (apply-generic 'ex-equ? x y))
(define (ex-zero? x) (apply-generic 'ex-zero? x))
(define (exp x y) (apply-generic 'exp x y))
(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))
(define (add-3 a b c) (apply-generic 'add-3 a b c))

(define (negation x) (apply-generic 'negation x))

(define (greatest-common-divisor x y) (apply-generic 'greatest-common-divisor x y))



(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
        (error "Bad tagged datum -- TYPE-TAG" datum)))

(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (error "Bad tagged datum -- CONTENTS" datum)))

(define (raise x) (apply-generic 'raise x))

(define (project z)
  (apply-generic 'project z))

(define (install-get-higher-system)
  (put 'scheme-number 'rational 'rational)
  (put 'scheme-number 'complex 'complex)
  (put 'rational 'scheme-number 'rational)
  (put 'rational 'complex 'complex)
  (put 'complex 'scheme-number 'complex)
  (put 'complex 'rational 'complex))
(install-get-higher-system)       

(define (former-is-higher-system? type1 type2)
  (cond ((eq? type1 type2) #f)
        ((and (eq? type1 'rational) (eq? type2 'scheme-number)) #t)
        ((eq? type1 'complex) #t)
        (else #f)))

(define (drop x)
  (cond ((eq? (type-tag x) 'scheme-number) x)
        ((ex-equ? (raise (project x)) x) (drop (project x)))
        (else x)))


;; fail to make new apply-generic which is applied with drop procedure
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args))) ;; extract tags of each arguments
    (let ((proc (get op type-tags)))
      (if proc
          ;; I tried (drop (apply proc (map contents args))),
          ;; but it generated Stack-Overflow.
          ;; I failed to make new apply-generic procedure.
          (apply proc (map contents args)) ;; extract data
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (if (former-is-higher-system? type1 type2)
                    (apply-generic op (car args) (raise (cadr args)))
                    (apply-generic op (raise (car args)) (cadr args))))
              (error
               "No method for these types -- APPLY-GENERIC"
               (list op type-tags)))))))


;;------ Number Systems ----------------------

;; normal number
;; eg) (add (make-scheme-number 3) (make-scheme-number 4))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))

  (define (scheme-number->complex x)
    (make-complex-from-real-imag (cdr x) 0))
  (define (scheme-number->rational x)
    (make-rational x 1))


  ;; ex2.94
  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))

  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (+ x y)))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (- x y)))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (* x y)))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (/ x y)))

  (put 'negation '(scheme-number)
       (lambda (x) (- x)))


  ;;
  ;; remove tag because it make number look dirty
  ;;

  ;; (put 'add '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (+ x y))))
  ;; (put 'sub '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (- x y))))
  ;; (put 'mul '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (* x y))))
  ;; (put 'div '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (/ x y))))
  ;; (put 'negation '(scheme-number)
  ;;     (lambda (x) (tag (- x))))


  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  (put 'ex-equ? '(scheme-number scheme-number)
       (lambda (x y) (= x y)))
  (put 'ex-zero? '(scheme-number)
       (lambda (x) (= x 0)))
  (put 'add-3 '(scheme-number scheme-number scheme-number)
       (lambda (a b c) (tag (+ a b c))))
  (put 'exp '(scheme-number scheme-number)
       (lambda (x y) (tag (expt x y))))

  (put 'raise '(scheme-number) scheme-number->rational)

  ;; ex2.94
  (put 'greatest-common-divisor '(scheme-number scheme-number)
       (lambda (a b) (tag (gcd a b))))

  'done)


(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))



;; real + imaginary number
;; 3 + 4i = (rectangular 3 . 4)
(define (square a) (* a a))
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))

  'done)

;; mag + angle number
;; 3 + 45' = (polar 3 . 45)
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

;; complex number
(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures

  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
                         (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))
  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))

  (define (add-complex-3 z1 z2 z3)
    (make-from-real-imag (+ (real-part z1) (real-part z2) (real-part z3))
                         (+ (imag-part z1) (imag-part z2) (imag-part z3))))

  (define (project-complex z)
    (make-rational (round (real-part z)) 1))

  (put 'add-3 '(complex complex complex)
       (lambda (z1 z2 z3) (tag (add-complex-3 z1 z2 z3))))

  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'ex-equ? '(complex complex)
       (lambda (z1 z2) (and (equal? (real-part z1) (real-part z2))
                            (equal? (imag-part z1) (imag-part z2)))))
  (put 'ex-zero? '(complex)
       (lambda (z1) (and (equal? (real-part z1) 0)
                         (equal? (imag-part z1) 0))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

  (put 'project '(complex) project-complex)

  (put 'negation '(complex)
       (lambda (z) (display "귀찮아서 안만듬")))

  'done)

;; complex 숫자들은 2개의 태그를 가진다.
;; make-comple-from-real-imag에서 'complex라는 태그를 추가해주고 
;; make-from-real-imag에서 'rectangular라는 태그를 추가해서
;; (complex rectangular 3 . 4) 와 같은 형태가 된다.
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)



;; rational number
;; eg) (add (make-rational 3 4) (make-rational 3 4))
(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))

  ;; ex2.93
  (define (make-rat n d)
    (let (gcd (greatest-common-divisor n d))
      (cons (div n gcd) (div d gcd))))

  ;; ex2.93
  (define (add-rat x y)
    (make-rat (add (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
              (mul (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (sub (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
              (mul (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (mul (numer x) (numer y))
              (mul (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (mul (numer x) (denom y))
              (mul (denom x) (numer y))))


  ;; should be fixed to handle polynomial
  (define (ex-equ? x y)
    (and (= (numer x) (numer y))
         (= (denom x) (denom y))))
  (define (ex-zero? x)
    (= (numer x) 0))

  (define (rational->complex x)
    (make-complex-from-real-imag (round (/ (numer x) (denom x))) 0))

  (define (tag x) (attach-tag 'rational x))

  (define (project-rational x) ; rational -> scheme-number
    (make-scheme-number (round (/ (numer x) (denom x)))))


  ;; interface to rest of the system
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'ex-equ? '(rational rational) ex-equ?)
  (put 'ex-zero? '(rational) ex-zero?)
  (put 'raise '(rational) rational->complex)
  (put 'project '(rational) project-rational)

  (put 'negation '(rational)
       (lambda (x) (tag (make-rat ( - (numer x))
                                  (denom x)))))

  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))



;; sparse polynomial : variable and list of (order coeff)
;; eg) ('x ((100 2) (2 4) (0 5)))
(define (install-sparse-polynomial-package)
  ;; from ch2.3.2
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))

  (define (make-poly variable term-list)
    (cons variable term-list))

  (define (variable p) (car p))
  (define (term-list p) (cdr p))

  (define (zero-termlist? terms)
    (cond ((empty-termlist? terms)
           #t)
          ((zero? (coeff (first-term terms)))
           (zero-termlist? (rest-terms terms)))
          (else
           #f)))

  (define (adjoin-term term term-list)
    (if (ex-zero? (coeff term))
        term-list
        (cons term term-list)))

  (define (the-empty-termlist) '())
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))

  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))

  ;; tag = sparse
  (define (tag p) (attach-tag 'sparse p))

  (define (make-dense-from-sparse sparse-termlist)
    (if (empty-termlist? sparse-termlist) '()
        (make-dense-from-sparse-body (order (first-term sparse-termlist))
                                     sparse-termlist
                                     '())))
  (define (make-dense-from-sparse-body current-order termlist newlist)
    (cond ((< current-order 0) newlist)
          ((empty-termlist? termlist)
           (make-dense-from-sparse-body
            (- current-order 1)
            termlist
            (append newlist (list 0))))
          ((= current-order (order (first-term termlist)))
           (make-dense-from-sparse-body
            (- current-order 1)
            (rest-terms termlist)
            (append newlist (list (coeff (first-term termlist))))))
          (else
           (make-dense-from-sparse-body
            (- current-order 1)
            termlist
            (append newlist (list 0))))))


  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1))
                 (t2 (first-term L2)))
             (cond ((> (order t1) (order t2))
                    (adjoin-term t1
                                 (add-terms (rest-terms L1) L2)))
                   ((< (order t1) (order t2))
                    (adjoin-term t2
                                 (add-terms L1 (rest-terms L2))))
                   (else
                    (adjoin-term
                     (make-term (order t1)
                                (add (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))
                     
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
             
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ((t2 (first-term L)))
          (adjoin-term
           (make-term (+ (order t1) (order t2)) ; order of term
                      (mul (coeff t1) (coeff t2))) ; coeff of term
           (mul-term-by-all-terms t1 (rest-terms L))))))

  (define (negation-termlist termlist)
    (if (empty-termlist? termlist) '()
        (adjoin-term 
         (make-term (order (first-term termlist))
                    ; use negation again that can handle any type of coeff
                    (negation (coeff (first-term termlist))))
         (negation-termlist (rest-terms termlist)))))


  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- ADD-POLY" (list p1 p2))))

  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (mul-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- MUL-POLY" (list p1 p2))))


  ;;-------- ex2.91 ------------
  (define (div-terms L1 L2)
    (if (empty-termlist? L1)
        (list (the-empty-termlist) (the-empty-termlist))
        (let ((t1 (first-term L1))
              (t2 (first-term L2)))
          (if (> (order t2) (order t1))
              (list (the-empty-termlist) L1)  ;; L1 is remainder
              (let ((new-c (div (coeff t1) (coeff t2)))
                    (new-o (- (order t1) (order t2))))
                (let ((rest-of-result
                       ;; get next dividee
                       (div-terms (add-terms L1 
                                             (negation-termlist (mul-term-by-all-terms (list new-o new-c) L2)))
                                  L2)
                       ))
                  ;; get result
                  (list (cons (list new-o new-c) (car rest-of-result)) (cadr rest-of-result))
                  ))))))

  (define (div-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (div-terms (term-list p1) (term-list p2)))
        (error "Polys not in same var -- DIV-POLY" (list p1 p2))))


  ;; ex2.94
  (define (remainder-terms p1 p2)
    (cadr (div-terms p1 p2)))

  (define (gcd-terms a b)
    (if (empty-termlist? b)
        a
        (gcd-terms b (remainder-terms a b))))


  (define (gcd-poly a b)
    (if (same-variable? (variable a) (variable b))
        (make-poly (variable a) (gcd-terms (term-list a) (term-list b)))
        (error "Polys not in same var -- MUL-POLY" (list a b))))


  (put 'make 'sparse
       (lambda (var terms) (tag (make-poly var terms))))

  ;; term-list를 반드시 호출해야
  ;; 변수가 없어지고 각 term을 곧바로 처리할 수 있게 된다.
  (put 'ex-zero? '(sparse) 
       (lambda (terms) (zero-termlist? (term-list terms))))

  (put 'negation '(sparse)
       (lambda (termlist)
         (tag (make-poly (variable termlist)
                         (negation-termlist (term-list termlist))))))

  (put 'make-dense-from-sparse '(sparse) 
       (lambda (x)
         (attach-tag 'dense
                     (make-poly (variable x)
                                (make-dense-from-sparse (term-list x))))))


  ;; install operations
  (put 'add '(sparse sparse)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(sparse sparse)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))

  ;; ex2.91
  (put 'div '(sparse sparse)
       (lambda (p1 p2) (tag (div-poly p1 p2))))

  (put 'greatest-common-divisor '(sparse sparse)
       (lambda (p1 p2) (tag (gcd-poly p1 p2))))


  'done)

;; dense polynomial : variable and list of coeff (1 0 0 2 0 4)
;; eg) ('x (1 0 0 2 0 4))
(define (install-dense-polynomial-package)
  ;; from ch2.3.2
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  (define (make-poly variable coeff-list)
    (cons variable coeff-list))
  (define (variable p) (car p))
  (define (coeff-list p) (cdr p))
  (define (the-empty-termlist) '())
  (define (highest-coeff coeff-list)
    (car coeff-list)) ;; first-term -> highest-coeff
  (define (rest-coeffs coeff-list)
    (cdr coeff-list))   ;; rest-terms -> rest-coeffs
  (define (empty-coefflist? coeff-list)
    (null? coeff-list)) ;; empty-termlist? -> empty-coefflist?

  (define (zero-coefflist? coefflist)
    (cond ((empty-coefflist? coefflist)
           #t)
          ((zero? (highest-coeff coefflist)))
           (zero-coefflist? (rest-coeffs coefflist)))
          (else
           #f))

  (define (adjoin-coeff coeff coeff-list)
    (cons coeff coeff-list))

  (define (negation-coefflist coefflist)
    (if (empty-coefflist? coefflist) '()
        (adjoin-coeff (negation (highest-coeff coefflist))
                      (negation-coefflist (rest-coeffs coefflist)))))

  (define (tag p) (attach-tag 'dense p))

  ;; make-sparse-from-dense HERE!
  (define (make-sparse-from-dense coefflist)
    (if (empty-coefflist? coefflist) '()
        (make-sparse-from-dense-body (- (length coefflist) 1) coefflist)))

  (define (make-sparse-from-dense-body curr-order coefflist)
    (cond ((< curr-order 0) '())
          ((ex-zero? (highest-coeff coefflist))
           (make-sparse-from-dense-body (- curr-order 1)
                                        (rest-coeffs coefflist)))
          (else
           (cons (list curr-order (highest-coeff coefflist))
                 (make-sparse-from-dense-body (- curr-order 1)
                                              (rest-coeffs coefflist))))))

  ;; install operations
  (put 'make 'dense
       (lambda (var coeffs) (tag (make-poly var coeffs))))

  (put 'ex-zero? '(dense) 
       (lambda (coeffs) (zero-coefflist? (coeff-list coeffs))))

  (put 'negation '(dense)
       (lambda (coefflist)
         (tag (make-poly (variable coefflist)
                         (negation-coefflist (coeff-list coefflist))))))

  (put 'make-sparse-from-dense '(dense)
       (lambda (x)
         (attach-tag 'sparse
                     (make-poly (variable x)
                                (make-sparse-from-dense (coeff-list x))))))

  'done)



;; install generic procedure used for both of two types of polynomial
(define (install-polynomial-package)

  (define (tag p) (attach-tag 'polynomial p))
  (define (coeff-list p) (cdr p))
  (define (term-list p) (cdr p))

  ;; call procedure in each package
  (define (make-from-termlist v t)
    ((get 'make 'sparse) v t))
  (define (make-from-coefflist v c)
    ((get 'make 'dense) v c))

  (define (make-dense-from-sparse x)
    (apply-generic 'make-dense-from-sparse x))
  (define (make-sparse-from-dense x)
    (apply-generic 'make-sparse-from-dense x))

  (define (get-type p) (car p))

  (define (add-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (add p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (add p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (add (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (add (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC ADD for " p1 p2)))))

  (define (mul-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (mul p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (mul p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (mul (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (mul (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC MUL for " p1 p2)))))

  ;; ex2.91
  (define (div-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (div p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (div p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (div (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (div (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC DIV for " p1 p2)))))


  ;; ex2.94
  (define (gcd-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (greatest-common-divisor p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (greatest-common-divisor p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (greatest-common-divisor (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (greatest-common-divisor (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC GREATEST-COMMON-DIVISOR for " p1 p2)))))



  (put 'make-polynomial-from-termlist 'polynomial
       (lambda (v t) (tag (make-from-termlist v t))))
  (put 'make-polynomial-from-coefflist 'polynomial
       (lambda (v c) (tag (make-from-coefflist v c))))

  ;; apply-generic으로 호출된 make-dense-polynomial-from-sparse함수는
  ;; (polynomial) 태그는 없어졌지만 (sparse)태그는 없어지지 않았다.
  ;; 따라서 다시한번 apply-generic 으로 make-dense-from-sparse를
  ;; 호출하면 최종 패키지에서는 태그가 없고
  ;; 변수와 리스트만 있는 데이터가 전달된다.
  (put 'make-dense-polynomial-from-sparse '(polynomial)
       (lambda (x) (tag (make-dense-from-sparse x))))
  (put 'make-sparse-polynomial-from-dense '(polynomial)
       (lambda (x) (tag (make-sparse-from-dense x))))

  (put 'add '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))

  ;; no need to make another procedure for sub, but use add & negation
  (put 'sub '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 (negation p2)))))
  (put 'negation '(polynomial)
       (lambda (p) (tag (negation p))))

  ;; ex2.91
  (put 'div '(polynomial polynomial)
       (lambda (p1 p2) (tag (div-poly p1 p2))))

  (put 'greatest-common-divisor '(polynomial polynomial)
       (lambda (p1 p2) (tag (gcd-poly p1 p2))))

  'done)


(define (make-polynomial-from-termlist var termlist)
  ((get 'make-polynomial-from-termlist 'polynomial) var termlist))
(define (make-polynomial-from-coefflist var coefflist)
  ((get 'make-polynomial-from-coefflist 'polynomial) var coefflist))
(define (make-polynomial var termlist)
  ((get 'make-polynomial-from-termlist 'polynomial) var termlist))

(define (make-dense-polynomial-from-sparse sparselist)
  (apply-generic 'make-dense-polynomial-from-sparse sparselist))
(define (make-sparse-polynomial-from-dense denselist)
  (apply-generic 'make-sparse-polynomial-from-dense denselist))


                 
;;--------- test ----------------

;; MUST INSTALL!!
(install-scheme-number-package)
(install-rational-package)
(install-polar-package)
(install-rectangular-package)
(install-complex-package)
(install-sparse-polynomial-package)
(install-dense-polynomial-package)
(install-polynomial-package)



(define p1 (make-polynomial 'x '((2 1) (1 -2) (0 1))))
(define p2 (make-polynomial 'x '((2 11) (0 7))))
(define p3 (make-polynomial 'x '((1 13) (0 5))))

;; (polynomial sparse x (4 11) (3 -22) (2 18) (1 -14) (0 7))
;; (polynomial sparse x (3 13) (2 -21) (1 3) (0 5))
(define q1 (mul p1 p2))
(define q2 (mul p1 p3))

;;old result -> (polynomial sparse x (2 1458/169) (1 -2916/169) (0 1458/169))
;;factor = 13^2 = 169
;;new result -> (polynomial sparse x (2 1458) (1 -2916) (0 1458))
;; GCD of q1,q2 must be p1, so that the result should be redused by GCD of all coeffs.
;; final result -> (polynomial sparse x (2 1) (1 -2) (0 1)) == p1
(greatest-common-divisor q1 q2)


(div q1 (make-polynomial 'x '((2 1) (1 -2) (0 1))))
}}}


== 2.96.scm ==


{{{
;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;; (put <op> <type> <item>)
;; (get <op> <type>
;;------------------------------------------------


;;----- GENERIC PROCEDURES -----------------

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (ex-equ? x y) (apply-generic 'ex-equ? x y))
(define (ex-zero? x) (apply-generic 'ex-zero? x))
(define (exp x y) (apply-generic 'exp x y))
(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))
(define (add-3 a b c) (apply-generic 'add-3 a b c))

(define (negation x) (apply-generic 'negation x))

(define (greatest-common-divisor x y) (apply-generic 'greatest-common-divisor x y))



(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
        (error "Bad tagged datum -- TYPE-TAG" datum)))

(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (error "Bad tagged datum -- CONTENTS" datum)))

(define (raise x) (apply-generic 'raise x))

(define (project z)
  (apply-generic 'project z))

(define (install-get-higher-system)
  (put 'scheme-number 'rational 'rational)
  (put 'scheme-number 'complex 'complex)
  (put 'rational 'scheme-number 'rational)
  (put 'rational 'complex 'complex)
  (put 'complex 'scheme-number 'complex)
  (put 'complex 'rational 'complex))
(install-get-higher-system)       

(define (former-is-higher-system? type1 type2)
  (cond ((eq? type1 type2) #f)
        ((and (eq? type1 'rational) (eq? type2 'scheme-number)) #t)
        ((eq? type1 'complex) #t)
        (else #f)))

(define (drop x)
  (cond ((eq? (type-tag x) 'scheme-number) x)
        ((ex-equ? (raise (project x)) x) (drop (project x)))
        (else x)))


;; fail to make new apply-generic which is applied with drop procedure
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args))) ;; extract tags of each arguments
    (let ((proc (get op type-tags)))
      (if proc
          ;; I tried (drop (apply proc (map contents args))),
          ;; but it generated Stack-Overflow.
          ;; I failed to make new apply-generic procedure.
          (apply proc (map contents args)) ;; extract data
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (if (former-is-higher-system? type1 type2)
                    (apply-generic op (car args) (raise (cadr args)))
                    (apply-generic op (raise (car args)) (cadr args))))
              (error
               "No method for these types -- APPLY-GENERIC"
               (list op type-tags)))))))


;;------ Number Systems ----------------------

;; normal number
;; eg) (add (make-scheme-number 3) (make-scheme-number 4))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))

  (define (scheme-number->complex x)
    (make-complex-from-real-imag (cdr x) 0))
  (define (scheme-number->rational x)
    (make-rational x 1))


  ;; ex2.94
  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))

  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (+ x y)))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (- x y)))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (* x y)))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (/ x y)))

  (put 'negation '(scheme-number)
       (lambda (x) (- x)))


  ;;
  ;; remove tag because it make number look dirty
  ;;

  ;; (put 'add '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (+ x y))))
  ;; (put 'sub '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (- x y))))
  ;; (put 'mul '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (* x y))))
  ;; (put 'div '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (/ x y))))
  ;; (put 'negation '(scheme-number)
  ;;     (lambda (x) (tag (- x))))


  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  (put 'ex-equ? '(scheme-number scheme-number)
       (lambda (x y) (= x y)))
  (put 'ex-zero? '(scheme-number)
       (lambda (x) (= x 0)))
  (put 'add-3 '(scheme-number scheme-number scheme-number)
       (lambda (a b c) (tag (+ a b c))))
  (put 'exp '(scheme-number scheme-number)
       (lambda (x y) (tag (expt x y))))

  (put 'raise '(scheme-number) scheme-number->rational)

  ;; ex2.94
  (put 'greatest-common-divisor '(scheme-number scheme-number)
       (lambda (a b) (tag (gcd a b))))

  'done)


(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))



;; real + imaginary number
;; 3 + 4i = (rectangular 3 . 4)
(define (square a) (* a a))
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))

  'done)

;; mag + angle number
;; 3 + 45' = (polar 3 . 45)
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

;; complex number
(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures

  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
                         (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))
  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))

  (define (add-complex-3 z1 z2 z3)
    (make-from-real-imag (+ (real-part z1) (real-part z2) (real-part z3))
                         (+ (imag-part z1) (imag-part z2) (imag-part z3))))

  (define (project-complex z)
    (make-rational (round (real-part z)) 1))

  (put 'add-3 '(complex complex complex)
       (lambda (z1 z2 z3) (tag (add-complex-3 z1 z2 z3))))

  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'ex-equ? '(complex complex)
       (lambda (z1 z2) (and (equal? (real-part z1) (real-part z2))
                            (equal? (imag-part z1) (imag-part z2)))))
  (put 'ex-zero? '(complex)
       (lambda (z1) (and (equal? (real-part z1) 0)
                         (equal? (imag-part z1) 0))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

  (put 'project '(complex) project-complex)

  (put 'negation '(complex)
       (lambda (z) (display "귀찮아서 안만듬")))

  'done)

;; complex 숫자들은 2개의 태그를 가진다.
;; make-comple-from-real-imag에서 'complex라는 태그를 추가해주고 
;; make-from-real-imag에서 'rectangular라는 태그를 추가해서
;; (complex rectangular 3 . 4) 와 같은 형태가 된다.
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)



;; rational number
;; eg) (add (make-rational 3 4) (make-rational 3 4))
(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))

  ;; ex2.93
  (define (make-rat n d)
    (let (gcd (greatest-common-divisor n d))
      (cons (div n gcd) (div d gcd))))

  ;; ex2.93
  (define (add-rat x y)
    (make-rat (add (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
              (mul (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (sub (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
              (mul (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (mul (numer x) (numer y))
              (mul (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (mul (numer x) (denom y))
              (mul (denom x) (numer y))))


  ;; should be fixed to handle polynomial
  (define (ex-equ? x y)
    (and (= (numer x) (numer y))
         (= (denom x) (denom y))))
  (define (ex-zero? x)
    (= (numer x) 0))

  (define (rational->complex x)
    (make-complex-from-real-imag (round (/ (numer x) (denom x))) 0))

  (define (tag x) (attach-tag 'rational x))

  (define (project-rational x) ; rational -> scheme-number
    (make-scheme-number (round (/ (numer x) (denom x)))))


  ;; interface to rest of the system
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'ex-equ? '(rational rational) ex-equ?)
  (put 'ex-zero? '(rational) ex-zero?)
  (put 'raise '(rational) rational->complex)
  (put 'project '(rational) project-rational)

  (put 'negation '(rational)
       (lambda (x) (tag (make-rat ( - (numer x))
                                  (denom x)))))

  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))



;; sparse polynomial : variable and list of (order coeff)
;; eg) ('x ((100 2) (2 4) (0 5)))
(define (install-sparse-polynomial-package)
  ;; from ch2.3.2
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))

  (define (make-poly variable term-list)
    (cons variable term-list))

  (define (variable p) (car p))
  (define (term-list p) (cdr p))

  (define (zero-termlist? terms)
    (cond ((empty-termlist? terms)
           #t)
          ((zero? (coeff (first-term terms)))
           (zero-termlist? (rest-terms terms)))
          (else
           #f)))

  (define (adjoin-term term term-list)
    (if (ex-zero? (coeff term))
        term-list
        (cons term term-list)))

  (define (the-empty-termlist) '())
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))

  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))

  ;; tag = sparse
  (define (tag p) (attach-tag 'sparse p))

  (define (make-dense-from-sparse sparse-termlist)
    (if (empty-termlist? sparse-termlist) '()
        (make-dense-from-sparse-body (order (first-term sparse-termlist))
                                     sparse-termlist
                                     '())))
  (define (make-dense-from-sparse-body current-order termlist newlist)
    (cond ((< current-order 0) newlist)
          ((empty-termlist? termlist)
           (make-dense-from-sparse-body
            (- current-order 1)
            termlist
            (append newlist (list 0))))
          ((= current-order (order (first-term termlist)))
           (make-dense-from-sparse-body
            (- current-order 1)
            (rest-terms termlist)
            (append newlist (list (coeff (first-term termlist))))))
          (else
           (make-dense-from-sparse-body
            (- current-order 1)
            termlist
            (append newlist (list 0))))))


  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1))
                 (t2 (first-term L2)))
             (cond ((> (order t1) (order t2))
                    (adjoin-term t1
                                 (add-terms (rest-terms L1) L2)))
                   ((< (order t1) (order t2))
                    (adjoin-term t2
                                 (add-terms L1 (rest-terms L2))))
                   (else
                    (adjoin-term
                     (make-term (order t1)
                                (add (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))
                     
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
             
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ((t2 (first-term L)))
          (adjoin-term
           (make-term (+ (order t1) (order t2)) ; order of term
                      (mul (coeff t1) (coeff t2))) ; coeff of term
           (mul-term-by-all-terms t1 (rest-terms L))))))

  (define (negation-termlist termlist)
    (if (empty-termlist? termlist) '()
        (adjoin-term 
         (make-term (order (first-term termlist))
                    ; use negation again that can handle any type of coeff
                    (negation (coeff (first-term termlist))))
         (negation-termlist (rest-terms termlist)))))


  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- ADD-POLY" (list p1 p2))))

  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (mul-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- MUL-POLY" (list p1 p2))))


  ;;-------- ex2.91 ------------
  (define (div-terms L1 L2)
    (if (empty-termlist? L1)
        (list (the-empty-termlist) (the-empty-termlist))
        (let ((t1 (first-term L1))
              (t2 (first-term L2)))
          (if (> (order t2) (order t1))
              (list (the-empty-termlist) L1)  ;; L1 is remainder
              (let ((new-c (div (coeff t1) (coeff t2)))
                    (new-o (- (order t1) (order t2))))
                (let ((rest-of-result
                       ;; get next dividee
                       (div-terms (add-terms L1 
                                             (negation-termlist (mul-term-by-all-terms (list new-o new-c) L2)))
                                  L2)
                       ))
                  ;; get result
                  (list (cons (list new-o new-c) (car rest-of-result)) (cadr rest-of-result))
                  ))))))

  (define (div-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (div-terms (term-list p1) (term-list p2)))
        (error "Polys not in same var -- DIV-POLY" (list p1 p2))))


  ;; ex2.94
  (define (remainder-terms p1 p2)
    (cadr (div-terms p1 p2)))

  ;; ex2.96
  (define (mul-terms-by-int terms val)
    (if (eq? terms '()) '()
        (cons (list (car (car terms)) (* val (cadr (car terms))))
              (mul-terms-by-int (cdr terms) val))))
  (define (div-terms-by-int terms val)
    (if (eq? terms '()) '()
        (cons (list (car (car terms)) (/ (cadr (car terms)) val))
              (div-terms-by-int (cdr terms) val))))
  (define (pseudoremainder-terms p1 p2)
    (let ((o1 (order (first-term p1)))
          (o2 (order (first-term p2)))
          (c (coeff (first-term p2))))
      (let ((factor (expt c (+ 1 (- o1 o2)))))
        (cadr (div-terms (mul-terms-by-int p1 factor) p2)))))

  (define (gcd-terms-body a b)
    (if (empty-termlist? b)
        a
        (gcd-terms-body b (pseudoremainder-terms a b))))

  (define (gcd-terms a b)
    (if (empty-termlist? b)
        a
        (let ((result (gcd-terms-body a b)))
          (let ((gcd-all-coeffs (apply gcd (map (lambda (x) (cadr x)) result))))
            (div-terms-by-int result gcd-all-coeffs)))))

  (define (gcd-poly a b)
    (if (same-variable? (variable a) (variable b))
        (make-poly (variable a) (gcd-terms (term-list a) (term-list b)))
        (error "Polys not in same var -- MUL-POLY" (list a b))))


  (put 'make 'sparse
       (lambda (var terms) (tag (make-poly var terms))))

  ;; term-list를 반드시 호출해야
  ;; 변수가 없어지고 각 term을 곧바로 처리할 수 있게 된다.
  (put 'ex-zero? '(sparse) 
       (lambda (terms) (zero-termlist? (term-list terms))))

  (put 'negation '(sparse)
       (lambda (termlist)
         (tag (make-poly (variable termlist)
                         (negation-termlist (term-list termlist))))))

  (put 'make-dense-from-sparse '(sparse) 
       (lambda (x)
         (attach-tag 'dense
                     (make-poly (variable x)
                                (make-dense-from-sparse (term-list x))))))


  ;; install operations
  (put 'add '(sparse sparse)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(sparse sparse)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))

  ;; ex2.91
  (put 'div '(sparse sparse)
       (lambda (p1 p2) (tag (div-poly p1 p2))))

  (put 'greatest-common-divisor '(sparse sparse)
       (lambda (p1 p2) (tag (gcd-poly p1 p2))))


  'done)

;; dense polynomial : variable and list of coeff (1 0 0 2 0 4)
;; eg) ('x (1 0 0 2 0 4))
(define (install-dense-polynomial-package)
  ;; from ch2.3.2
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  (define (make-poly variable coeff-list)
    (cons variable coeff-list))
  (define (variable p) (car p))
  (define (coeff-list p) (cdr p))
  (define (the-empty-termlist) '())
  (define (highest-coeff coeff-list)
    (car coeff-list)) ;; first-term -> highest-coeff
  (define (rest-coeffs coeff-list)
    (cdr coeff-list))   ;; rest-terms -> rest-coeffs
  (define (empty-coefflist? coeff-list)
    (null? coeff-list)) ;; empty-termlist? -> empty-coefflist?

  (define (zero-coefflist? coefflist)
    (cond ((empty-coefflist? coefflist)
           #t)
          ((zero? (highest-coeff coefflist)))
           (zero-coefflist? (rest-coeffs coefflist)))
          (else
           #f))

  (define (adjoin-coeff coeff coeff-list)
    (cons coeff coeff-list))

  (define (negation-coefflist coefflist)
    (if (empty-coefflist? coefflist) '()
        (adjoin-coeff (negation (highest-coeff coefflist))
                      (negation-coefflist (rest-coeffs coefflist)))))

  (define (tag p) (attach-tag 'dense p))

  ;; make-sparse-from-dense HERE!
  (define (make-sparse-from-dense coefflist)
    (if (empty-coefflist? coefflist) '()
        (make-sparse-from-dense-body (- (length coefflist) 1) coefflist)))

  (define (make-sparse-from-dense-body curr-order coefflist)
    (cond ((< curr-order 0) '())
          ((ex-zero? (highest-coeff coefflist))
           (make-sparse-from-dense-body (- curr-order 1)
                                        (rest-coeffs coefflist)))
          (else
           (cons (list curr-order (highest-coeff coefflist))
                 (make-sparse-from-dense-body (- curr-order 1)
                                              (rest-coeffs coefflist))))))

  ;; install operations
  (put 'make 'dense
       (lambda (var coeffs) (tag (make-poly var coeffs))))

  (put 'ex-zero? '(dense) 
       (lambda (coeffs) (zero-coefflist? (coeff-list coeffs))))

  (put 'negation '(dense)
       (lambda (coefflist)
         (tag (make-poly (variable coefflist)
                         (negation-coefflist (coeff-list coefflist))))))

  (put 'make-sparse-from-dense '(dense)
       (lambda (x)
         (attach-tag 'sparse
                     (make-poly (variable x)
                                (make-sparse-from-dense (coeff-list x))))))

  'done)



;; install generic procedure used for both of two types of polynomial
(define (install-polynomial-package)

  (define (tag p) (attach-tag 'polynomial p))
  (define (coeff-list p) (cdr p))
  (define (term-list p) (cdr p))

  ;; call procedure in each package
  (define (make-from-termlist v t)
    ((get 'make 'sparse) v t))
  (define (make-from-coefflist v c)
    ((get 'make 'dense) v c))

  (define (make-dense-from-sparse x)
    (apply-generic 'make-dense-from-sparse x))
  (define (make-sparse-from-dense x)
    (apply-generic 'make-sparse-from-dense x))

  (define (get-type p) (car p))

  (define (add-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (add p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (add p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (add (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (add (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC ADD for " p1 p2)))))

  (define (mul-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (mul p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (mul p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (mul (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (mul (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC MUL for " p1 p2)))))

  ;; ex2.91
  (define (div-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (div p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (div p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (div (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (div (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC DIV for " p1 p2)))))


  ;; ex2.94
  (define (gcd-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (greatest-common-divisor p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (greatest-common-divisor p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (greatest-common-divisor (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (greatest-common-divisor (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC GREATEST-COMMON-DIVISOR for " p1 p2)))))



  (put 'make-polynomial-from-termlist 'polynomial
       (lambda (v t) (tag (make-from-termlist v t))))
  (put 'make-polynomial-from-coefflist 'polynomial
       (lambda (v c) (tag (make-from-coefflist v c))))

  ;; apply-generic으로 호출된 make-dense-polynomial-from-sparse함수는
  ;; (polynomial) 태그는 없어졌지만 (sparse)태그는 없어지지 않았다.
  ;; 따라서 다시한번 apply-generic 으로 make-dense-from-sparse를
  ;; 호출하면 최종 패키지에서는 태그가 없고
  ;; 변수와 리스트만 있는 데이터가 전달된다.
  (put 'make-dense-polynomial-from-sparse '(polynomial)
       (lambda (x) (tag (make-dense-from-sparse x))))
  (put 'make-sparse-polynomial-from-dense '(polynomial)
       (lambda (x) (tag (make-sparse-from-dense x))))

  (put 'add '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))

  ;; no need to make another procedure for sub, but use add & negation
  (put 'sub '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 (negation p2)))))
  (put 'negation '(polynomial)
       (lambda (p) (tag (negation p))))

  ;; ex2.91
  (put 'div '(polynomial polynomial)
       (lambda (p1 p2) (tag (div-poly p1 p2))))

  (put 'greatest-common-divisor '(polynomial polynomial)
       (lambda (p1 p2) (tag (gcd-poly p1 p2))))

  'done)


(define (make-polynomial-from-termlist var termlist)
  ((get 'make-polynomial-from-termlist 'polynomial) var termlist))
(define (make-polynomial-from-coefflist var coefflist)
  ((get 'make-polynomial-from-coefflist 'polynomial) var coefflist))
(define (make-polynomial var termlist)
  ((get 'make-polynomial-from-termlist 'polynomial) var termlist))

(define (make-dense-polynomial-from-sparse sparselist)
  (apply-generic 'make-dense-polynomial-from-sparse sparselist))
(define (make-sparse-polynomial-from-dense denselist)
  (apply-generic 'make-sparse-polynomial-from-dense denselist))


                 
;;--------- test ----------------

;; MUST INSTALL!!
(install-scheme-number-package)
(install-rational-package)
(install-polar-package)
(install-rectangular-package)
(install-complex-package)
(install-sparse-polynomial-package)
(install-dense-polynomial-package)
(install-polynomial-package)



(define p1 (make-polynomial 'x '((2 1) (1 -2) (0 1))))
(define p2 (make-polynomial 'x '((2 11) (0 7))))
(define p3 (make-polynomial 'x '((1 13) (0 5))))

;; (polynomial sparse x (4 11) (3 -22) (2 18) (1 -14) (0 7))
;; (polynomial sparse x (3 13) (2 -21) (1 3) (0 5))
(define q1 (mul p1 p2))
(define q2 (mul p1 p3))

;;old result -> (polynomial sparse x (2 1458/169) (1 -2916/169) (0 1458/169))
;;factor = 13^2 = 169
;;new result -> (polynomial sparse x (2 1458) (1 -2916) (0 1458))
;; GCD of q1,q2 must be p1, so that the result should be redused by GCD of all coeffs.
;; final result -> (polynomial sparse x (2 1) (1 -2) (0 1)) == p1
(greatest-common-divisor q1 q2)


(div q1 (make-polynomial 'x '((2 1) (1 -2) (0 1))))
}}}


== 2.97.scm ==


{{{
;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;; (put <op> <type> <item>)
;; (get <op> <type>
;;------------------------------------------------


;;----- GENERIC PROCEDURES -----------------

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (ex-equ? x y) (apply-generic 'ex-equ? x y))
(define (ex-zero? x) (apply-generic 'ex-zero? x))
(define (exp x y) (apply-generic 'exp x y))
(define (real-part z)
  (apply-generic 'real-part z))
(define (imag-part z)
  (apply-generic 'imag-part z))
(define (magnitude z)
  (apply-generic 'magnitude z))
(define (angle z)
  (apply-generic 'angle z))
(define (add-3 a b c) (apply-generic 'add-3 a b c))

(define (negation x) (apply-generic 'negation x))

(define (greatest-common-divisor x y) (apply-generic 'greatest-common-divisor x y))

;;ex2.97
(define (reduce x y) (apply-generic 'reduce x y))


(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
        (error "Bad tagged datum -- TYPE-TAG" datum)))

(define (attach-tag type-tag contents)
  (cons type-tag contents))

(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (error "Bad tagged datum -- CONTENTS" datum)))

(define (raise x) (apply-generic 'raise x))

(define (project z)
  (apply-generic 'project z))

(define (install-get-higher-system)
  (put 'scheme-number 'rational 'rational)
  (put 'scheme-number 'complex 'complex)
  (put 'rational 'scheme-number 'rational)
  (put 'rational 'complex 'complex)
  (put 'complex 'scheme-number 'complex)
  (put 'complex 'rational 'complex))
(install-get-higher-system)       

(define (former-is-higher-system? type1 type2)
  (cond ((eq? type1 type2) #f)
        ((and (eq? type1 'rational) (eq? type2 'scheme-number)) #t)
        ((eq? type1 'complex) #t)
        (else #f)))

(define (drop x)
  (cond ((eq? (type-tag x) 'scheme-number) x)
        ((ex-equ? (raise (project x)) x) (drop (project x)))
        (else x)))


;; fail to make new apply-generic which is applied with drop procedure
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args))) ;; extract tags of each arguments
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args)) ;; extract data
          (error
           "No method for these types -- APPLY-GENERIC"
           (list op type-tags))))))


;;------ Number Systems ----------------------

;; normal number
;; eg) (add (make-scheme-number 3) (make-scheme-number 4))
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))

  (define (scheme-number->complex x)
    (make-complex-from-real-imag (cdr x) 0))
  (define (scheme-number->rational x)
    (make-rational x 1))


  ;; ex2.94
  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))

  ;; ex2.97
  (define (reduce-integers n d)
    (let ((g (gcd n d)))
      (list (/ n g) (/ d g))))

  (put 'reduce '(scheme-number scheme-number)
       (lambda (x y) (reduce-integers x y)))

  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (+ x y)))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (- x y)))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (* x y)))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (/ x y)))

  (put 'negation '(scheme-number)
       (lambda (x) (- x)))


  ;;
  ;; remove tag because it make number look dirty
  ;;

  ;; (put 'add '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (+ x y))))
  ;; (put 'sub '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (- x y))))
  ;; (put 'mul '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (* x y))))
  ;; (put 'div '(scheme-number scheme-number)
  ;;      (lambda (x y) (tag (/ x y))))
  ;; (put 'negation '(scheme-number)
  ;;     (lambda (x) (tag (- x))))


  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  (put 'ex-equ? '(scheme-number scheme-number)
       (lambda (x y) (= x y)))
  (put 'ex-zero? '(scheme-number)
       (lambda (x) (= x 0)))
  (put 'add-3 '(scheme-number scheme-number scheme-number)
       (lambda (a b c) (tag (+ a b c))))
  (put 'exp '(scheme-number scheme-number)
       (lambda (x y) (tag (expt x y))))

  (put 'raise '(scheme-number) scheme-number->rational)

  ;; ex2.94
  (put 'greatest-common-divisor '(scheme-number scheme-number)
       (lambda (a b) (tag (gcd a b))))

  'done)


(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))



;; real + imaginary number
;; 3 + 4i = (rectangular 3 . 4)
(define (square a) (* a a))
(define (install-rectangular-package)
  ;; internal procedures
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))

  'done)

;; mag + angle number
;; 3 + 45' = (polar 3 . 45)
(define (install-polar-package)
  ;; internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

;; complex number
(define (install-complex-package)
  ;; imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))

  ;; internal procedures

  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
                         (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))
  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))

  (define (add-complex-3 z1 z2 z3)
    (make-from-real-imag (+ (real-part z1) (real-part z2) (real-part z3))
                         (+ (imag-part z1) (imag-part z2) (imag-part z3))))

  (define (project-complex z)
    (make-rational (round (real-part z)) 1))

  (put 'add-3 '(complex complex complex)
       (lambda (z1 z2 z3) (tag (add-complex-3 z1 z2 z3))))

  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'ex-equ? '(complex complex)
       (lambda (z1 z2) (and (equal? (real-part z1) (real-part z2))
                            (equal? (imag-part z1) (imag-part z2)))))
  (put 'ex-zero? '(complex)
       (lambda (z1) (and (equal? (real-part z1) 0)
                         (equal? (imag-part z1) 0))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

  (put 'project '(complex) project-complex)

  (put 'negation '(complex)
       (lambda (z) (display "귀찮아서 안만듬")))

  'done)

;; complex 숫자들은 2개의 태그를 가진다.
;; make-comple-from-real-imag에서 'complex라는 태그를 추가해주고 
;; make-from-real-imag에서 'rectangular라는 태그를 추가해서
;; (complex rectangular 3 . 4) 와 같은 형태가 된다.
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)



;; rational number
;; eg) (add (make-rational 3 4) (make-rational 3 4))
(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))

  ;;
  ;; ------------ ex2.97 -------------------------
  ;; rational expression is changed into list, not cons
  ;; Therefore denom must call cadr, not cdr to get 2nd element in list.
  ;;
  (define (denom x) (cadr x))

  ;; ex2.93
  ;; (define (make-rat n d)
  ;;   (let (gcd (greatest-common-divisor n d))
  ;;     (cons (div n gcd) (div d gcd))))

  (define (make-rat n d)
    (reduce n d))

  ;; ex2.93
  (define (add-rat x y)
    (make-rat (add (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
              (mul (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (sub (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
              (mul (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (mul (numer x) (numer y))
              (mul (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (mul (numer x) (denom y))
              (mul (denom x) (numer y))))


  ;; should be fixed to handle polynomial
  (define (ex-equ? x y)
    (and (= (numer x) (numer y))
         (= (denom x) (denom y))))
  (define (ex-zero? x)
    (= (numer x) 0))

  (define (rational->complex x)
    (make-complex-from-real-imag (round (/ (numer x) (denom x))) 0))

  (define (tag x) (attach-tag 'rational x))

  (define (project-rational x) ; rational -> scheme-number
    (make-scheme-number (round (/ (numer x) (denom x)))))


  ;; interface to rest of the system
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'ex-equ? '(rational rational) ex-equ?)
  (put 'ex-zero? '(rational) ex-zero?)
  (put 'raise '(rational) rational->complex)
  (put 'project '(rational) project-rational)

  (put 'negation '(rational)
       (lambda (x) (tag (make-rat ( - (numer x))
                                  (denom x)))))

  'done)

(define (make-rational n d)
  ((get 'make 'rational) n d))



;; sparse polynomial : variable and list of (order coeff)
;; eg) ('x ((100 2) (2 4) (0 5)))
(define (install-sparse-polynomial-package)
  ;; from ch2.3.2
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))

  (define (make-poly variable term-list)
    (cons variable term-list))

  (define (variable p) (car p))
  (define (term-list p) (cdr p))

  (define (zero-termlist? terms)
    (cond ((empty-termlist? terms)
           #t)
          ((zero? (coeff (first-term terms)))
           (zero-termlist? (rest-terms terms)))
          (else
           #f)))

  (define (adjoin-term term term-list)
    (if (ex-zero? (coeff term))
        term-list
        (cons term term-list)))

  (define (the-empty-termlist) '())
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))

  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))

  ;; tag = sparse
  (define (tag p) (attach-tag 'sparse p))

  (define (make-dense-from-sparse sparse-termlist)
    (if (empty-termlist? sparse-termlist) '()
        (make-dense-from-sparse-body (order (first-term sparse-termlist))
                                     sparse-termlist
                                     '())))
  (define (make-dense-from-sparse-body current-order termlist newlist)
    (cond ((< current-order 0) newlist)
          ((empty-termlist? termlist)
           (make-dense-from-sparse-body
            (- current-order 1)
            termlist
            (append newlist (list 0))))
          ((= current-order (order (first-term termlist)))
           (make-dense-from-sparse-body
            (- current-order 1)
            (rest-terms termlist)
            (append newlist (list (coeff (first-term termlist))))))
          (else
           (make-dense-from-sparse-body
            (- current-order 1)
            termlist
            (append newlist (list 0))))))


  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1))
                 (t2 (first-term L2)))
             (cond ((> (order t1) (order t2))
                    (adjoin-term t1
                                 (add-terms (rest-terms L1) L2)))
                   ((< (order t1) (order t2))
                    (adjoin-term t2
                                 (add-terms L1 (rest-terms L2))))
                   (else
                    (adjoin-term
                     (make-term (order t1)
                                (add (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))
                     
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
             
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ((t2 (first-term L)))
          (adjoin-term
           (make-term (+ (order t1) (order t2)) ; order of term
                      (mul (coeff t1) (coeff t2))) ; coeff of term
           (mul-term-by-all-terms t1 (rest-terms L))))))

  (define (negation-termlist termlist)
    (if (empty-termlist? termlist) '()
        (adjoin-term 
         (make-term (order (first-term termlist))
                    ; use negation again that can handle any type of coeff
                    (negation (coeff (first-term termlist))))
         (negation-termlist (rest-terms termlist)))))


  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- ADD-POLY" (list p1 p2))))

  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (mul-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- MUL-POLY" (list p1 p2))))


  ;;-------- ex2.91 ------------
  (define (div-terms L1 L2)
    (if (empty-termlist? L1)
        (list (the-empty-termlist) (the-empty-termlist))
        (let ((t1 (first-term L1))
              (t2 (first-term L2)))
          (if (> (order t2) (order t1))
              (list (the-empty-termlist) L1)  ;; L1 is remainder
              (let ((new-c (div (coeff t1) (coeff t2)))
                    (new-o (- (order t1) (order t2))))
                (let ((rest-of-result
                       ;; get next dividee
                       (div-terms (add-terms L1 
                                             (negation-termlist (mul-term-by-all-terms (list new-o new-c) L2)))
                                  L2)
                       ))
                  ;; get result
                  (list (cons (list new-o new-c) (car rest-of-result)) (cadr rest-of-result))
                  ))))))

  (define (div-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (div-terms (term-list p1) (term-list p2)))
        (error "Polys not in same var -- DIV-POLY" (list p1 p2))))


  ;; ex2.94
  (define (remainder-terms p1 p2)
    (cadr (div-terms p1 p2)))

  ;; ex2.96
  (define (mul-terms-by-int terms val)
    (if (eq? terms '()) '()
        (cons (list (car (car terms)) (* val (cadr (car terms))))
              (mul-terms-by-int (cdr terms) val))))
  (define (div-terms-by-int terms val)
    (if (eq? terms '()) '()
        (cons (list (car (car terms)) (/ (cadr (car terms)) val))
              (div-terms-by-int (cdr terms) val))))
  (define (pseudoremainder-terms p1 p2)
    (let ((o1 (order (first-term p1)))
          (o2 (order (first-term p2)))
          (c (coeff (first-term p2))))
      (let ((factor (expt c (+ 1 (- o1 o2)))))
        (cadr (div-terms (mul-terms-by-int p1 factor) p2)))))

  (define (gcd-terms-body a b)
    (if (empty-termlist? b)
        a
        (gcd-terms-body b (pseudoremainder-terms a b))))

  (define (gcd-terms a b)
    (if (empty-termlist? b)
        a
        (let ((result (gcd-terms-body a b)))
          (let ((gcd-all-coeffs (apply gcd (map (lambda (x) (cadr x)) result))))
            (div-terms-by-int result gcd-all-coeffs)))))

  (define (gcd-poly a b)
    (if (same-variable? (variable a) (variable b))
        (make-poly (variable a) (gcd-terms (term-list a) (term-list b)))
        (error "Polys not in same var -- MUL-POLY" (list a b))))


  ;; ex2.97
  (define (reduce-terms n d)
    (let ((g (gcd-terms n d)))
      (list (car (div-terms n g)) (car (div-terms d g)))))

  (define (reduce-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (list (make-poly (variable p1)
                         (car (reduce-terms (term-list p1) (term-list p2))))
              (make-poly (variable p2)
                         (cadr (reduce-terms (term-list p1) (term-list p2)))))
        (error "Polys not in same var -- REDUCE-POLY" (list p1 p2))))

  (put 'reduce '(sparse sparse)
       (lambda (p1 p2) (list (tag (car (reduce-poly p1 p2)))
                             (tag (cadr (reduce-poly p1 p2))))))

  (put 'make 'sparse
       (lambda (var terms) (tag (make-poly var terms))))

  ;; term-list를 반드시 호출해야
  ;; 변수가 없어지고 각 term을 곧바로 처리할 수 있게 된다.
  (put 'ex-zero? '(sparse) 
       (lambda (terms) (zero-termlist? (term-list terms))))

  (put 'negation '(sparse)
       (lambda (termlist)
         (tag (make-poly (variable termlist)
                         (negation-termlist (term-list termlist))))))

  (put 'make-dense-from-sparse '(sparse) 
       (lambda (x)
         (attach-tag 'dense
                     (make-poly (variable x)
                                (make-dense-from-sparse (term-list x))))))


  ;; install operations
  (put 'add '(sparse sparse)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(sparse sparse)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))

  ;; ex2.91
  (put 'div '(sparse sparse)
       (lambda (p1 p2) (tag (div-poly p1 p2))))

  (put 'greatest-common-divisor '(sparse sparse)
       (lambda (p1 p2) (tag (gcd-poly p1 p2))))



  'done)

;; dense polynomial : variable and list of coeff (1 0 0 2 0 4)
;; eg) ('x (1 0 0 2 0 4))
(define (install-dense-polynomial-package)
  ;; from ch2.3.2
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  (define (make-poly variable coeff-list)
    (cons variable coeff-list))
  (define (variable p) (car p))
  (define (coeff-list p) (cdr p))
  (define (the-empty-termlist) '())
  (define (highest-coeff coeff-list)
    (car coeff-list)) ;; first-term -> highest-coeff
  (define (rest-coeffs coeff-list)
    (cdr coeff-list))   ;; rest-terms -> rest-coeffs
  (define (empty-coefflist? coeff-list)
    (null? coeff-list)) ;; empty-termlist? -> empty-coefflist?

  (define (zero-coefflist? coefflist)
    (cond ((empty-coefflist? coefflist)
           #t)
          ((zero? (highest-coeff coefflist)))
           (zero-coefflist? (rest-coeffs coefflist)))
          (else
           #f))

  (define (adjoin-coeff coeff coeff-list)
    (cons coeff coeff-list))

  (define (negation-coefflist coefflist)
    (if (empty-coefflist? coefflist) '()
        (adjoin-coeff (negation (highest-coeff coefflist))
                      (negation-coefflist (rest-coeffs coefflist)))))

  (define (tag p) (attach-tag 'dense p))

  ;; make-sparse-from-dense HERE!
  (define (make-sparse-from-dense coefflist)
    (if (empty-coefflist? coefflist) '()
        (make-sparse-from-dense-body (- (length coefflist) 1) coefflist)))

  (define (make-sparse-from-dense-body curr-order coefflist)
    (cond ((< curr-order 0) '())
          ((ex-zero? (highest-coeff coefflist))
           (make-sparse-from-dense-body (- curr-order 1)
                                        (rest-coeffs coefflist)))
          (else
           (cons (list curr-order (highest-coeff coefflist))
                 (make-sparse-from-dense-body (- curr-order 1)
                                              (rest-coeffs coefflist))))))

  ;; install operations
  (put 'make 'dense
       (lambda (var coeffs) (tag (make-poly var coeffs))))

  (put 'ex-zero? '(dense) 
       (lambda (coeffs) (zero-coefflist? (coeff-list coeffs))))

  (put 'negation '(dense)
       (lambda (coefflist)
         (tag (make-poly (variable coefflist)
                         (negation-coefflist (coeff-list coefflist))))))

  (put 'make-sparse-from-dense '(dense)
       (lambda (x)
         (attach-tag 'sparse
                     (make-poly (variable x)
                                (make-sparse-from-dense (coeff-list x))))))

  'done)



;; install generic procedure used for both of two types of polynomial
(define (install-polynomial-package)

  (define (tag p) (attach-tag 'polynomial p))
  (define (coeff-list p) (cdr p))
  (define (term-list p) (cdr p))

  ;; call procedure in each package
  (define (make-from-termlist v t)
    ((get 'make 'sparse) v t))
  (define (make-from-coefflist v c)
    ((get 'make 'dense) v c))

  (define (make-dense-from-sparse x)
    (apply-generic 'make-dense-from-sparse x))
  (define (make-sparse-from-dense x)
    (apply-generic 'make-sparse-from-dense x))

  (define (get-type p) (car p))

  (define (add-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (add p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (add p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (add (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (add (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC ADD for " p1 p2)))))

  (define (mul-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (mul p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (mul p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (mul (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (mul (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC MUL for " p1 p2)))))

  ;; ex2.91
  (define (div-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (div p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (div p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (div (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (div (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC DIV for " p1 p2)))))


  ;; ex2.94
  (define (gcd-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (greatest-common-divisor p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (greatest-common-divisor p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (greatest-common-divisor (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (greatest-common-divisor (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC GREATEST-COMMON-DIVISOR for " p1 p2)))))

  ;; ex2.97
  (define (reduce-poly p1 p2)
    (let ((type-p1 (get-type p1))
          (type-p2 (get-type p2)))
      (cond ((and (eq? type-p1 'sparse) (eq? type-p2 'sparse))
             (reduce p1 p2))
            ((and (eq? type-p1 'sparse) (eq? type-p2 'dense))
             (reduce p1 (make-sparse-from-dense p2)))
            ((and (eq? type-p1 'dense) (eq? type-p2 'sparse))
             (reduce (make-sparse-from-dense p1) p2))
            ((and (eq? type-p1 'dense) (eq? type-p2 'dense))
             (reduce (make-sparse-from-dense p1) (make-sparse-from-dense p2)))
            (else
             (error "NO GENERIC REDUCE for REDUCE" p1 p2)))))

  ;; ex2.97
  (put 'reduce '(polynomial polynomial)
       (lambda (p1 p2) (list (tag (car (reduce-poly p1 p2)))
                             (tag (cadr (reduce-poly p1 p2))))))


  (put 'make-polynomial-from-termlist 'polynomial
       (lambda (v t) (tag (make-from-termlist v t))))
  (put 'make-polynomial-from-coefflist 'polynomial
       (lambda (v c) (tag (make-from-coefflist v c))))

  ;; apply-generic으로 호출된 make-dense-polynomial-from-sparse함수는
  ;; (polynomial) 태그는 없어졌지만 (sparse)태그는 없어지지 않았다.
  ;; 따라서 다시한번 apply-generic 으로 make-dense-from-sparse를
  ;; 호출하면 최종 패키지에서는 태그가 없고
  ;; 변수와 리스트만 있는 데이터가 전달된다.
  (put 'make-dense-polynomial-from-sparse '(polynomial)
       (lambda (x) (tag (make-dense-from-sparse x))))
  (put 'make-sparse-polynomial-from-dense '(polynomial)
       (lambda (x) (tag (make-sparse-from-dense x))))

  (put 'add '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))

  ;; no need to make another procedure for sub, but use add & negation
  (put 'sub '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 (negation p2)))))
  (put 'negation '(polynomial)
       (lambda (p) (tag (negation p))))

  ;; ex2.91
  (put 'div '(polynomial polynomial)
       (lambda (p1 p2) (tag (div-poly p1 p2))))

  (put 'greatest-common-divisor '(polynomial polynomial)
       (lambda (p1 p2) (tag (gcd-poly p1 p2))))


  'done)


(define (make-polynomial-from-termlist var termlist)
  ((get 'make-polynomial-from-termlist 'polynomial) var termlist))
(define (make-polynomial-from-coefflist var coefflist)
  ((get 'make-polynomial-from-coefflist 'polynomial) var coefflist))
(define (make-polynomial var termlist)
  ((get 'make-polynomial-from-termlist 'polynomial) var termlist))

(define (make-dense-polynomial-from-sparse sparselist)
  (apply-generic 'make-dense-polynomial-from-sparse sparselist))
(define (make-sparse-polynomial-from-dense denselist)
  (apply-generic 'make-sparse-polynomial-from-dense denselist))


                 
;;--------- test ----------------

;; MUST INSTALL!!
(install-scheme-number-package)
(install-rational-package)
(install-polar-package)
(install-rectangular-package)
(install-complex-package)
(install-sparse-polynomial-package)
(install-dense-polynomial-package)
(install-polynomial-package)



(define p1 (make-polynomial 'x '((1 1)(0 1))))
(define p2 (make-polynomial 'x '((3 1)(0 -1))))
(define p3 (make-polynomial 'x '((1 1))))
(define p4 (make-polynomial 'x '((2 1)(0 -1))))



;; guile> rf1
;; (rational (polynomial sparse x (1 -1) (0 -1)) (polynomial sparse x (3 -1) (0 1)))
;; guile> rf2
;; (rational (polynomial sparse x (1 -1)) (polynomial sparse x (2 -1) (0 1)))
(define rf1 (make-rational p1 p2))
(define rf2 (make-rational p3 p4))

;;(rational (polynomial sparse x (3 -1) (2 -2) (1 -3) (0 -1)) (polynomial sparse x (4 -1) (3 -1) (1 1) (0 1)))
(add rf1 rf2)

;;(rational 5 4)
(add (make-rational 1 2) (make-rational 3 4))
}}}


