== 3.1.scm ==


{{{
(define (make-accumulator num)
  (lambda (addor)
    (begin (set! num (+ num addor))
           num)))

(define A (make-accumulator 5))
(A 10)
(A 10)
}}}


== 3.2.scm ==


{{{


(define (make-monitored proc)
  (let ((called-count 0))
    (define (mf m)
      (cond ((eq? m 'how-many-calls?) called-count)
            ((eq? m 'reset-count) (set! called-count 0))
            (else 
             (begin
               (set! called-count (+ 1 called-count))
               (proc m)))))
    mf))

(define s (make-monitored sqrt))

(s 100)
(s 'how-many-calls?)
(s 4)
(s 16)
(s 'reset-count)


;; let으로 만든 지역변수의 값이 계속 남아있는 이유는
;; (define ss ...)으로 다시한번 ss라는 객체로 정의되어서이다.
;; ss가 존재하는한 let으로 만든 지역변수도 계속 존재하게 된다.
;; 만약 객체로 정의하지 않고 한번만 실행되는 함수안에 있는 지역변수라면
;; 실행될때마다 변수가 생성되므로 계속 선언된 값만 가지게 된다.
(define (addnum proc)
  (let ((result 0))
    (define (mf n)
      (set! result (proc result n))
      result)
    mf))

(define (addnum2 proc)
  (let ((result 0))
    (define (mf n)
      (set! result (proc result n))
      (display "RESULT=") (display result) (newline))
    mf))

(define ss (addnum +))

(ss 1) ; ss객체는 계속 유지되므로 result 변수는 값이 바뀜?
(ss 2)
((addnum2 +) 1) ;; 실행될때마다 result변수가 생성되므로 계속 1이 됨
}}}


== 3.3.scm ==


{{{
(define (make-account passwd balance)
  (let ((count-pass-error 0))
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (call-the-cops)
      (error "FREEZE!!!"))
    (define (dispatch p m)
      (if (eq? passwd p) 
          (cond ((eq? m 'withdraw) withdraw)
                ((eq? m 'deposit) deposit)
                (else (error "Unknown request -- MAKE-ACOUNT" m)))
          (begin (set! count-pass-error (+ 1 count-pass-error))
                 (if (> count-pass-error 3)
                     (call-the-cops)
                     (error "Incorrect password" count-pass-error)))))
    dispatch))

(define acc (make-account 'pass 100))
((acc 'p 'deposit) 100)
((acc 'pass 'deposit) 100)
((acc 'pass 'withdraw) 40)
}}}


== 3.4.scm ==


{{{
(define (make-account passwd balance)
  (let ((count-pass-error 0))
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (call-the-cops)
      (error "FREEZE!!!"))
    (define (dispatch p m)
      (if (eq? passwd p) 
          (cond ((eq? m 'withdraw) withdraw)
                ((eq? m 'deposit) deposit)
                (else (error "Unknown request -- MAKE-ACOUNT" m)))
          (begin (set! count-pass-error (+ 1 count-pass-error))
                 (if (> count-pass-error 3)
                     (call-the-cops)
                     (error "Incorrect password" count-pass-error)))))
    dispatch))

(define acc (make-account 'pass 100))
((acc 'p 'deposit) 100)
((acc 'pass 'deposit) 100)
((acc 'pass 'withdraw) 40)
}}}


== 3.6.scm ==


{{{



;; 난수 수열을 만들기가 어려우므로
;; 1 2 4 8 16... 수열을 난수로 가정하고 처리한다.

(define random-init 1)

(define (rand-update seed)
  (* seed 2))
  
(define rand  ;; 함수가 아니라 객체다! 따라서 x값은 계속 유지된다.
  (let ((x random-init))
    (define (dispatch cmd)
      (cond ((eq? cmd 'generate)
             (begin (set! x (rand-update x))
                    x))
            ((eq? cmd 'reset)
             ;; 변수를 추가로 요청해서 새로 값을 시작함
             (lambda (new-val) (set! x new-val)))
            (else
             (error "Unknown command"))))
    dispatch))
            
(rand 'generate)
((rand 'reset) 3)
}}}


== 3.7.scm ==


{{{
(define (make-account passwd balance)
  (let ((count-pass-error 0))
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (call-the-cops)
      (error "FREEZE!!!"))
    (define (dispatch p m)
      (if (eq? passwd p) 
          (cond ((eq? m 'withdraw) withdraw)
                ((eq? m 'deposit) deposit)
                (else (error "Unknown request -- MAKE-ACOUNT" m)))
          (begin (set! count-pass-error (+ 1 count-pass-error))
                 (if (> count-pass-error 3)
                     (call-the-cops)
                     (error "Incorrect password" count-pass-error)))))
    dispatch))

(define (make-joint acc-name orig-pass new-pass)
  ;; check password with new-pass
  ;; if ok, original account is refered.
  (define (dispatch p m)
    (if (eq? new-pass p)
        (acc-name orig-pass m)
        (error "Incorrect password" p)))
  dispatch)


(define peter-acc (make-account 'open-sesame 100))
((peter-acc 'p 'deposit) 100)
((peter-acc 'open-sesame 'deposit) 100)
((peter-acc 'open-sesame 'withdraw) 40)

(define paul-acc (make-joint peter-acc 'open-sesame 'rosebud))

((paul-acc 'rosebud 'deposit) 100)
((paul-acc 'rosebud 'withdraw) 30)

((paul-acc 'open-sesame 'deposit) 200)
((peter-acc 'open-sesame 'deposit) 10)
}}}


== 3.8.scm ==


{{{


(define var -1)

(define (f num)
    (if (eq? var -1)
        (begin (set! var num)
               var)
        0))

(+ (f 0) (f 1)) ;; 0

;; right term first is the same with (+ (f 1) (f 0))
(+ (f 1) (f 0)) ;; 1
    


        
}}}


== 3.9.scm ==


{{{


;; recursive factorial
;; E1->n:6
;; E2->n:5
;; E3->n:4
;; E4->n:5
;; E5->n:6


;; iterative factorial
;; E1->n:6
;; E2->product:1,counter:1,max-count:6
;; E2->product:1,counter:2,max-count:6
;; E2->product:2,counter:3,max-count:6
;; E2->product:6,counter:4,max-count:6
;; E2->product:24,counter:5,max-count:6
;; E2->product:120,counter:6,max-count:6
;; E2->product:720,counter:7,max-count:6


}}}


== 3.10.scm ==


{{{


(define (make-withdraw initial-amount)
  (let ((balance initial-amount))
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))))

(define w1 (make-withdraw 100))
(w1 50)
(w1 40)

(define (make-withdraw initial-amount)
  ((lambda (balance)
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds")))
   initial-amount))

(define w2 (make-withdraw 100))
(w2 50)
(w2 40)

}}}


== 3.12.scm ==


{{{


(define (my-append! x y)
  (set-cdr! (my-last-pair x) y)
  x)

(define (my-last-pair x)
  (if (null? (cdr x))
      x
      (my-last-pair (cdr x))))

(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))

;; x: a->b-|
;; y: c->d-|
;; z: a->b->c->d-|
(cdr x)  ;; b-|


;; w: a->b->c->d-|
;; x: a->b->c->d-|
;; y: c->d-|
(define w (my-append! x y))
(cdr x)  ;; b->c->d-|
}}}


== 3.13.scm ==


{{{


(define (my-last-pair x)
  (if (null? (cdr x))
      x
      (my-last-pair (cdr x))))


(define (make-cycle x)
  (set-cdr! (my-last-pair x) x)
  x)

(define z (make-cycle (list 'a 'b 'c)))


;; calling built-in last-pair results error
;; standard input:123:1: In procedure last-pair in expression (last-pair z):
;; standard input:123:1: Circular structure in position 1: (a b c . #-2#)
;; ABORT: (misc-error)
(last-pair z)

;; custom last-pair do infinite-loop
(my-last-pair z)
}}}


== 3.14.scm ==


{{{


(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))

(define v '(a b c d))

(define w (mystery v))

;; result
;; guie> w
;; (d c b a)
;; guile> v
;; (a)


;; v: a->b->c->d
;; (loop (a b c d) ()) -> temp=(b c d), x=(a)---> this x is v!
;; (loop (b c d) (a)) -> temp=(c d), x=(b a)
;; (loop (c d) (b a)) -> temp=(d), x=(c b a)
;; (loop (d) (c b a)) -> temp=(), x=(d c b a)
;; (loop () (c d b a)) -> returns (c d b a)
}}}


== 3.15.scm ==


{{{


(define (set-to-wow! x)
  (set-car! (car x) 'wow)
  x)

(define x (list 'a 'b))
(define z1 (cons x x))
(define z2 (cons '(a b) '(a b)))

(set-to-wow! z1)
(set-to-wow! z2)
;; guile> ((wow b) wow b)
;; guile> ((wow b) a b)



    ;; z1.........
    ;;         . .
    ;;         . .
    ;;         . .
    ;;         . .
    ;;  x.................
    ;;         .         .
    ;;         .         .
    ;;         .         .
    ;;         wow       b



    ;;  z2......................
    ;;      .          .       .
    ;;      .          .       .
    ;;      .          .       .
    ;;      .          a       b
    ;;      .                  .
    ;;      .                  .
    ;;      .                  .
    ;;      ....................
    ;;                 .
    ;;                 .
    ;;                 .
    ;;                wow


}}}


== 3.16.scm ==


{{{


(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))

;;; test normal data

;; 3
(count-pairs '((a) b))
(count-pairs '(a b c))
(count-pairs '(((a))))
(count-pairs '((a b)))
(count-pairs '(a (b)))
(count-pairs '(() (a)))


;;; test shared data
(define z '(a))

;; 4
(count-pairs (cons z (cons z '())))

;; 7
(count-pairs (cons (cons z z) (cons z z)))

}}}


== 3.17.scm ==


{{{




;; 한번 읽은 쌍의 포인터를  리스트로 모아서
;; 중복된 포인터를 제거하고 나머지의 갯수를 센다.

(define pairs-list '())

(define (insert-pair target-list pair)
  (cond ((null? target-list) (set! pairs-list (cons pair pairs-list)))
        ((equal? (car target-list) pair) 
         #f)
        (else
         (insert-pair (cdr target-list) pair))))


(define (count-pairs x)
  (if (not (pair? x))
      0
      (begin (insert-pair pairs-list (car x)) ;; Which is correct, (car x) or x?
             (count-pairs (car x))
             (count-pairs (cdr x))
             (length pairs-list))))
      


;;; test shared data
(define z '(a))

;; pairs-list=(a (a)) , result=2
(define pairs-list '())
(count-pairs (cons z (cons z '())))

;; pairs-list=(a (a) ((a) a)), result=3
(define pairs-list '())
(count-pairs (cons (cons z z) (cons z z)))

;; pairs-list=(c b a), result=3
(define pairs-list '())
(count-pairs '(a b c))

;; all followings are 3
(count-pairs '((a) b))
(count-pairs '(a b c))
(count-pairs '(((a))))
(count-pairs '((a b)))
(count-pairs '(a (b)))
(count-pairs '(() (a)))
}}}


== 3.18.scm ==


{{{


(define (my-last-pair x)
  (if (null? (cdr x))
      x
      (my-last-pair (cdr x))))


(define (make-cycle x)
  (set-cdr! (my-last-pair x) x)
  x)

(define z (make-cycle '(a b c d e f g)))


(define (cycle? pair-list)
  (define (go-fast lst)
    (cdr (cdr lst)))
  (define (go-slow lst)
    (cdr lst))
  (define (travel-list fast slow)
;    (display fast) (display "--") (display slow) (newline)
    (cond ((equal? (car fast) (car slow))
           #t)
          ((or (null? (go-slow fast)) (null? (go-fast fast)))
           #f)
          (else
           (travel-list (go-fast fast) (go-slow slow)))))
  (travel-list (go-fast pair-list) (go-slow pair-list)))


}}}


== 3.19.scm ==


{{{


(define (my-last-pair x)
  (if (null? (cdr x))
      x
      (my-last-pair (cdr x))))


(define (make-cycle x)
  (set-cdr! (my-last-pair x) x)
  x)

(define z (make-cycle '(a b c d e f g)))


;; same with 3.18.scm, limited space
(define (cycle? pair-list)
  (define (go-fast lst)
    (cdr (cdr lst)))
  (define (go-slow lst)
    (cdr lst))
  (define (travel-list fast slow)
;    (display fast) (display "--") (display slow) (newline)
    (cond ((equal? (car fast) (car slow))
           #t)
          ((or (null? (go-slow fast)) (null? (go-fast fast)))
           #f)
          (else
           (travel-list (go-fast fast) (go-slow slow)))))
  (travel-list (go-fast pair-list) (go-slow pair-list)))


}}}


== 3.21.scm ==


{{{


(define (front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))

(define (set-front-ptr! queue item) (set-car! queue item))
(define (set-rear-ptr! queue item) (set-cdr! queue item))

(define (empty-queue? queue) (null? (front-ptr queue)))

(define (make-queue) (cons '() '()))

(define (front-queue queue)
  (if (empty-queue? queue)
      (error "FRONT called with an empty queue" queue)
      (car (front-ptr queue))))

(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (cond ((empty-queue? queue)
           (set-front-ptr! queue new-pair)
           (set-rear-ptr! queue new-pair)
           queue)
          (else
           (set-cdr! (rear-ptr queue) new-pair)
           (set-rear-ptr! queue new-pair)
           queue))))

(define (delete-queue! queue)
  (cond ((empty-queue? queue)
         (error "DELETE! called with an empty queue" queue))
        (else
         (set-front-ptr! queue (cdr (front-ptr queue)))
         queue)))


(define (print-queue queue)
  ;; The first element of queue is a list of elements included in queue
  (let ((temp-front (front-ptr queue)))
    (define (print-queue-body ptr)
      (if (not (null? ptr))
          (begin (display (car ptr)) (newline)
                 (print-queue-body (cdr ptr)))))
    (print-queue-body temp-front)))
  

(define q1 (make-queue))
(insert-queue! q1 'a)
(print-queue q1)

(insert-queue! q1 'b)
(print-queue q1)

(delete-queue! q1)
(print-queue q1)

(delete-queue! q1)
(print-queue q1)

(delete-queue! q1) ;;->error
(print-queue q1)
}}}


== 3.22.scm ==


{{{
;; (define (front-ptr queue) (car queue))
;; (define (rear-ptr queue) (cdr queue))
;; (define (set-front-ptr! queue item) (set-car! queue item))
;; (define (set-rear-ptr! queue item) (set-cdr! queue item))
;; (define (empty-queue? queue) (null? (front-ptr queue)))
;; (define (front-queue queue)
;;   (if (empty-queue? queue)
;;       (error "FRONT called with an empty queue" queue)
;;       (car (front-ptr queue))))
;; (define (insert-queue! queue item)
;;   (let ((new-pair (cons item '())))
;;     (cond ((empty-queue? queue)
;;            (set-front-ptr! queue new-pair)
;;            (set-rear-ptr! queue new-pair)
;;            queue)
;;           (else
;;            (set-cdr! (rear-ptr queue) new-pair)
;;            (set-rear-ptr! queue new-pair)
;;            queue))))
;; (define (delete-queue! queue)
;;   (cond ((empty-queue? queue)
;;          (error "DELETE! called with an empty queue" queue))
;;         (else
;;          (set-front-ptr! queue (cdr (front-ptr queue)))
;;          queue)))
;; (define (print-queue queue)
;;   ;; The first element of queue is a list of elements included in queue
;;   (let ((temp-front (front-ptr queue)))
;;     (define (print-queue-body ptr)
;;       (if (not (null? ptr))
;;           (begin (display (car ptr)) (newline)
;;                  (print-queue-body (cdr ptr)))))
;;     (print-queue-body temp-front)))


;; (define (make-queue) (cons '() '()))
(define (make-queue)
  (let ((front-ptr '())
        (rear-ptr '()))

    ;; How to porting old funtions
    ;; - delete argument queue
    ;; - change front-ptr,rear-ptr functions into local variables

    (define (set-front-ptr! item) (set! front-ptr item))
    (define (set-rear-ptr! item) (set! rear-ptr item))
    
    (define (empty-queue?)
      (null? front-ptr))
    (define (front-queue)
      (if (empty-queue?)
          (error "FRONT called with an empty queue")
          (car front-ptr)))

    (define (print-queue)
      ;; The first element of queue is a list of elements included in queue
      (let ((temp-front front-ptr))
        (define (print-queue-body ptr)
          (if (not (null? ptr))
              (begin (display (car ptr)) (newline)
                     (print-queue-body (cdr ptr)))))
        (print-queue-body temp-front)))

    (define (insert-queue! item)
      (let ((new-pair (cons item '())))
        (cond ((empty-queue?)
               (set-front-ptr! new-pair)
               (set-rear-ptr! new-pair))
              (else
               (set-cdr! rear-ptr new-pair)
               (set-rear-ptr! new-pair)))))
      
    (define (delete-queue!)
      (cond ((empty-queue?)
             (error "DELETE! called with an empty queue"))
            (else
             (set-front-ptr! (cdr front-ptr)))))

    (define (dispatch m)
      (cond ((eq? m 'empty-queue?)
             (empty-queue?))
            ((eq? m 'front-queue)
             (front-queue))
            ((eq? m 'insert)
             insert-queue!)
            ((eq? m 'print)
             (print-queue))
            ((eq? m 'delete)
             (delete-queue!))
            (else
             (error "Unidentified command" m))))
    dispatch))

(define (empty-queue? queue)
  (queue 'empty-queue?))
(define (front-queue queue)
  (queue 'front-queue))
(define (insert-queue! queue item)
  ((queue 'insert) item))
(define (delete-queue! queue)
  (queue 'delete))
(define (print-queue queue)
  (queue 'print))

(define q2 (make-queue))

(empty-queue? q2)
(insert-queue q2 'a)
(insert-queue q2 'b)
(insert-queue q2 'c)
(insert-queue q2 'd)

(print-queue q2)

(delete-queue! q2)
(print-queue q2)

(delete-queue! q2)
(print-queue q2)

(delete-queue! q2)
(print-queue q2)

(delete-queue! q2)
(print-queue q2)

(delete-queue! q2)
(print-queue q2)

(empty-queue? q2)


}}}


== 3.23.scm ==


{{{

;; the constructor make-deque, the predicate empty-deque?,
;; selectors front-deque and rear-deque, and
;; mutators front-insert-deque!, rear-insert-deque!, front-delete-deque!, and rear-delete-deque!.


;; internal procedures

;; pair -> (prev-pair (item next-pair))
(define (make-new-pair item) (cons '() (cons item '())))

(define (set-prev! new-pair prev-pair) (set-car! new-pair prev-pair))
(define (set-next! new-pair next-pair) (set-cdr! (cdr new-pair) next-pair))

(define (get-prev new-pair) (car new-pair))
(define (get-next new-pair) (cddr new-pair))
(define (get-item new-pair) (cadr new-pair))

(define (set-front-ptr! deque item) (set-car! deque item))
(define (set-rear-ptr! deque item) (set-cdr! deque item))


(define aa (make-new-pair 'a))
(define bb (make-new-pair 'b))
(define cc (make-new-pair 'c))


;; aa <-> bb
(set-next! aa bb)
(set-prev! bb aa)
;; bb <-> cc
(set-next! bb cc)
(set-prev! cc bb)
;; result
;; guile> aa
;; (() a #-2# b #-2# c)
;; guile> bb
;; ((() a . #-2#) b #-2# c)
;; guile> cc
;; (((() a . #-2#) b . #-2#) c)
;; guile> (cadr aa)
;; a
;; guile> (cadr bb)
;; b
;; guile> (cadr cc)
;; c
;; guile> (get-item (get-prev bb))
;; a
;; guile> (get-item (get-prev cc))
;; b
;; guile> (get-item (get-next aa))
;; b
;; guile> (get-item (get-next bb))
;; c


;; APIs

(define (make-deque) (cons '() '()))

(define (front-ptr deque) (car deque))
(define (rear-ptr deque) (cdr deque))

(define (empty-deque? deque) (null? (front-ptr deque)))

(define (front-deque deque)
  (if (empty-deque? deque)
      (error "FRONT called with an empty deque" deque)
      (cadr (front-ptr deque))))
(define (rear-deque deque)
  (if (empty-deque? deque)
      (error "REAR called with an empty deque" deque)
      (cdr (rear-ptr deque))))

(define (front-insert-deque! deque item)
  (let ((new-pair (make-new-pair item)))
    (cond ((empty-deque? deque)
           (set-front-ptr! deque new-pair)
           (set-rear-ptr! deque new-pair)
           deque)
          (else
           (set-prev! (front-ptr deque) new-pair)
           (set-next! new-pair (front-ptr deque))
           (set-front-ptr! deque new-pair)
           deque))))
        
(define (print-deque deque)
  ;; The first element of deque is a list of elements included in deque
  (let ((temp-front (front-ptr deque)))
    (define (print-deque-body ptr)
      (if (not (null? ptr))
          (begin (display (cadr ptr)) (newline)
                 (print-deque-body (cddr ptr)))))
    (print-deque-body temp-front)))
  

(define (rear-insert-deque! deque item)
  (let ((new-pair (make-new-pair item)))
    (cond ((empty-deque? deque)
           (set-front-ptr! deque new-pair)
           (set-rear-ptr! deque new-pair)
           deque)
          (else
           (set-next! (rear-ptr deque) new-pair)
           (set-prev! new-pair (rear-ptr deque))
           (set-rear-ptr! deque new-pair)
           deque))))

(define q1 (make-deque))
(front-insert-deque! q1 'c)
(front-insert-deque! q1 'b)
(front-insert-deque! q1 'a)

(rear-insert-deque! q1 'c)
(rear-insert-deque! q1 'b)
(rear-insert-deque! q1 'a)

(print-deque q1)

;; result
;; a
;; b
;; c
;; c
;; b
;; a


(define (front-delete-deque! deque)
  (cond ((empty-deque? deque)
         (error "DELETE! called with an empty deque" deque))
        (else
         (set-front-ptr! deque (get-next (front-ptr deque)))
         (if (null? (front-ptr deque))
             (set-rear-ptr! deque '()) ;; empty-deque
             (set-prev! (front-ptr deque) '())) ;; unlink old front item
         deque)))

(define (rear-delete-deque! deque)
  (cond ((empty-deque? deque)
         (error "DELETE! called with an empty deque" deque))
        (else
         (set-rear-ptr! deque (get-prev (rear-ptr deque)))
         ;; cannot use empty-deque. rear-ptr is null, but front-ptr is not null yet.
         (if (null? (rear-ptr deque))
             (set-front-ptr! deque '())
             (set-next! (rear-ptr deque) '()))
         deque)))


(define q1 (make-deque))
(front-insert-deque! q1 'c)
(front-delete-deque! q1)
(print-deque q1)

(front-insert-deque! q1 'c)
(front-insert-deque! q1 'b)
(front-insert-deque! q1 'a)
(front-delete-deque! q1)
(front-delete-deque! q1)
(front-delete-deque! q1)
(print-deque q1)
(front-delete-deque! q1) ;; error

(front-insert-deque! q1 'a)
(front-insert-deque! q1 'b)
(front-insert-deque! q1 'c)
(front-delete-deque! q1)
(front-delete-deque! q1)
(front-delete-deque! q1)
(print-deque q1)
(front-delete-deque! q1) ;; error

(define q1 (make-deque))
(front-insert-deque! q1 'c)
(rear-insert-deque! q1 'b)
(front-insert-deque! q1 'a)
(rear-insert-deque! q1 'd) ;; a-c-b-d
(rear-delete-deque! q1) ;; a-c-b
(rear-delete-deque! q1) ;; a-c
(front-delete-deque! q1) ;; c
(front-delete-deque! q1) ;; ()
(print-deque q1)
(empty-deque? q1)




}}}


== 3.24.scm ==


{{{

(define false #f)

(define (my-assoc key records check-equal?)
  (cond ((null? records) false)
        ((check-equal? key (caar records)) (car records)) ;; return pair of data
        (else (my-assoc key (cdr records) check-equal?))))


(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2 check-key?)
      (let ((subtable (my-assoc key-1 (cdr local-table) check-key?)))
        (if subtable
            (let ((record (my-assoc key-2 (cdr subtable) check-key?)))
              (if record
                  (cdr record)  ;; return only data
                  #f))
            #f)))
    (define (insert! key-1 key-2 value check-key?)
      (let ((subtable (my-assoc key-1 (cdr local-table) check-key?)))
        (if subtable
            (let ((record (my-assoc key-2 (cdr subtable) check-key?)))
              (if record
                  (set-cdr! record value)  ;; return found data
                  (set-cdr! subtable       ;; add new data into subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table  ;; make new subtable
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))

(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))

(define (same-key? a b)
  (<= (abs (- a b)) 1))

(put '1 '1 'one (lambda (a b) (= a b)))
(put '1 '4 'two (lambda (a b) (= a b)))
(put '1 '7 'three (lambda (a b) (= a b)))
(put '10 '10 'ten (lambda (a b) (= a b)))
(put '10 '14 'eleven (lambda (a b) (= a b)))
(put '10 '17 'twelve (lambda (a b) (= a b)))


;; #f
(get '1 '5 (lambda (a b) (= a b)))

;; get 'one
(get '1 '1 same-key?)
(get '1 '2 same-key?)
;; get 'two
(get '1 '3 same-key?)
(get '1 '4 same-key?)
(get '1 '5 same-key?)
;; get 'three
(get '1 '6 same-key?)
(get '1 '7 same-key?)
(get '1 '8 same-key?)

}}}


== 3.25.scm ==


{{{

;; original source
;; (define (make-table)
;;   (let ((local-table (list '*table*)))
;;     (define (lookup key-1 key-2)
;;       (let ((subtable (assoc key-1 (cdr local-table))))
;;         (if subtable
;;             (let ((record (assoc key-2 (cdr subtable))))
;;               (if record
;;                   (cdr record)
;;                   #f))
;;             #f)))
;;     (define (insert! key-1 key-2 value)
;;       (let ((subtable (assoc key-1 (cdr local-table))))
;;         (if subtable
;;             (let ((record (assoc key-2 (cdr subtable))))
;;               (if record
;;                   (set-cdr! record value)
;;                   (set-cdr! subtable
;;                             (cons (cons key-2 value)
;;                                   (cdr subtable)))))
;;             (set-cdr! local-table
;;                       (cons (list key-1
;;                                   (cons key-2 value))
;;                             (cdr local-table)))))
;;       'ok)
;;     (define (print) (display local-table) (newline))
;;     (define (dispatch m)
;;       (cond ((eq? m 'lookup-proc) lookup)
;;             ((eq? m 'insert-proc!) insert!)
;;             ((eq? m 'print-proc) print)
;;             (else (error "Unknown operation -- TABLE" m))))
;;     dispatch))
;; (define operation-table (make-table))
;; (define get (operation-table 'lookup-proc))
;; (define put (operation-table 'insert-proc!))
;; (define print (operation-table 'print-proc))
;; (put 'math '+ 48)
;; (put 'math '- 45)
;; (put 'math '* 42)
;; (put 'letters 'a 97)
;; (put 'letters 'b 98)
;; (put 'big 'A 67)


(define (make-table)
  (let ((local-table (list '*table*)))
    (define (insert! key-list value)
      (define (insert-body cur-table key-list value)
        (let ((subtable (assoc (car key-list) (cdr cur-table))))
          (if subtable
              (if (null? (cdr key-list)) ;; final key already exists -> key has already data -> change value
                  (set-cdr! subtable value)
                  (insert-body subtable (cdr key-list) value))
              (begin
                (set-cdr! cur-table
                          (cons (list (car key-list))
                                (cdr cur-table)))
                (if (null? (cdr key-list))
                    (set-cdr! (cadr cur-table) value)
                    (insert-body (cadr cur-table) (cdr key-list) value))))))
      (insert-body local-table key-list value))

    (define (lookup key-list)
      (define (lookup-body cur-table key-list)
        (let ((subtable (assoc (car key-list) (cdr cur-table))))
          (if subtable
              (if (null? (cdr key-list))
                  (cdr subtable)
                  (lookup-body subtable (cdr key-list)))
              #f)))
      (lookup-body local-table key-list))

    (define (print) (display local-table) (newline))
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            ((eq? m 'print-proc) print)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))

(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
(define print (operation-table 'print-proc))

(put '(letters alpha small a) 97)
(get '(letters alpha small a))

(put '(letters alpha small a) 95) ;; change key
(put '(letters alpha small a) 97)
(put '(letters alpha small b) 98)
(put '(letters alpha extra) 99)
(put '(letters alpha big A) 65)
(put '(letters alpha big B) 66)
(put '(letters alpha big C) 67)
(put '(letters num 0) 48)
(put '(letters num 1) 49)
(put '(letters num 2) 50)
(put '(math +) 43)
(put '(math -) 45)
(put '(math *) 42)
;; result
;; (*table* (math (* . 42) (- . 45) (+ . 43)) (letters (num (2 . 50) (1 . 49) (0 . 48)) (alpha (big (C . 67) (B . 66) (A . 65)) (extra . 99) (small (b . 98) (a . 97)))))


(get '(math +))
(get '(letters alpha big B))
(get '(letters alpha small b))
}}}


== 3.26.scm ==


{{{
;; original source
(define (make-table)
  (let ((local-table (list '*table*)))
    ;; basic operations of binary tree
    ;; node : (list key value left-branch right-branch)
    (define (get-key node) (car node))
    (define (get-value node) (cadr node))
    (define (left-branch node) (caddr node))
    (define (right-branch node) (cadddr node))
    (define (make-node key value left right)
      (list key value left right))

    (define (element-of-tree key tree)
      (cond ((null? tree) #f)
            ((= key (get-key tree)) (get-value tree))
            ((< key (get-key tree))
             (element-of-tree key (left-branch tree)))
            ((> key (get-key tree))
             (element-of-tree key (right-branch tree)))))

    (define (adjoin-tree key value tree)
      (cond ((null? tree) (make-node key value '() '()))
            ((= key (get-key tree))
             ;ignore same key;(set-cdr! tree (list value (left-branch tree) (right-branch tree))))
             tree)
            ((< key (get-key tree))
             (make-node (get-key tree)
                        (get-value tree)
                        (adjoin-tree key value (left-branch tree))
                        (right-branch tree)))
            ((> key (get-key tree))
             (make-node (get-key tree)
                        (get-value tree)
                        (left-branch tree)
                        (adjoin-tree key value (right-branch tree))))))

    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (element-of-tree key-2 (cadr subtable))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtree (assoc key-1 (cdr local-table))))
        (if subtree
            (set-cdr! subtree (list (adjoin-tree key-2 value (cadr subtree))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (make-node key-2 value '() '()))
                            (cdr local-table)))))
      'ok)
    (define (print) (display local-table) (newline))
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            ((eq? m 'print-proc) print)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))

(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
(define print (operation-table 'print-proc))

(put 'alpha 1 'a)
(put 'beta 1 'a)
(put 'alpha 9 'b)
(put 'alpha 5 'c)
(put 'alpha 2 'd)
(put 'alpha 4 'e)
(put 'alpha 6 'f)
(put 'alpha 3 'g)
(put 'alpha 7 'h)

(get 'alpha 1)
(get 'beta 1)
(get 'alpha 9)
(get 'alpha 5)
(get 'alpha 2)
(get 'alpha 4)
(get 'alpha 6)
(get 'alpha 3)
(get 'alpha 7)


}}}


== 3.27.scm ==


{{{
(define (lookup key table)
  (let ((record (assoc key (cdr table))))
    (if record
        (cdr record)
        #f)))
(define (assoc key records)
  (cond ((null? records) #f)
        ((equal? key (caar records)) (car records))
        (else (assoc key (cdr records)))))
(define (insert! key value table)
  (let ((record (assoc key (cdr table))))
    (if record
        (set-cdr! record value)
        (set-cdr! table
                  (cons (cons key value) (cdr table)))))
  'ok)
(define (make-table)
  (list '*table*))

(define (memorize f)
  (let ((table (make-table)))
    (lambda (x)
      (let ((previously-computed-result (lookup x table)))
        (or previously-computed-result
            (let ((result (f x)))
              (insert! x result table)
              (display "insert value") (display "-")
              (display x) (display ":") (display result)
              (newline)
              result))))))

(define memo-fib
  (memorize (lambda (n)
              (cond ((= n 0) 0)
                    ((= n 1) 1)
                    (else (+ (memo-fib (- n 1))
                             (memo-fib (- n 2))))))))

(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))


;; (memo-fib 10) stores result values of each steps of lambda
(memo-fib 10)
;; result of (memo-fib 10)
;; guile> insert value-1:1
;; insert value-0:0
;; insert value-2:1
;; insert value-3:2
;; insert value-4:3
;; insert value-5:5
;; insert value-6:8
;; insert value-7:13
;; insert value-8:21
;; insert value-9:34
;; insert value-10:55
;; 55


;; store final result value
((memorize fib) 10)
;; result of ((memorize fib) 10)
;; guile> insert value:55
}}}


== 3.28.scm ==


{{{


(define (logical-or s1 s2)
  (cond ((and (= s1 1) (= s2 1)) 1)
        ((and (= s1 1) (= s2 0)) 1)
        ((and (= s1 0) (= s2 1)) 1)
        ((and (= s1 0) (= s2 0)) 0)
        (else
         (error "Invalid signal" s1 s2))))

(define (or-gate a1 a2 output)
  (define (or-action-procedure)
    (let ((new-value (logical-or (get-signal a1) (get-signal a2))))
      (after-delay or-gate-delay
                   (lambda () (set-signal! output new-value)))))
  (add-action! a1 or-action-procedure)
  (add-action! a2 or-action-procedure)
  'ok)


      
}}}


== 3.29.scm ==


{{{


;;a+b = (a'*b')'
(define (or-gate a1 a2 output)
  (define (or-action-procedure)
    (let ((c1 (make-wire))
          (c2 (make-wire))
          (c3 (make-wire)))
      (inverter a1 c1)
      (inverter a2 c2)
      (and-gate c1 c2 c3)
      (inverter c3 output)))
  (add-action! a1 or-action-procedure)
  (add-action! a2 or-action-procedure)
  'ok)
}}}


== 3.30.scm ==


{{{
;========== queue ===================

(define (front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))

(define (set-front-ptr! queue item) (set-car! queue item))
(define (set-rear-ptr! queue item) (set-cdr! queue item))

(define (empty-queue? queue) (null? (front-ptr queue)))

(define (make-queue) (cons '() '()))

(define (front-queue queue)
  (if (empty-queue? queue)
      (error "FRONT called with an empty queue" queue)
      (car (front-ptr queue))))

(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (cond ((empty-queue? queue)
           (set-front-ptr! queue new-pair)
           (set-rear-ptr! queue new-pair)
           queue)
          (else
           (set-cdr! (rear-ptr queue) new-pair)
           (set-rear-ptr! queue new-pair)
           queue))))

(define (delete-queue! queue)
  (cond ((empty-queue? queue)
         (error "DELETE! called with an empty queue" queue))
        (else
         (set-front-ptr! queue (cdr (front-ptr queue)))
         queue)))


(define (print-queue queue)
  ;; The first element of queue is a list of elements included in queue
  (let ((temp-front (front-ptr queue)))
    (define (print-queue-body ptr)
      (if (not (null? ptr))
          (begin (display (car ptr)) (newline)
                 (print-queue-body (cdr ptr)))))
    (print-queue-body temp-front)))


;=========== line ===========

(define (call-each procedures)
  (if (null? procedures)
      'done
      (begin
        ((car procedures))
        (call-each (cdr procedures)))))

(define (make-wire)
  (let ((signal-value 0)
        (action-procedures '()))
    (define (set-my-signal! new-value)
      (if (not (= signal-value new-value))
          (begin (set! signal-value new-value)
                 (call-each action-procedures))
          'done))
    (define (accept-action-procedure! proc)
      (set! action-procedures (cons proc action-procedures))
      (proc))
    (define (dispatch m)
      (cond ((eq? m 'get-signal) signal-value)
            ((eq? m 'set-signal!) set-my-signal!)
            ((eq? m 'add-action!) accept-action-procedure!)
            (else (error "Unknown operation -- WIRE" m))))
    dispatch))

(define (get-signal wire)
  (wire 'get-signal))
(define (set-signal! wire new-value)
  ((wire 'set-signal!) new-value))
(define (add-action! wire action-procedures)
  ((wire 'add-action!) action-procedures))


;============ gates ===============

(define (and-gate a1 a2 output)
  (define (and-action-procedure)
    (let ((new-value
           (logical-and (get-signal a1) (get-signal a2))))
      (after-delay and-gate-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! a1 and-action-procedure)
  (add-action! a2 and-action-procedure)
  'ok)

(define (logical-and s1 s2)
  (cond ((and (= s1 1) (= s2 1)) 1)
        ((and (= s1 1) (= s2 0)) 0)
        ((and (= s1 0) (= s2 1)) 0)
        ((and (= s1 0) (= s2 0)) 0)
        (else
         (error "Invalid signal" s1 s2))))

(define (inverter input output)
  (define (invert-input)
    (let ((new-value (logical-not (get-signal input))))
      (after-delay inverter-delay
                   (lambda () (set-signal! output new-value)))))
  (add-action! input invert-input)
  'ok)

(define (logical-not s)
  (cond ((= s 0) 1)
        ((= s 1) 0)
        (else (error "Invalid signal" s))))

(define (logical-or s1 s2)
  (cond ((and (= s1 1) (= s2 1)) 1)
        ((and (= s1 1) (= s2 0)) 1)
        ((and (= s1 0) (= s2 1)) 1)
        ((and (= s1 0) (= s2 0)) 0)
        (else
         (error "Invalid signal" s1 s2))))

(define (or-gate a1 a2 output)
  (define (or-action-procedure)
    (let ((new-value (logical-or (get-signal a1) (get-signal a2))))
      (after-delay or-gate-delay
                   (lambda () (set-signal! output new-value)))))
  (add-action! a1 or-action-procedure)
  (add-action! a2 or-action-procedure)
  'ok)

;============= circuits ===============
      
(define (half-adder a b s c)
  (let ((d (make-wire))
        (e (make-wire)))
    (or-gate a b d)
    (and-gate a b c)
    (inverter c e)
    (and-gate d e s)
    'ok))

(define (full-adder a b c-in sum c-out)
  (let ((s (make-wire))
        (c1 (make-wire))
        (c2 (make-wire)))
    (half-adder b c-in s c1)
    (half-adder a s sum c2)
    (or-gate c1 c2 c-out)
    'ok))


;================== agenda ====================

(define (make-time-segment time queue)
  (cons time queue))

(define (segment-time s) (car s))

(define (segment-queue s) (cdr s))

(define (make-agenda) (list 0))

(define (current-time agenda) (car agenda))

(define (set-current-time! agenda time)
  (set-car! agenda time))

(define (segments agenda) (cdr agenda))

(define (set-segments! agenda segments)
  (set-cdr! agenda segments))

(define (first-segment agenda) (car (segments agenda)))

(define (rest-segments agenda) (cdr (segments agenda)))

(define (empty-agenda? agenda)
  (null? (segments agenda)))


(define (add-to-agenda! time action agenda)
  (define (belongs-before? segments)
    (or (null? segments)
        (< time (segment-time (car segments)))))
  (define (make-new-time-segment time action)
    (let ((q (make-queue)))
      (insert-queue! q action)
      (make-time-segment time q)))
  (define (add-to-segments! segments)
    (if (= (segment-time (car segments)) time)
        (insert-queue! (segment-queue (car segments))
                       action)
        (let ((rest (cdr segments)))
          (if (belongs-before? rest)
              (set-cdr! segments
                        (cons (make-new-time-segment time action)
                              (cdr segments)))
              (add-to-segments! rest)))))
  (let ((segments (segments agenda)))
    (if (belongs-before? segments)
        (set-segments! agenda
                       (cons (make-new-time-segment time action)
                             segments))
        (add-to-segments! segments))))

(define (remove-first-agenda-item! agenda)
  (let ((q (segment-queue (first-segment agenda))))
    (delete-queue! q)
    (if (empty-queue? q)
        (set-segments! agenda (rest-segments agenda)))))

(define (first-agenda-item agenda)
  (if (empty-agenda? agenda)
      (error "Agenda is empty -- FIRST-AGENDA-ITEM")
      (let ((first-seg (first-segment agenda)))
        (set-current-time! agenda (segment-time first-seg))
        (front-queue (segment-queue first-seg)))))

(define (after-delay delay action)
  (add-to-agenda! (+ delay (current-time the-agenda))
                  action
                  the-agenda))

(define (propagate)
  (if (empty-agenda? the-agenda)
      'done
      (let ((first-item (first-agenda-item the-agenda)))
        (first-item)
        (remove-first-agenda-item! the-agenda)
        (propagate))))

(define (probe name wire)
  (add-action! wire
               (lambda ()
                 (newline)
                 (display name)
                 (display " ")
                 (display (current-time the-agenda))
                 (display " New-value = ")
                 (display (get-signal wire)))))



;============ example =========================

(define the-agenda (make-agenda))
(define inverter-delay 2)
(define and-gate-delay 3)
(define or-gate-delay 5)


;;--------------------- 3.30 ----------------------------------
;; time delay = (length of bit list) * (delay of full-adder)
;;            = 3*or-gate-delay + 4*and-gate-delay + 2*inverter-delay
(define (ripple-carry-adder a-list b-list s-list final-c)
  (let ((c-init (make-wire)))
    (define (ripple-carry-adder-body alist blist slist c-in)
      (let ((c-out (make-wire)))
        (if (not (null? alist))
            (begin
              (full-adder (car alist) (car blist) c-in (car slist) c-out)
              (ripple-carry-adder-body (cdr alist) (cdr blist) (cdr slist) c-out))
            (set-signal! final-c (get-signal c-in)))))
    (ripple-carry-adder-body a-list b-list s-list c-init)))



(define inputa-0 (make-wire))
(define inputa-1 (make-wire))
(define inputa-2 (make-wire))

(define inputb-0 (make-wire))
(define inputb-1 (make-wire))
(define inputb-2 (make-wire))

(define sum0 (make-wire))
(define sum1 (make-wire))
(define sum2 (make-wire))

(define c (make-wire))


(ripple-carry-adder (list inputa-0 inputa-1 inputa-2)
                    (list inputb-0 inputb-1 inputb-2)
                    (list sum0 sum1 sum2)
                    c)

;; (define cout0 (make-wire))
;; (define cin0 (make-wire))
;; (full-adder inputa-0 inputb-0 cin0 sum0 cout0)
;; (define cout1 (make-wire))
;; (full-adder inputa-1 inputb-1 cout0 sum1 cout1)


;; test1: 001+000 = 001 - 0
(get-signal sum0)
(set-signal! inputa-0 1)
(propagate)
(get-signal sum0)
(get-signal sum1)
(get-signal sum2)
(get-signal c)

;; test2: 001+001 = 010 - 0
(set-signal! inputb-0 1)
(propagate)

(get-signal inputa-0)
(get-signal inputa-1)
(get-signal inputb-0)
(get-signal inputb-1)
(get-signal sum0)
(get-signal sum1)
(get-signal sum2)
(get-signal c)

;; test3: 101+001 = 110 - 0
(set-signal! inputa-2 1)
(propagate)
(get-signal sum0)
(get-signal sum1)
(get-signal sum2)
(get-signal c)


;;============== FAILURE : I cannot generate carry! c is now always 0. ================

;; test4: 101+101 = 010 - 1
(set-signal! inputb-2 1)
(propagate)
(get-signal sum0)
(get-signal sum1)
(get-signal sum2)
(get-signal c)

;; test4: 111+101 = 100 - 1
(set-signal! inputa-1 1)
(propagate)
(get-signal sum0)
(get-signal sum1)
(get-signal sum2)
(get-signal c)

}}}


== 3.31.scm ==


{{{
;========== queue ===================

(define (front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))

(define (set-front-ptr! queue item) (set-car! queue item))
(define (set-rear-ptr! queue item) (set-cdr! queue item))

(define (empty-queue? queue) (null? (front-ptr queue)))

(define (make-queue) (cons '() '()))

(define (front-queue queue)
  (if (empty-queue? queue)
      (error "FRONT called with an empty queue" queue)
      (car (front-ptr queue))))

(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (cond ((empty-queue? queue)
           (set-front-ptr! queue new-pair)
           (set-rear-ptr! queue new-pair)
           queue)
          (else
           (set-cdr! (rear-ptr queue) new-pair)
           (set-rear-ptr! queue new-pair)
           queue))))

(define (delete-queue! queue)
  (cond ((empty-queue? queue)
         (error "DELETE! called with an empty queue" queue))
        (else
         (set-front-ptr! queue (cdr (front-ptr queue)))
         queue)))


(define (print-queue queue)
  ;; The first element of queue is a list of elements included in queue
  (let ((temp-front (front-ptr queue)))
    (define (print-queue-body ptr)
      (if (not (null? ptr))
          (begin (display (car ptr)) (newline)
                 (print-queue-body (cdr ptr)))))
    (print-queue-body temp-front)))


;=========== line ===========

(define (call-each procedures)
  (if (null? procedures)
      'done
      (begin
        ((car procedures))
        (call-each (cdr procedures)))))

(define (make-wire)
  (let ((signal-value 0)
        (action-procedures '()))
    (define (set-my-signal! new-value)
      (if (not (= signal-value new-value))
          (begin (set! signal-value new-value)
                 (call-each action-procedures))
          'done))
    (define (accept-action-procedure! proc)
      (set! action-procedures (cons proc action-procedures))
      (display "run ") (display proc) (newline)
      (proc))
    (define (dispatch m)
      (cond ((eq? m 'get-signal) signal-value)
            ((eq? m 'set-signal!) set-my-signal!)
            ((eq? m 'add-action!) accept-action-procedure!)
            (else (error "Unknown operation -- WIRE" m))))
    dispatch))

(define (get-signal wire)
  (wire 'get-signal))
(define (set-signal! wire new-value)
  ((wire 'set-signal!) new-value))
(define (add-action! wire action-procedures)
  ((wire 'add-action!) action-procedures))


;============ gates ===============

(define (and-gate a1 a2 output)
  (define (and-action-procedure)
    (let ((new-value
           (logical-and (get-signal a1) (get-signal a2))))
      (after-delay and-gate-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! a1 and-action-procedure)
  (add-action! a2 and-action-procedure)
  'ok)

(define (logical-and s1 s2)
  (cond ((and (= s1 1) (= s2 1)) 1)
        ((and (= s1 1) (= s2 0)) 0)
        ((and (= s1 0) (= s2 1)) 0)
        ((and (= s1 0) (= s2 0)) 0)
        (else
         (error "Invalid signal" s1 s2))))

(define (inverter input output)
  (define (invert-input)
    (let ((new-value (logical-not (get-signal input))))
      (after-delay inverter-delay
                   (lambda () (set-signal! output new-value)))))
  (add-action! input invert-input)
  'ok)

(define (logical-not s)
  (cond ((= s 0) 1)
        ((= s 1) 0)
        (else (error "Invalid signal" s))))

(define (logical-or s1 s2)
  (cond ((and (= s1 1) (= s2 1)) 1)
        ((and (= s1 1) (= s2 0)) 1)
        ((and (= s1 0) (= s2 1)) 1)
        ((and (= s1 0) (= s2 0)) 0)
        (else
         (error "Invalid signal" s1 s2))))

(define (or-gate a1 a2 output)
  (define (or-action-procedure)
    (let ((new-value (logical-or (get-signal a1) (get-signal a2))))
      (after-delay or-gate-delay
                   (lambda () (set-signal! output new-value)))))
  (add-action! a1 or-action-procedure)
  (add-action! a2 or-action-procedure)
  'ok)

;============= circuits ===============
      
(define (half-adder a b s c)
  (let ((d (make-wire))
        (e (make-wire)))
    (or-gate a b d)
    (and-gate a b c)
    (inverter c e)
    (and-gate d e s)
    'ok))

(define (full-adder a b c-in sum c-out)
  (let ((s (make-wire))
        (c1 (make-wire))
        (c2 (make-wire)))
    (half-adder b c-in s c1)
    (half-adder a s sum c2)
    (or-gate c1 c2 c-out)
    'ok))


;================== agenda ====================

(define (make-time-segment time queue)
  (cons time queue))

(define (segment-time s) (car s))

(define (segment-queue s) (cdr s))

(define (make-agenda) (list 0))

(define (current-time agenda) (car agenda))

(define (set-current-time! agenda time)
  (set-car! agenda time))

(define (segments agenda) (cdr agenda))

(define (set-segments! agenda segments)
  (set-cdr! agenda segments))

(define (first-segment agenda) (car (segments agenda)))

(define (rest-segments agenda) (cdr (segments agenda)))

(define (empty-agenda? agenda)
  (null? (segments agenda)))


(define (add-to-agenda! time action agenda)
  (define (belongs-before? segments)
    (or (null? segments)
        (< time (segment-time (car segments)))))
  (define (make-new-time-segment time action)
    (let ((q (make-queue)))
      (insert-queue! q action)
      (make-time-segment time q)))
  (define (add-to-segments! segments)
    (if (= (segment-time (car segments)) time)
        (insert-queue! (segment-queue (car segments))
                       action)
        (let ((rest (cdr segments)))
          (if (belongs-before? rest)
              (set-cdr! segments
                        (cons (make-new-time-segment time action)
                              (cdr segments)))
              (add-to-segments! rest)))))
  (let ((segments (segments agenda)))
    (if (belongs-before? segments)
        (set-segments! agenda
                       (cons (make-new-time-segment time action)
                             segments))
        (add-to-segments! segments))))

(define (remove-first-agenda-item! agenda)
  (let ((q (segment-queue (first-segment agenda))))
    (delete-queue! q)
    (if (empty-queue? q)
        (set-segments! agenda (rest-segments agenda)))))

(define (first-agenda-item agenda)
  (if (empty-agenda? agenda)
      (error "Agenda is empty -- FIRST-AGENDA-ITEM")
      (let ((first-seg (first-segment agenda)))
        (set-current-time! agenda (segment-time first-seg))
        (front-queue (segment-queue first-seg)))))

(define (after-delay delay action)
  (add-to-agenda! (+ delay (current-time the-agenda))
                  action
                  the-agenda))

(define (propagate)
  (if (empty-agenda? the-agenda)
      'done
      (let ((first-item (first-agenda-item the-agenda)))
        (first-item)
        (remove-first-agenda-item! the-agenda)
        (propagate))))

(define (probe name wire)
  (add-action! wire
               (lambda ()
                 (newline)
                 (display name)
                 (display " ")
                 (display (current-time the-agenda))
                 (display " New-value = ")
                 (display (get-signal wire)))))



;============ example =========================

;; original make-wire
(define (make-wire)
  (let ((signal-value 0)
        (action-procedures '()))
    (define (set-my-signal! new-value)
      (if (not (= signal-value new-value))
          (begin (set! signal-value new-value)
                 (call-each action-procedures))
          'done))
    (define (accept-action-procedure! proc)
      (set! action-procedures (cons proc action-procedures))
      (display "run ") (display proc) (newline)
      (proc))
    ;; test wire
    (define (print)
      (display signal-value) (display "--") (display action-procedures) (newline))
    (define (dispatch m)
      (cond ((eq? m 'get-signal) signal-value)
            ((eq? m 'set-signal!) set-my-signal!)
            ((eq? m 'add-action!) accept-action-procedure!)
            ((eq? m 'print) print)
            (else (error "Unknown operation -- WIRE" m))))
    dispatch))

(define input-1 (make-wire))
(define input-2 (make-wire))
(define sum (make-wire))

;; 0 not-xor 0 = 1
(define (not-xor a b o)
  (let ((not-a (make-wire))
        (not-b (make-wire))
        (c (make-wire))
        (d (make-wire))
        (e (make-wire)))
    (inverter a not-a)
    (inverter b not-b)
    (and-gate not-a b c)
    (and-gate a not-b d)
    (or-gate c d e)
    (inverter e o)
    'ok))

(not-xor input-1 input-2 sum)

(get-signal sum)
((input-1 'print))
((input-2 'print))
((sum 'print))

(propagate) ;; many item in agenda. It can reflect the inital values of lines
(get-signal sum) ;; 1

(set-signal! input-1 1)
(get-signal sum) ;; 1 -> no change

(propagate)
(get-signal sum) ;; 0 -> change


;; no calling proc
(define (make-wire)
  (let ((signal-value 0)
        (action-procedures '()))
    (define (set-my-signal! new-value)
      (if (not (= signal-value new-value))
          (begin (set! signal-value new-value)
                 (call-each action-procedures))
          'done))
    (define (accept-action-procedure! proc)
      (set! action-procedures (cons proc action-procedures))
      (display "don't run proc"))
    (define (dispatch m)
      (cond ((eq? m 'get-signal) signal-value)
            ((eq? m 'set-signal!) set-my-signal!)
            ((eq? m 'add-action!) accept-action-procedure!)
            (else (error "Unknown operation -- WIRE" m))))
    dispatch))

(define input-1 (make-wire))
(define input-2 (make-wire))
(define sum (make-wire))


(not-xor input-1 input-2 sum)

(get-signal sum)

(propagate) ;; many item in agenda. It can reflect the inital values of input lines
(get-signal sum) ;; 0 -> should be 1, cannot reflect the initial values of input lines

(set-signal! input-1 1)
(get-signal sum) ;; 0

(propagate)
(get-signal sum) ;; 0


;; 각 라인이 갖는 초기값이 있고, 이 값에 따라 출력의 초기값이 있다.
;; 출력의 초기값을 설정하려면 accept-action-procedure!에서 라인이 가지는 프로시저를 먼저 한번 호출해야한다.
}}}


== 3.32.scm ==


{{{
;========== queue ===================

(define (front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))

(define (set-front-ptr! queue item) (set-car! queue item))
(define (set-rear-ptr! queue item) (set-cdr! queue item))

(define (empty-queue? queue) (null? (front-ptr queue)))

(define (make-queue) (cons '() '()))

(define (front-queue queue)
  (if (empty-queue? queue)
      (error "FRONT called with an empty queue" queue)
      (car (front-ptr queue))))

(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (cond ((empty-queue? queue)
           (set-front-ptr! queue new-pair)
           (set-rear-ptr! queue new-pair)
           queue)
          (else
           (set-cdr! (rear-ptr queue) new-pair)
           (set-rear-ptr! queue new-pair)
           queue))))

(define (delete-queue! queue)
  (cond ((empty-queue? queue)
         (error "DELETE! called with an empty queue" queue))
        (else
         (set-front-ptr! queue (cdr (front-ptr queue)))
         queue)))


(define (print-queue queue)
  ;; The first element of queue is a list of elements included in queue
  (let ((temp-front (front-ptr queue)))
    (define (print-queue-body ptr)
      (if (not (null? ptr))
          (begin (display (car ptr)) (newline)
                 (print-queue-body (cdr ptr)))))
    (print-queue-body temp-front)))


;=========== line ===========

(define (call-each procedures)
  (if (null? procedures)
      'done
      (begin
        ((car procedures))
        (call-each (cdr procedures)))))

(define (make-wire)
  (let ((signal-value 0)
        (action-procedures '()))
    (define (set-my-signal! new-value)
      (if (not (= signal-value new-value))
          (begin (set! signal-value new-value)
                 (call-each action-procedures))
          'done))
    (define (accept-action-procedure! proc)
      (set! action-procedures (cons proc action-procedures))
      (proc))
    (define (dispatch m)
      (cond ((eq? m 'get-signal) signal-value)
            ((eq? m 'set-signal!) set-my-signal!)
            ((eq? m 'add-action!) accept-action-procedure!)
            (else (error "Unknown operation -- WIRE" m))))
    dispatch))

(define (get-signal wire)
  (wire 'get-signal))
(define (set-signal! wire new-value)
  ((wire 'set-signal!) new-value))
(define (add-action! wire action-procedures)
  ((wire 'add-action!) action-procedures))


;============ gates ===============

(define (and-gate a1 a2 output)
  (define (and-action-procedure)
    (let ((new-value
           (logical-and (get-signal a1) (get-signal a2))))
      (after-delay and-gate-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! a1 and-action-procedure)
  (add-action! a2 and-action-procedure)
  'ok)

(define (logical-and s1 s2)
  (cond ((and (= s1 1) (= s2 1)) 1)
        ((and (= s1 1) (= s2 0)) 0)
        ((and (= s1 0) (= s2 1)) 0)
        ((and (= s1 0) (= s2 0)) 0)
        (else
         (error "Invalid signal" s1 s2))))

(define (inverter input output)
  (define (invert-input)
    (let ((new-value (logical-not (get-signal input))))
      (after-delay inverter-delay
                   (lambda () (set-signal! output new-value)))))
  (add-action! input invert-input)
  'ok)

(define (logical-not s)
  (cond ((= s 0) 1)
        ((= s 1) 0)
        (else (error "Invalid signal" s))))

(define (logical-or s1 s2)
  (cond ((and (= s1 1) (= s2 1)) 1)
        ((and (= s1 1) (= s2 0)) 1)
        ((and (= s1 0) (= s2 1)) 1)
        ((and (= s1 0) (= s2 0)) 0)
        (else
         (error "Invalid signal" s1 s2))))

(define (or-gate a1 a2 output)
  (define (or-action-procedure)
    (let ((new-value (logical-or (get-signal a1) (get-signal a2))))
      (after-delay or-gate-delay
                   (lambda () (set-signal! output new-value)))))
  (add-action! a1 or-action-procedure)
  (add-action! a2 or-action-procedure)
  'ok)

;============= circuits ===============
      
(define (half-adder a b s c)
  (let ((d (make-wire))
        (e (make-wire)))
    (or-gate a b d)
    (and-gate a b c)
    (inverter c e)
    (and-gate d e s)
    'ok))

(define (full-adder a b c-in sum c-out)
  (let ((s (make-wire))
        (c1 (make-wire))
        (c2 (make-wire)))
    (half-adder b c-in s c1)
    (half-adder a s sum c2)
    (or-gate c1 c2 c-out)
    'ok))


;================== agenda ====================

(define (make-time-segment time queue)
  (cons time queue))

(define (segment-time s) (car s))

(define (segment-queue s) (cdr s))

(define (make-agenda) (list 0))

(define (current-time agenda) (car agenda))

(define (set-current-time! agenda time)
  (set-car! agenda time))

(define (segments agenda) (cdr agenda))

(define (set-segments! agenda segments)
  (set-cdr! agenda segments))

(define (first-segment agenda) (car (segments agenda)))

(define (rest-segments agenda) (cdr (segments agenda)))

(define (empty-agenda? agenda)
  (null? (segments agenda)))


(define (add-to-agenda! time action agenda)
  (define (belongs-before? segments)
    (or (null? segments)
        (< time (segment-time (car segments)))))
  (define (make-new-time-segment time action)
    ;(let ((q (make-queue)))
    (let ((q '()))
      ;(insert-queue! q action)
      (cons action q)
      (make-time-segment time q)))
  (define (add-to-segments! segments)
    (if (= (segment-time (car segments)) time)
        ;(insert-queue! (segment-queue (car segments)) action)
        (cons action (segment-queue (car segments)))
        (let ((rest (cdr segments)))
          (if (belongs-before? rest)
              (set-cdr! segments
                        (cons (make-new-time-segment time action)
                              (cdr segments)))
              (add-to-segments! rest)))))
  (let ((segments (segments agenda)))
    (if (belongs-before? segments)
        (set-segments! agenda
                       (cons (make-new-time-segment time action)
                             segments))
        (add-to-segments! segments))))

(define (remove-first-agenda-item! agenda)
  (let ((q (segment-queue (first-segment agenda))))
;    (delete-queue! q)
    (set! q (cdr q))
;    (if (empty-queue? q)
    (if (null? q)
        (set-segments! agenda (rest-segments agenda)))))

(define (first-agenda-item agenda)
  (if (empty-agenda? agenda)
      (error "Agenda is empty -- FIRST-AGENDA-ITEM")
      (let ((first-seg (first-segment agenda)))
        (set-current-time! agenda (segment-time first-seg))
;        (front-queue (segment-queue first-seg)))))
        (display "item:") (display (car (segment-queue first-seg))) (newline)
        (car (segment-queue first-seg)))))

(define (after-delay delay action)
  (add-to-agenda! (+ delay (current-time the-agenda))
                  action
                  the-agenda))

(define (propagate)
  (if (empty-agenda? the-agenda)
      'done
      (let ((first-item (first-agenda-item the-agenda)))
        (first-item)
        (remove-first-agenda-item! the-agenda)
        (propagate))))

(define (probe name wire)
  (add-action! wire
               (lambda ()
                 (newline)
                 (display name)
                 (display " ")
                 (display (current-time the-agenda))
                 (display " New-value = ")
                 (display (get-signal wire)))))



;============ example =========================

(define the-agenda (make-agenda))
(define inverter-delay 2)
(define and-gate-delay 3)
(define or-gate-delay 5)


;;--------------------- 3.30 ----------------------------------
;; time delay = (length of bit list) * (delay of full-adder)
;;            = 3*or-gate-delay + 4*and-gate-delay + 2*inverter-delay
(define (ripple-carry-adder a-list b-list s-list final-c)
  (let ((c-init (make-wire)))
    (define (ripple-carry-adder-body alist blist slist c-in)
      (let ((c-out (make-wire)))
        (if (not (null? alist))
            (begin
              (full-adder (car alist) (car blist) c-in (car slist) c-out)
              (ripple-carry-adder-body (cdr alist) (cdr blist) (cdr slist) c-out))
            (set-signal! final-c (get-signal c-in)))))
    (ripple-carry-adder-body a-list b-list s-list c-init)))



(define inputa-0 (make-wire))
(define inputa-1 (make-wire))
(define inputa-2 (make-wire))

(define inputb-0 (make-wire))
(define inputb-1 (make-wire))
(define inputb-2 (make-wire))

(define sum0 (make-wire))
(define sum1 (make-wire))
(define sum2 (make-wire))

(define c (make-wire))



;;======================================================
;; not working!!!!!!
;;======================================================
(ripple-carry-adder (list inputa-0 inputa-1 inputa-2)
                    (list inputb-0 inputb-1 inputb-2)
                    (list sum0 sum1 sum2)
                    c)

;; (define cout0 (make-wire))
;; (define cin0 (make-wire))
;; (full-adder inputa-0 inputb-0 cin0 sum0 cout0)
;; (define cout1 (make-wire))
;; (full-adder inputa-1 inputb-1 cout0 sum1 cout1)


;; test1: 001+000 = 001 - 0
(get-signal sum0)
(set-signal! inputa-0 1)
(propagate)
(get-signal sum0)
(get-signal sum1)
(get-signal sum2)
(get-signal c)

;; test2: 001+001 = 010 - 0
(set-signal! inputb-0 1)
(propagate)

(get-signal inputa-0)
(get-signal inputa-1)
(get-signal inputb-0)
(get-signal inputb-1)
(get-signal sum0)
(get-signal sum1)
(get-signal sum2)
(get-signal c)

;; test3: 101+001 = 110 - 0
(set-signal! inputa-2 1)
(propagate)
(get-signal sum0)
(get-signal sum1)
(get-signal sum2)
(get-signal c)


;;============== FAILURE : I cannot generate carry! c is now always 0. ================

;; test4: 101+101 = 010 - 1
(set-signal! inputb-2 1)
(propagate)
(get-signal sum0)
(get-signal sum1)
(get-signal sum2)
(get-signal c)

;; test4: 111+101 = 100 - 1
(set-signal! inputa-1 1)
(propagate)
(get-signal sum0)
(get-signal sum1)
(get-signal sum2)
(get-signal c)

(define (pa) (display "aaa"))
(define (pb) (display "bbb"))
(define aaa (list pa pb))


}}}


== 3.33.scm ==


{{{


;; (define C (make-connector))
;; (define F (make-connector))
;; (celsius-fahrenheit-converter C F)

;; (define (celsius-fahrenheit-converter c f)
;;   (let ((u (make-connector))
;;         (v (make-connector))
;;         (w (make-connector))
;;         (x (make-connector))
;;         (y (make-connector)))
;;     (multiplier c w u)
;;     (multiplier v x u)
;;     (adder v y f)
;;     (constant 9 w)
;;     (constant 5 x)
;;     (constant 32 y)
;;     'ok))

;; (probe "Celsius temp" C)
;; (probe "Fahrenheit temp" F)

;; (set-value! C 25 'user)
;; (set-value! F 212 'user)
;; (forget-value! C 'user)
;; (set-value! F 212 'user)


(define a (make-connector))
(define b (make-connector))
(define c (make-connector))

(define (averager a b c)
  (let ((sum (make-connector))
        (di (make-connector)))
    (adder a b sum)
    (multiplier sum di c)
    (constant 0.5 di)
    'ok))

(probe "Average" c)
(probe "Num1" a)
(probe "Num2" b)

(averager a b c)

;;test1
(set-value! a 25 'user)
(set-value! b 15 'user)
(get-value c)

;;test2
(set-value! a 15 'user)
(forget-value! a 'user)
(set-value! a 15 'user)

;;test3
(forget-value! a 'user)
(forget-value! c 'user)
(set-value! c 20 'user)

;===== system ======

;; (has-value? <connector>)
;; tells whether the connector has a value.
;; (get-value <connector>)
;; returns the connector's current value.
;; (set-value! <connector> <new-value> <informant>)
;; indicates that the informant is requesting the connector to set its value to the new value.
;; (forget-value! <connector> <retractor>)
;; tells the connector that the retractor is requesting it to forget its value.
;; (connect <connector> <new-constraint>)
;; tells the connector to participate in the new constraint.


(define (adder a1 a2 sum)
  (define (process-new-value)
    (cond ((and (has-value? a1) (has-value? a2))
           (display "1")
           (set-value! sum
                       (+ (get-value a1) (get-value a2))
                       me))
          ((and (has-value? a1) (has-value? sum))
           (display "2")
           (set-value! a2
                       (- (get-value sum) (get-value a1))
                       me))
          ((and (has-value? a2) (has-value? sum))
           (display "3")
           (set-value! a1
                       (- (get-value sum) (get-value a2))
                       me))
          (else
           (display "4"))))
  (define (process-forget-value)
    (forget-value! sum me)
    (forget-value! a1 me)
    (forget-value! a2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)  
           (process-new-value))
          ((eq? request 'I-lost-my-value) 
           (process-forget-value))
          (else 
           (error "Unknown request -- ADDER" request))))
  (connect a1 me 'adder)
  (connect a2 me 'adder)
  (connect sum me 'adder)
  me)

(define (inform-about-value constraint)
  (constraint 'I-have-a-value))
(define (inform-about-no-value constraint)
  (constraint 'I-lost-my-value))


(define (multiplier m1 m2 product)
  (define (process-new-value)
    (cond ((or (and (has-value? m1) (= (get-value m1) 0))
               (and (has-value? m2) (= (get-value m2) 0)))
           (set-value! product 0 me))
          ((and (has-value? m1) (has-value? m2))
           (set-value! product
                       (* (get-value m1) (get-value m2))
                       me))
          ((and (has-value? product) (has-value? m1))
           (set-value! m2
                       (/ (get-value product) (get-value m1))
                       me))
          ((and (has-value? product) (has-value? m2))
           (set-value! m1
                       (/ (get-value product) (get-value m2))
                       me))))
  (define (process-forget-value)
    (forget-value! product me)
    (forget-value! m1 me)
    (forget-value! m2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else
           (error "Unknown request -- MULTIPLIER" request))))
  (connect m1 me 'multi)
  (connect m2 me 'multi)
  (connect product me 'multi)
  me)


(define (constant value connector)
  (define (me request)
    (error "Unknown request -- CONSTANT" request))
  (connect connector me 'constant)
  (set-value! connector value me)
  me)


(define (probe name connector)
  (define (print-probe value)
    (newline)
    (display "Probe: ")
    (display name)
    (display " = ")
    (display value))
  (define (process-new-value)
    (print-probe (get-value connector)))
  (define (process-forget-value)
    (print-probe "?"))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else
           (error "Unknown request -- PROBE" request))))
  (connect connector me 'probe)
  me)




(define (make-connector)
  (let ((value #f) (informant #f) (constraints '()) (const-names '()))
    (define (set-my-value newval setter)
      (cond ((not (has-value? me))
             (set! value newval)
             (set! informant setter)
             (for-each-except setter
                              inform-about-value
                              constraints))
            ((not (= value newval))
             (error "Contradiction" (list value newval)))
            (else 'ignored)))
    (define (forget-my-value retractor)
      (if (eq? retractor informant)
          (begin (set! informant #f)
                 (for-each-except retractor
                                  inform-about-no-value
                                  constraints))
          'ignored))
    (define (connect new-constraint new-name)
      (if (not (memq new-constraint constraints))
          (set! constraints 
                (cons new-constraint constraints)))
      (if (has-value? me)
          (inform-about-value new-constraint))

      (if (not (memq new-name const-names))
          (set! const-names
                (cons new-name const-names)))
      'done)

    (define (print-const names)
      (if (null? names) 'done
          (begin
            (display "CONSTRAINTS:")
            (display (car names))
            (newline)
            (print-const (cdr names)))))

    (define (me request)
      (cond ((eq? request 'has-value?)
             (if informant #t #f))
            ((eq? request 'value) value)
            ((eq? request 'set-value!) set-my-value)
            ((eq? request 'forget) forget-my-value)
            ((eq? request 'connect) connect)
            ((eq? request 'print) (print-const const-names))
            (else (error "Unknown operation -- CONNECTOR"
                         request))))
    me))



(define (for-each-except exception procedure list)
  (define (loop items)
    (cond ((null? items) 'done)
          ((eq? (car items) exception) (loop (cdr items)))
          (else (procedure (car items))
                (loop (cdr items)))))
  (loop list))



(define (has-value? connector)
  (connector 'has-value?))
(define (get-value connector)
  (connector 'value))
(define (set-value! connector new-value informant)
  ((connector 'set-value!) new-value informant))
(define (forget-value! connector retractor)
  ((connector 'forget) retractor))
(define (connect connector new-constraint new-name)
  ((connector 'connect) new-constraint new-name))

}}}


== 3.34.scm ==


{{{


(define a (make-connector))
(define b (make-connector))

(define (squarer a b)
  (multiplier a a b))

(squarer a b)

(set-value! a 3 'user)
(get-value b)
(get-value a)

(forget-value! a 'user)
(get-value a)
(get-value b)

(set-value! b 4 'user) 
(get-value a) ;; a is not changed
(get-value b)

;; a값을 지우면 multiplier의 process-new-value에서
;; 모든 조건문이 거짓이므로, b값이 바뀌더라도 a값이 바뀌지 않는다.
;; 반대로 a값을 바꾸면, 조건문이 성립되므로 b값은 바뀐다.


;===== system ======

;; (has-value? <connector>)
;; tells whether the connector has a value.
;; (get-value <connector>)
;; returns the connector's current value.
;; (set-value! <connector> <new-value> <informant>)
;; indicates that the informant is requesting the connector to set its value to the new value.
;; (forget-value! <connector> <retractor>)
;; tells the connector that the retractor is requesting it to forget its value.
;; (connect <connector> <new-constraint>)
;; tells the connector to participate in the new constraint.


(define (adder a1 a2 sum)
  (define (process-new-value)
    (cond ((and (has-value? a1) (has-value? a2))
           (display "1")
           (set-value! sum
                       (+ (get-value a1) (get-value a2))
                       me))
          ((and (has-value? a1) (has-value? sum))
           (display "2")
           (set-value! a2
                       (- (get-value sum) (get-value a1))
                       me))
          ((and (has-value? a2) (has-value? sum))
           (display "3")
           (set-value! a1
                       (- (get-value sum) (get-value a2))
                       me))
          (else
           (display "4"))))
  (define (process-forget-value)
    (forget-value! sum me)
    (forget-value! a1 me)
    (forget-value! a2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)  
           (process-new-value))
          ((eq? request 'I-lost-my-value) 
           (process-forget-value))
          (else 
           (error "Unknown request -- ADDER" request))))
  (connect a1 me 'adder)
  (connect a2 me 'adder)
  (connect sum me 'adder)
  me)

(define (inform-about-value constraint)
  (constraint 'I-have-a-value))
(define (inform-about-no-value constraint)
  (constraint 'I-lost-my-value))


(define (multiplier m1 m2 product)
  (define (process-new-value)
    (cond ((or (and (has-value? m1) (= (get-value m1) 0))
               (and (has-value? m2) (= (get-value m2) 0)))
           (set-value! product 0 me))
          ((and (has-value? m1) (has-value? m2))
           (set-value! product
                       (* (get-value m1) (get-value m2))
                       me))
          ((and (has-value? product) (has-value? m1))
           (set-value! m2
                       (/ (get-value product) (get-value m1))
                       me))
          ((and (has-value? product) (has-value? m2))
           (set-value! m1
                       (/ (get-value product) (get-value m2))
                       me))))
  (define (process-forget-value)
    (forget-value! product me)
    (forget-value! m1 me)
    (forget-value! m2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else
           (error "Unknown request -- MULTIPLIER" request))))
  (connect m1 me 'multi)
  (connect m2 me 'multi)
  (connect product me 'multi)
  me)


(define (constant value connector)
  (define (me request)
    (error "Unknown request -- CONSTANT" request))
  (connect connector me 'constant)
  (set-value! connector value me)
  me)


(define (probe name connector)
  (define (print-probe value)
    (newline)
    (display "Probe: ")
    (display name)
    (display " = ")
    (display value))
  (define (process-new-value)
    (print-probe (get-value connector)))
  (define (process-forget-value)
    (print-probe "?"))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else
           (error "Unknown request -- PROBE" request))))
  (connect connector me 'probe)
  me)




(define (make-connector)
  (let ((value #f) (informant #f) (constraints '()) (const-names '()))
    (define (set-my-value newval setter)
      (cond ((not (has-value? me))
             (set! value newval)
             (set! informant setter)
             (for-each-except setter
                              inform-about-value
                              constraints))
            ((not (= value newval))
             (error "Contradiction" (list value newval)))
            (else 'ignored)))
    (define (forget-my-value retractor)
      (if (eq? retractor informant)
          (begin (set! informant #f)
                 (for-each-except retractor
                                  inform-about-no-value
                                  constraints))
          'ignored))
    (define (connect new-constraint new-name)
      (if (not (memq new-constraint constraints))
          (set! constraints 
                (cons new-constraint constraints)))
      (if (has-value? me)
          (inform-about-value new-constraint))

      (if (not (memq new-name const-names))
          (set! const-names
                (cons new-name const-names)))
      'done)

    (define (print-const names)
      (if (null? names) 'done
          (begin
            (display "CONSTRAINTS:")
            (display (car names))
            (newline)
            (print-const (cdr names)))))

    (define (me request)
      (cond ((eq? request 'has-value?)
             (if informant #t #f))
            ((eq? request 'value) value)
            ((eq? request 'set-value!) set-my-value)
            ((eq? request 'forget) forget-my-value)
            ((eq? request 'connect) connect)
            ((eq? request 'print) (print-const const-names))
            (else (error "Unknown operation -- CONNECTOR"
                         request))))
    me))



(define (for-each-except exception procedure list)
  (define (loop items)
    (cond ((null? items) 'done)
          ((eq? (car items) exception) (loop (cdr items)))
          (else (procedure (car items))
                (loop (cdr items)))))
  (loop list))



(define (has-value? connector)
  (connector 'has-value?))
(define (get-value connector)
  (connector 'value))
(define (set-value! connector new-value informant)
  ((connector 'set-value!) new-value informant))
(define (forget-value! connector retractor)
  ((connector 'forget) retractor))
(define (connect connector new-constraint new-name)
  ((connector 'connect) new-constraint new-name))

}}}


== 3.35.scm ==


{{{


(define a (make-connector "a"))
(define b (make-connector "b"))


(define (squarer a b)
  (define (process-new-value)
    (if (has-value? b)
        (if (< (get-value b) 0)
            (error "square less than 0 -- SQUARER" (get-value b))
            (set-value! a
                        (sqrt (get-value b))
                        me))
        (if (has-value? a) ;; b has no value, but a
            (set-value! b
                        (* (get-value a) (get-value a))
                        me))))
  (define (process-forget-value)
    (forget-value! a me)
    (forget-value! b me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)  
           (process-new-value))
          ((eq? request 'I-lost-my-value) 
           (process-forget-value))
          ((eq? request 'Who-are-you)
           (display "I-am-squarer") (newline))
          (else 
           (error "Unknown request -- ADDER" request))))
  (connect a me 'squarer)
  (connect b me 'sqaurer)
  me)
            

(squarer a b)

(set-value! a 10 'user)
;; (a 'get-informant)
;; user
;; guile> (b 'get-informant)
;; #<procedure me (request)>
;; guile> ((b 'get-informant) 'Who-are-you)
;; I-am-squarer

(get-value a)
(get-value b)

(forget-value! a 'user)
(get-value a)
(get-value b)
(a 'print)
(b 'print)

(set-value! b 4 'user)
(get-value a)
(get-value b)
(a 'print)
(b 'print)

(set-value! b 100 'user) ;; constradiction
(forget-value! b 'user)
(set-value! b 100 'user)
(get-value a)
(get-value b)
(a 'print)
(b 'print)



;===== system ======

;; (has-value? <connector>)
;; tells whether the connector has a value.
;; (get-value <connector>)
;; returns the connector's current value.
;; (set-value! <connector> <new-value> <informant>)
;; indicates that the informant is requesting the connector to set its value to the new value.
;; (forget-value! <connector> <retractor>)
;; tells the connector that the retractor is requesting it to forget its value.
;; (connect <connector> <new-constraint>)
;; tells the connector to participate in the new constraint.


(define (adder a1 a2 sum)
  (define (process-new-value)
    (cond ((and (has-value? a1) (has-value? a2))
           (display "1")
           (set-value! sum
                       (+ (get-value a1) (get-value a2))
                       me))
          ((and (has-value? a1) (has-value? sum))
           (display "2")
           (set-value! a2
                       (- (get-value sum) (get-value a1))
                       me))
          ((and (has-value? a2) (has-value? sum))
           (display "3")
           (set-value! a1
                       (- (get-value sum) (get-value a2))
                       me))
          (else
           (display "cannot set new value"))))
  (define (process-forget-value)
    (forget-value! sum me)
    (forget-value! a1 me)
    (forget-value! a2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)  
           (process-new-value))
          ((eq? request 'I-lost-my-value) 
           (process-forget-value))
          ((eq? request 'Who-are-you)
           (display "I-am-adder") (newline))
          (else 
           (error "Unknown request -- ADDER" request))))
  (connect a1 me 'adder)
  (connect a2 me 'adder)
  (connect sum me 'adder)
  me)

(define (inform-about-value constraint)
  (constraint 'I-have-a-value))
(define (inform-about-no-value constraint)
  (constraint 'I-lost-my-value))


(define (multiplier m1 m2 product)
  (define (process-new-value)
    (cond ((or (and (has-value? m1) (= (get-value m1) 0))
               (and (has-value? m2) (= (get-value m2) 0)))
           (set-value! product 0 me))
          ((and (has-value? m1) (has-value? m2))
           (set-value! product
                       (* (get-value m1) (get-value m2))
                       me))
          ((and (has-value? product) (has-value? m1))
           (set-value! m2
                       (/ (get-value product) (get-value m1))
                       me))
          ((and (has-value? product) (has-value? m2))
           (set-value! m1
                       (/ (get-value product) (get-value m2))
                       me))))
  (define (process-forget-value)
    (forget-value! product me)
    (forget-value! m1 me)
    (forget-value! m2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          ((eq? request 'Who-are-you)
           (display "I-am-multiplier") (newline))
          (else
           (error "Unknown request -- MULTIPLIER" request))))
  (connect m1 me 'multi)
  (connect m2 me 'multi)
  (connect product me 'multi)
  me)


(define (constant value connector)
  (define (me request)
    (error "Unknown request -- CONSTANT" request))
  (connect connector me 'constant)
  (set-value! connector value me)
  me)


(define (probe name connector)
  (define (print-probe value)
    (newline)
    (display "Probe: ")
    (display name)
    (display " = ")
    (display value))
  (define (process-new-value)
    (print-probe (get-value connector)))
  (define (process-forget-value)
    (print-probe "?"))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else
           (error "Unknown request -- PROBE" request))))
  (connect connector me 'probe)
  me)




(define (make-connector name)
  (let ((value #f) (informant #f) (constraints '()) (const-names '()))
    (define (set-my-value newval setter)
      (cond ((not (has-value? me))
             (set! value newval)
             (set! informant setter)
             (for-each-except setter
                              inform-about-value
                              constraints))
            ((not (= value newval))
             (error "Contradiction" (list value newval informant)))
            (else 'ignored)))
    (define (forget-my-value retractor)
      (if (eq? retractor informant)
          (begin
            (set! informant #f)
            (display name) (display " lost value") (newline)
            (for-each-except retractor
                             inform-about-no-value
                             constraints))
          'ignored))
    (define (connect new-constraint new-name)
      (if (not (memq new-constraint constraints))
          (set! constraints 
                (cons new-constraint constraints)))
      (if (has-value? me)
          (inform-about-value new-constraint))

      (if (not (memq new-name const-names))
          (set! const-names
                (cons new-name const-names)))
      'done)

    (define (print-const names)
      (if (null? names) 'done
          (begin
            (display "CONSTRAINTS:")
            (display (car names))
            (newline)
            (print-const (cdr names)))))
    (define (print-informant)
      (display "INFORMANT:") (display informant) (newline))

    (define (me request)
      (cond ((eq? request 'has-value?)
             (if informant #t #f))
            ((eq? request 'value) value)
            ((eq? request 'set-value!) set-my-value)
            ((eq? request 'forget) forget-my-value)
            ((eq? request 'connect) connect)
            ((eq? request 'print)
             (print-const const-names)
             (print-informant))
            ((eq? request 'get-informant)
             informant)
            (else (error "Unknown operation -- CONNECTOR"
                         request))))
    me))



(define (for-each-except exception procedure list)
  (define (loop items)
    (cond ((null? items) 'done)
          ((eq? (car items) exception) (loop (cdr items)))
          (else (procedure (car items))
                (loop (cdr items)))))
  (loop list))



(define (has-value? connector)
  (connector 'has-value?))
(define (get-value connector)
  (connector 'value))
(define (set-value! connector new-value informant)
  ((connector 'set-value!) new-value informant))
(define (forget-value! connector retractor)
  ((connector 'forget) retractor))
(define (connect connector new-constraint new-name)
  ((connector 'connect) new-constraint new-name))

}}}


== 3.37.scm ==


{{{

(define (celsius-fahrenheit-converter x)
  (c+ (c* (c/ (cv 9) (cv 5))
          x)
      (cv 32)))
(define C (make-connector))
(define F (celsius-fahrenheit-converter C))

(define (c+ x y)
  (let ((z (make-connector)))
    (adder x y z)
    z))

(define (c* x y)
  (let ((z (make-connector)))
    (multiplier x y z)
    z))

(define (c/ x y)
  (let ((z (make-connector)))
    (multiplier z x y)
    z))

(define (cv num)
  (let ((z (make-connector)))
    (constant num z)
    z))

(set-value! C 100 'user)
(get-value F)


;===== system ======

;; (has-value? <connector>)
;; tells whether the connector has a value.
;; (get-value <connector>)
;; returns the connector's current value.
;; (set-value! <connector> <new-value> <informant>)
;; indicates that the informant is requesting the connector to set its value to the new value.
;; (forget-value! <connector> <retractor>)
;; tells the connector that the retractor is requesting it to forget its value.
;; (connect <connector> <new-constraint>)
;; tells the connector to participate in the new constraint.


(define (adder a1 a2 sum)
  (define (process-new-value)
    (cond ((and (has-value? a1) (has-value? a2))
           (display "1")
           (set-value! sum
                       (+ (get-value a1) (get-value a2))
                       me))
          ((and (has-value? a1) (has-value? sum))
           (display "2")
           (set-value! a2
                       (- (get-value sum) (get-value a1))
                       me))
          ((and (has-value? a2) (has-value? sum))
           (display "3")
           (set-value! a1
                       (- (get-value sum) (get-value a2))
                       me))
          (else
           (display "cannot set new value"))))
  (define (process-forget-value)
    (forget-value! sum me)
    (forget-value! a1 me)
    (forget-value! a2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)  
           (process-new-value))
          ((eq? request 'I-lost-my-value) 
           (process-forget-value))
          ((eq? request 'Who-are-you)
           (display "I-am-adder") (newline))
          (else 
           (error "Unknown request -- ADDER" request))))
  (connect a1 me 'adder)
  (connect a2 me 'adder)
  (connect sum me 'adder)
  me)

(define (inform-about-value constraint)
  (constraint 'I-have-a-value))
(define (inform-about-no-value constraint)
  (constraint 'I-lost-my-value))


(define (multiplier m1 m2 product)
  (define (process-new-value)
    (cond ((or (and (has-value? m1) (= (get-value m1) 0))
               (and (has-value? m2) (= (get-value m2) 0)))
           (set-value! product 0 me))
          ((and (has-value? m1) (has-value? m2))
           (set-value! product
                       (* (get-value m1) (get-value m2))
                       me))
          ((and (has-value? product) (has-value? m1))
           (set-value! m2
                       (/ (get-value product) (get-value m1))
                       me))
          ((and (has-value? product) (has-value? m2))
           (set-value! m1
                       (/ (get-value product) (get-value m2))
                       me))))
  (define (process-forget-value)
    (forget-value! product me)
    (forget-value! m1 me)
    (forget-value! m2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          ((eq? request 'Who-are-you)
           (display "I-am-multiplier") (newline))
          (else
           (error "Unknown request -- MULTIPLIER" request))))
  (connect m1 me 'multi)
  (connect m2 me 'multi)
  (connect product me 'multi)
  me)


(define (constant value connector)
  (define (me request)
    (error "Unknown request -- CONSTANT" request))
  (connect connector me 'constant)
  (set-value! connector value me)
  me)


(define (probe name connector)
  (define (print-probe value)
    (newline)
    (display "Probe: ")
    (display name)
    (display " = ")
    (display value))
  (define (process-new-value)
    (print-probe (get-value connector)))
  (define (process-forget-value)
    (print-probe "?"))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else
           (error "Unknown request -- PROBE" request))))
  (connect connector me 'probe)
  me)




(define (make-connector)
  (let ((value #f) (informant #f) (constraints '()) (const-names '()))
    (define (set-my-value newval setter)
      (cond ((not (has-value? me))
             (set! value newval)
             (set! informant setter)
             (for-each-except setter
                              inform-about-value
                              constraints))
            ((not (= value newval))
             (error "Contradiction" (list value newval informant)))
            (else 'ignored)))
    (define (forget-my-value retractor)
      (if (eq? retractor informant)
          (begin
            (set! informant #f)
            (for-each-except retractor
                             inform-about-no-value
                             constraints))
          'ignored))
    (define (connect new-constraint new-name)
      (if (not (memq new-constraint constraints))
          (set! constraints 
                (cons new-constraint constraints)))
      (if (has-value? me)
          (inform-about-value new-constraint))

      (if (not (memq new-name const-names))
          (set! const-names
                (cons new-name const-names)))
      'done)

    (define (print-const names)
      (if (null? names) 'done
          (begin
            (display "CONSTRAINTS:")
            (display (car names))
            (newline)
            (print-const (cdr names)))))
    (define (print-informant)
      (display "INFORMANT:") (display informant) (newline))

    (define (me request)
      (cond ((eq? request 'has-value?)
             (if informant #t #f))
            ((eq? request 'value) value)
            ((eq? request 'set-value!) set-my-value)
            ((eq? request 'forget) forget-my-value)
            ((eq? request 'connect) connect)
            ((eq? request 'print)
             (print-const const-names)
             (print-informant))
            ((eq? request 'get-informant)
             informant)
            (else (error "Unknown operation -- CONNECTOR"
                         request))))
    me))



(define (for-each-except exception procedure list)
  (define (loop items)
    (cond ((null? items) 'done)
          ((eq? (car items) exception) (loop (cdr items)))
          (else (procedure (car items))
                (loop (cdr items)))))
  (loop list))



(define (has-value? connector)
  (connector 'has-value?))
(define (get-value connector)
  (connector 'value))
(define (set-value! connector new-value informant)
  ((connector 'set-value!) new-value informant))
(define (forget-value! connector retractor)
  ((connector 'forget) retractor))
(define (connect connector new-constraint new-name)
  ((connector 'connect) new-constraint new-name))

}}}


== 3.39.scm ==


{{{


1. p1 get 100 -> p2 get 11 -> p1 set 100
2. p1 set 100 -> p2 set 101
3. p2 set 11 -> p1 set 121
}}}


== 3.40.scm ==


{{{

1. 10^2^3 = 10^6
2. 10^3^2 = 10^6
3. 10*10^3 = 10^4, 10*10*10^2 = 10^4, 10*10^2*10 = 10^4
4. 100
5. 1000
}}}


== 3.41.scm ==


{{{


1. 만약 withdraw나 deposit 함수가 복잡한 함수여서 balance 값을 여러번 읽고 여러번 쓴다면
중간중간 balance 값이 달라지므로, balance 값을 읽는 시간이 언제냐에 따라
balance 값이 달라진다. 따라서 이런 경우에는 withdraw와 deposit 함수가 실행되는 중간에
balance 값을 읽지 못하도록 하는 것이 좋다. -> protected 를하는 것이 좋다.
2. 예제와 같이 withdraw와 deposit 함수가 짧은 경우에는 이 함수들이 실행되는 중간에
balance 값을 읽어도 withdraw 와deposit 함수가 실행이 완료된 후나 실행 직전의
balance 값을 읽게되므로 protected를 할 필요가 없다.

결국 일반적인 상황에서는 상태 값을 읽는 함수도 줄세우기를 하는게 좋지 않을까?
상태를 바꾸는 함수들이 실행되는 중간에 상태값을 알수없는/보장할 수 없는 상황에서 상태값을 읽는게 좋지는 않을것이다.
}}}


== 3.42.scm ==


{{{


원본 소스는 상황에 따라 protected 리스트에 프로시저를 넣다 빼면서 실행하는 것이고,
수정 소스는 protected 리스트에 프로시저를 넣어놓고 실행하는 것이다.
따라서 모두 하나의 그룹에 속한 상태로 실행되므로, 동일하게 실행될 것이다.

}}}


== 3.43.scm ==


{{{



;; I made parallel-execute for myself and run ex3.43.
;; The result is not like what it said in ex3.43.


(define (parallel-execute . procs)
  (define (body proc-list)
    (if (null? proc-list) 'All-threads-start
        (begin
          (make-thread (car proc-list))
          (body (cdr proc-list)))))
  (body procs))



(define acc1 10)
(define acc2 30)
(define acc3 50)

(define (change12)
  (let ((differ (- acc1 acc2)))
    (set! acc1 (- acc1 differ))
    (set! acc2 (- acc2 differ)))
  (sleep 1)
  (display acc1) (display "-") (display acc2) (newline)
  (change12))
(define (change21)
  (let ((differ (- acc2 acc1)))
    (set! acc2 (- acc2 differ))
    (set! acc1 (- acc1 differ)))
  (sleep 1)
  (display acc1) (display "-") (display acc2) (newline)
  (change12))

(define (change13)
  (let ((differ (- acc1 acc3)))
    (set! acc1 (- acc1 differ))
    (set! acc3 (- acc3 differ)))
  (sleep 1)
  (display acc1) (display "-") (display acc3) (newline)
  (change13))
(define (change31)
  (let ((differ (- acc3 acc1)))
    (set! acc3 (- acc3 differ))
    (set! acc1 (- acc1 differ)))
  (sleep 1)
  (display acc1) (display "-") (display acc3) (newline)
  (change13))

(parallel-execute change12 change13 change21 change31)
;; guile> 30-50
;; 50-50
;; 50-70
;; 70-50
;; 50-90
;; 90-30
;; 30-130
;; 130--30
;; -30-230
;; 230--190
;; -190-490
;; 490--610
;; -610-1170
;; 1170--1710
;; -1710-2950
;; 2950--4590
;; -4590-7610
;; 7610--12130
;; -12130-19810
;; 19810--31870
}}}


== 3.44.scm ==


{{{



;; I made parallel-execute for myself and run ex3.44.
;; The result is not like what it said in ex3.44

(define (parallel-execute . procs)
  (define (body proc-list)
    (if (null? proc-list) 'All-threads-start
        (begin
          (make-thread (car proc-list))
          (body (cdr proc-list)))))
  (body procs))

(define (make-serializer)
  (let ((mutex (make-mutex)))
    (lambda (p)
      (define (serialized-p . args)
        (lock-mutex mutex)
        (let ((val (apply p args)))
          (unlock-mutex mutex)
          val))
      serialized-p)))



;; test without serializer
(define acc1 10)
(define acc2 30)
(define acc3 50)

(define amount 10)
(define (transfer12)
  (set! acc1 (- acc1 amount))
  (set! acc2 (+ acc2 amount))
  (sleep 1)
  (display acc1) (display "-") (display acc2) (newline)
  (transfer12))
(define (transfer21)
  (set! acc2 (- acc2 amount))
  (set! acc1 (+ acc1 amount))
  (sleep 1)
  (display acc1) (display "-") (display acc2) (newline)
  (transfer21))
(define (transfer13)
  (set! acc1 (- acc1 amount))
  (set! acc3 (+ acc3 amount))
  (sleep 1)
  (display acc1) (display "-") (display acc3) (newline)
  (transfer13))
(define (transfer31)
  (set! acc3 (- acc3 amount))
  (set! acc1 (+ acc1 amount))
  (sleep 1)
  (display acc1) (display "-") (display acc3) (newline)
  (transfer31))

(parallel-execute transfer12 transfer21 transfer13 transfer31)
;; guile> 10-30
;; 0-40
;; 0-50
;; 20-40
;; 10-30
;; 10-40
;; 0-50
;; 10-40
;; 10-30
;; 10-20
;; 20-50
;; 10-60
;; 10-30
;; 0-50
;; 10-40
;; 20-40
;; 10-30
;; 0-50
;; 10-40
;; 20-40
;; 1010-30-
;; 50
;; 10-40
;; 20-40
;; 10-30
;; 10-50
;; 10-4010
;; -40
;; 10-50
;; 20-30
;; 30-20
;; 20-40
;; 10-50
;; 20-30
;; 30-20


;; test with serializer
(define x 10)
(define s (make-serializer))
(parallel-execute (s (lambda () (set! x (* x x))))
                  (s (lambda () (set! x (+ x 1)))))


(define acc1 10)
(define acc2 30)
(define acc3 50)

(define amount 10)
(define (transfer12)
  (set! acc1 (- acc1 amount))
  (set! acc2 (+ acc2 amount))
  (sleep 1)
  (display acc1) (display "-") (display acc2) (newline)
  (transfer12))
(define (transfer21)
  (set! acc2 (- acc2 amount))
  (set! acc1 (+ acc1 amount))
  (sleep 1)
  (display acc1) (display "-") (display acc2) (newline)
  (transfer21))
(define (transfer13)
  (set! acc1 (- acc1 amount))
  (set! acc3 (+ acc3 amount))
  (sleep 1)
  (display acc1) (display "-") (display acc3) (newline)
  (transfer13))
(define (transfer31)
  (set! acc3 (- acc3 amount))
  (set! acc1 (+ acc1 amount))
  (sleep 1)
  (display acc1) (display "-") (display acc3) (newline)
  (transfer31))

(define s (make-serializer))
(parallel-execute (s (lambda () ((transfer12))))
                  (s (lambda () ((transfer21))))
                  (s (lambda () ((transfer13))))
                  (s (lambda () ((transfer31)))))
;; guile> 0-40
;; -10-50
;; -20-60
;; -30-70
;; -40-80
;; -50-90
;; -60-100
;; -70-110
;; -80-120
;; -90-130
;; -100-140
}}}


== 3.50.scm ==


{{{
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))
;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))
(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))

(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))

(define ddd (cons 10000
                  (delay (stream-enumerate-interval 10001 1000000))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))


;; ex3.50
(define (stream-map proc . argstreams)
  (if (null? (car argstreams))
      the-empty-stream
      (cons-stream
       (apply proc (map stream-car argstreams))
       (apply stream-map
              (cons proc (map stream-cdr argstreams))))))

}}}


== 3.51.scm ==


{{{
;;---------- prime? -------------------------------
(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n ) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))

(define (divides? a b)
  (= (remainder b a) 0))

(define (square n)
  (* n n))

(define (prime? n)
  (= n (smallest-divisor n)))
;;------------------------------------------------

;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (show x)
  (display-line x)
  x)


(define x (stream-map show
                      (stream-enumerate-interval 0 10)))
;; x is just (0 . #<promise #<procedure #f ()>>)
;; show cannot print all numbers 0~10

(stream-ref x 5) ; this prints only 0~5
(stream-ref x 7)


}}}


== 3.52.scm ==


{{{
;;---------- prime? -------------------------------
(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n ) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))

(define (divides? a b)
  (= (remainder b a) 0))

(define (square n)
  (* n n))

(define (prime? n)
  (= n (smallest-divisor n)))
;;------------------------------------------------

;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))
  
  
;;ex3.52

(define sum 0)
;; sum = 0


(define (accum x)
  (set! sum (+ x sum))
  sum)

(define seq
  (stream-map accum
              (stream-enumerate-interval 1 20)))
;; process one item (=1), therefore sum will be 1.
;; guile> guile> sum
;; 1
;; guile> seq
;; (1 . #<promise #<procedure #f ()>>)


(define y (stream-filter even? seq))
;; process until even number 6.
;; guile> seq
;; (1 . #<promise (3 . #<promise (6 . #<promise #<procedure #f ()>>)>)>)
;; guile> sum
;; 6
;; guile> 

(define z (stream-filter (lambda (x) (= (remainder x 5) 0))
                         seq))
;; process until meet 10
;; guile> sum
;; 10
;; guile> seq
;; (1 . #<promise (3 . #<promise (6 . #<promise (10 . #<promise #<procedure #f ()>>)>)>)>)
;; guile> 

(stream-ref y 7) ;; 136
(display-stream z)
;; 10
;; 15
;; 45
;; 55
;; 105
;; 120
;; 190
;; 210done


;; final status
;; guile> sum
;; 210
;; guile> seq
;; (1 . #<promise (3 . #<promise (6 . #<promise (10 . #<promise (15 . #<promise (21 . #<promise (28 . #<promise (36 . #<promise (45 . #<promise (55 . #<promise (66 . #<promise (78 . #<promise (91 . #<promise (105 . #<promise (120 . #<promise (136 . #<promise (153 . #<promise (171 . #<promise (190 . #<promise (210 . #<promise ()>)>)>)>)>)>)>)>)>)>)>)>)>)>)>)>)>)>)>)>)


;; If delay is normal lambda procedure, seq is initialized with full entry.



}}}


== 3.53.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define s (cons-stream 1 (add-streams s s)))

(stream-ref s 0)
(stream-ref s 1)
(stream-ref s 2)
(stream-ref s 3)
(stream-ref s 4)
(stream-ref s 5)
(stream-ref s 6)
;; guile> 1
;; guile> 2
;; guile> 4
;; guile> 8
;; guile> 16
;; guile> 32
;; guile> 64
;; guile> 
}}}


== 3.54.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))


(define ones (cons-stream 1 ones))
(define integers (cons-stream 1 (add-streams ones integers)))

(stream-ref integers 0)
(stream-ref integers 1)
(stream-ref integers 2)
(stream-ref integers 3)

;; test mul-streams
(define squares (mul-streams integers integers))

(stream-ref squares 0)
(stream-ref squares 1) ;; 2^2
(stream-ref squares 2) ;; 3^2
(stream-ref squares 3) ;; 4^2


(define factorials (cons-stream 1 (mul-streams factorials (stream-cdr integers))))

(stream-ref factorials 0)
(stream-ref factorials 1)
(stream-ref factorials 2)
(stream-ref factorials 3)
(stream-ref factorials 4)
(stream-ref factorials 5)
;; guile> 1
;; guile> 2
;; guile> 6
;; guile> 24
;; guile> 120
;; guile> 720
;; guile> 
}}}


== 3.55.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))


(define ones (cons-stream 1 ones))
(define integers (cons-stream 1 (add-streams ones integers)))

(stream-ref integers 0)
(stream-ref integers 1)
(stream-ref integers 2)
(stream-ref integers 3)

(define ddd (cons-stream 1 (add-streams ddd (stream-cdr integers))))
(stream-ref ddd 0)
(stream-ref ddd 1)
(stream-ref ddd 2)
(stream-ref ddd 3)


(define (partial-sums strm)
  (cons-stream (stream-car strm) (add-streams (stream-cdr strm) (partial-sums strm))))

(define partial-sums-integers (partial-sums integers))

(stream-ref partial-sums-integers 0)
(stream-ref partial-sums-integers 1)
(stream-ref partial-sums-integers 2)
(stream-ref partial-sums-integers 3)
(stream-ref partial-sums-integers 4)
;; guile> 1
;; guile> 3
;; guile> 6
;; guile> 10
;; guile> 15
;; guile> 
}}}


== 3.56.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))



(define (merge s1 s2)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           (cond ((< s1car s2car)
                  (cons-stream s1car (merge (stream-cdr s1) s2)))
                 ((> s1car s2car)
                  (cons-stream s2car (merge s1 (stream-cdr s2))))
                 (else
                  (cons-stream s1car
                               (merge (stream-cdr s1)
                                      (stream-cdr s2)))))))))

(define S (cons-stream 1 (merge (scale-stream S 2)
                                (merge (scale-stream S 3)
                                       (scale-stream S 5)))))
                                                     

(stream-ref S 0)           
(stream-ref S 1)
(stream-ref S 2)
(stream-ref S 3)
(stream-ref S 4)
(stream-ref S 5)
(stream-ref S 6)
(stream-ref S 7)
(stream-ref S 8)
(stream-ref S 9)
(stream-ref S 10)
(stream-ref S 11)
(stream-ref S 12)
(stream-ref S 13)
(stream-ref S 14)
(stream-ref S 15)
;; guile> 1
;; guile> 2
;; guile> 3
;; guile> 4
;; guile> 5
;; guile> 6
;; guile> 8
;; guile> 9
;; guile> 10
;; guile> 12
;; guile> 15
;; guile> 16
;; guile> 18
;; guile> 20
;; guile> 24
;; guile> 25
;; guile> 
}}}


== 3.58.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))



(define (expand num den radix)
  (cons-stream
   (quotient (* num radix) den)
   (expand (remainder (* num radix) den) den radix)))

(define re1 (expand 1 7 10))
(stream-ref re1 0)
(stream-ref re1 1)
(stream-ref re1 2)
(stream-ref re1 3)
(stream-ref re1 4)
(stream-ref re1 5)


(expand 3 8 10)
}}}


== 3.59.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))


(define ones (cons-stream 1 ones))
(define integers (cons-stream 1 (add-streams ones integers)))

;; 3.59 - a.
(define C 0)

(define (integrate-series coeffs)
  (cons-stream C (stream-map / coeffs integers)))

(define test (integrate-series ones))
(stream-ref test 0)
(stream-ref test 1)
(stream-ref test 2)
(stream-ref test 3)
(stream-ref test 4)

(define test2 (integrate-series integers))
(stream-ref test2 0)
(stream-ref test2 1)
(stream-ref test2 2)
(stream-ref test2 3)
(stream-ref test2 4)


;; 3.59 - b.
(define exp-series
  (cons-stream 1 (integrate-series exp-series)))


(define (negate-series series)
  (stream-map - series))

(define cosine-series
  (cons-stream 1 (negate-series (integrate-series sine-series))))

(define sine-series
  (cons-stream 0 (integrate-series cosine-series)))


(stream-ref cosine-series 0)
(stream-ref cosine-series 1)
(stream-ref cosine-series 2)
(stream-ref cosine-series 3)
(stream-ref cosine-series 4)
(stream-ref cosine-series 5)
(stream-ref cosine-series 6)
(stream-ref cosine-series 7)
(stream-ref cosine-series 8)
(stream-ref cosine-series 9)

(stream-ref sine-series 0)
(stream-ref sine-series 1)
(stream-ref sine-series 2)
(stream-ref sine-series 3)
(stream-ref sine-series 4)
(stream-ref sine-series 5)
(stream-ref sine-series 6)
(stream-ref sine-series 7)
(stream-ref sine-series 8)
(stream-ref sine-series 9)

}}}


== 3.60.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))




;; 3.59 - a.
(define ones (cons-stream 1 ones))
(define integers (cons-stream 1 (add-streams ones integers)))

(define (integrate-series coeffs)
  (stream-map / coeffs integers))

;; 3.59 - b.
(define exp-series
  (cons-stream 1 (integrate-series exp-series)))
(define cosine-series
  (cons-stream 1 (integrate-series
                  (scale-stream sine-series -1))))
(define sine-series
  (cons-stream 0 (integrate-series cosine-series)))

;; 3.60

;; (car s1)*(car s2) -> R1
;; + (car s1)*(cdr s2) -> R2
;; + (cdr s1)*(car s2) -> R3
;; + (cdr s1)*(cdr s1) -> R4 -> constant must be ZERO!
(define (mul-series s1 s2)
  (cons-stream (* (stream-car s1) (stream-car s2)) ;R1
               (add-streams
                (scale-stream (stream-cdr s2) (stream-car s1)) ;R2
                (add-streams
                 (scale-stream (stream-cdr s1) (stream-car s2)) ; R3
                 (cons-stream 0
                              (mul-series (stream-cdr s1)
                                          (stream-cdr s2))))))) ;R4

(define re (add-streams (mul-series cosine-series cosine-series)
                        (mul-series sine-series sine-series)))
(stream-ref re 0)
(stream-ref re 1)
(stream-ref re 2)
(stream-ref re 3)
(stream-ref re 4)
}}}


== 3.61.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))




;; 3.59 - a.
(define ones (cons-stream 1 ones))
(define integers (cons-stream 1 (add-streams ones integers)))

(define (integrate-series coeffs)
  (stream-map / coeffs integers))

;; 3.59 - b.
(define exp-series
  (cons-stream 1 (integrate-series exp-series)))
(define cosine-series
  (cons-stream 1 (integrate-series
                  (scale-stream sine-series -1))))
(define sine-series
  (cons-stream 0 (integrate-series cosine-series)))

;; 3.60

;; (car s1)*(car s2) -> R1
;; + (car s1)*(cdr s2) -> R2
;; + (cdr s1)*(car s2) -> R3
;; + (cdr s1)*(cdr s1) -> R4 -> constant must be ZERO!
(define (mul-series s1 s2)
  (cons-stream (* (stream-car s1) (stream-car s2)) ;R1
               (add-streams
                (scale-stream (stream-cdr s2) (stream-car s1)) ;R2
                (add-streams
                 (scale-stream (stream-cdr s1) (stream-car s2)) ; R3
                 (cons-stream 0
                              (mul-series (stream-cdr s1)
                                          (stream-cdr s2))))))) ;R4


;; 3.61

(define (invert-unit-series s)
  (cons-stream 1 (scale-stream (mul-series (stream-cdr s)
                                           (invert-unit-series s))
                               -1)))



}}}


== 3.62.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))




;; 3.59 - a.
(define ones (cons-stream 1 ones))
(define integers (cons-stream 1 (add-streams ones integers)))

(define (integrate-series coeffs)
  (stream-map / coeffs integers))

;; 3.59 - b.
(define exp-series
  (cons-stream 1 (integrate-series exp-series)))
(define cosine-series
  (cons-stream 1 (integrate-series
                  (scale-stream sine-series -1))))
(define sine-series
  (cons-stream 0 (integrate-series cosine-series)))

;; 3.60

;; (car s1)*(car s2) -> R1
;; + (car s1)*(cdr s2) -> R2
;; + (cdr s1)*(car s2) -> R3
;; + (cdr s1)*(cdr s1) -> R4 -> constant must be ZERO!
(define (mul-series s1 s2)
  (cons-stream (* (stream-car s1) (stream-car s2)) ;R1
               (add-streams
                (scale-stream (stream-cdr s2) (stream-car s1)) ;R2
                (add-streams
                 (scale-stream (stream-cdr s1) (stream-car s2)) ; R3
                 (cons-stream 0
                              (mul-series (stream-cdr s1)
                                          (stream-cdr s2))))))) ;R4


;; 3.61

(define (invert-unit-series s)
  (cons-stream 1 (scale-stream (mul-series (stream-cdr s)
                                           (invert-unit-series s))
                               -1)))



;; 3.62

(define (div-series s1 s2)
  (mul-series s1 (invert-unit-series s2)))


;; test
(stream-cdr (div-series exp-series exp-series))

;; tangent
(define tangent (div-series sine-series cosine-series))
(stream-ref tangent 0)
(stream-ref tangent 1)
(stream-ref tangent 2)
(stream-ref tangent 3)
(stream-ref tangent 4)
(stream-ref tangent 5)
(stream-ref tangent 6)
;; guile> 0
;; guile> 1
;; guile> 0
;; guile> 1/3
;; guile> 0
;; guile> 2/15
}}}


== 3.63.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))




;;3.63

(define (average a b) (/ (+ a b) 2))
(define (sqrt-improve guess x)
  (display "new guess=") (display (average guess (/ x guess))) (newline)
  (average guess (/ x guess)))

(define (sqrt-stream x)
  (cons-stream 1.0
               (stream-map (lambda (guess) (sqrt-improve guess x))
                           (sqrt-stream x))))


(define (sqrt-stream-fast x)
  (define guesses
    (cons-stream 1.0
                 (stream-map (lambda (guess)
                               (sqrt-improve guess x))
                             guesses)))
  guesses)

(define slow (sqrt-stream 4))
(stream-ref slow 0)
(stream-ref slow 1)
(stream-ref slow 2)
(stream-ref slow 3)
(stream-ref slow 4)
;; new guess=2.5
;; new guess=2.5
;; new guess=2.05
;; new guess=2.5
;; new guess=2.05
;; new guess=2.00060975609756
;; new guess=2.5
;; new guess=2.05
;; new guess=2.00060975609756
;; new guess=2.00000009292229
;; 2.00000009292229 
;; -> (sqrt-stream x) is repeated!

(define fast (sqrt-stream-fast 4))
(stream-ref fast 0)
(stream-ref fast 1)
(stream-ref fast 2)
(stream-ref fast 3)
(stream-ref fast 4)
;; guile> guile> new guess=2.5
;; new guess=2.05
;; new guess=2.00060975609756
;; new guess=2.00000009292229
;; 2.00000009292229
;; guile> 
}}}


== 3.64.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))




;;3.63

(define (average a b) (/ (+ a b) 2))
(define (sqrt-improve guess x)
  (display "new guess=") (display (average guess (/ x guess))) (newline)
  (average guess (/ x guess)))

(define (sqrt-stream x)
  (cons-stream 1.0
               (stream-map (lambda (guess) (sqrt-improve guess x))
                           (sqrt-stream x))))


(define (sqrt-stream-fast x)
  (define guesses
    (cons-stream 1.0
                 (stream-map (lambda (guess)
                               (sqrt-improve guess x))
                             guesses)))
  guesses)

(define slow (sqrt-stream 4))
(stream-ref slow 0)
(stream-ref slow 1)
(stream-ref slow 2)
(stream-ref slow 3)
(stream-ref slow 4)
;; new guess=2.5
;; new guess=2.5
;; new guess=2.05
;; new guess=2.5
;; new guess=2.05
;; new guess=2.00060975609756
;; new guess=2.5
;; new guess=2.05
;; new guess=2.00060975609756
;; new guess=2.00000009292229
;; 2.00000009292229 
;; -> (sqrt-stream x) is repeated!

(define fast (sqrt-stream-fast 4))
(stream-ref fast 0)
(stream-ref fast 1)
(stream-ref fast 2)
(stream-ref fast 3)
(stream-ref fast 4)
;; guile> guile> new guess=2.5
;; new guess=2.05
;; new guess=2.00060975609756
;; new guess=2.00000009292229
;; 2.00000009292229
;; guile> 

;;3.64
(define (sqrt x tolerance)
  (stream-limit (sqrt-stream-fast x) tolerance))

(define (stream-limit strm tolerance)
  (let ((one-step (stream-car strm))
        (two-step (stream-car (stream-cdr strm))))
    (if (< (abs (- one-step two-step)) tolerance)
        two-step
        (stream-limit (stream-cdr strm) tolerance))))

(sqrt 4 0.001)
(sqrt 4 0.00001)
}}}


== 3.65.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))


(define (display-stream strm)
  (define (body strm n)
    (if (< n 0) 'done
        (begin (display (stream-car strm)) (newline)
               (body (stream-cdr strm) (- n 1)))))
  (body strm 10))

;; 3.65

(define (partial-sums strm)
  (cons-stream (stream-car strm) (add-streams (stream-cdr strm) (partial-sums strm))))

(define (natural-log-summands n)
  (cons-stream (/ 1.0 n)
               (stream-map - (natural-log-summands (+ n 1)))))

(define natural-log-stream
  (scale-stream (partial-sums (natural-log-summands 1)) 1))

(display-stream natural-log-stream)
;; guile> 1.0
;; 0.5
;; 0.833333333333333
;; 0.583333333333333
;; 0.783333333333333
;; 0.616666666666667
;; 0.759523809523809
;; 0.634523809523809
;; 0.745634920634921
;; 0.645634920634921
;; 0.736544011544012
;; done

(define (square a) (* a a))

(define (euler-transform s)
  (let ((s0 (stream-ref s 0))
        (s1 (stream-ref s 1))
        (s2 (stream-ref s 2)))
    (cons-stream (- s2 (/ (square (- s2 s1))
                          (+ s0 (* -2 s1) s2)))
                 (euler-transform (stream-cdr s)))))

(display-stream (euler-transform natural-log-stream))
;; guile> 0.7
;; 0.690476190476191
;; 0.694444444444444
;; 0.692424242424242
;; 0.693589743589744
;; 0.692857142857143
;; 0.693347338935574
;; 0.693003341687552
;; 0.693253968253968
;; 0.693065750674446
;; 0.693210678210678
;; done

(define (make-tableau transform s)
  (cons-stream s
               (make-tableau transform
                             (transform s))))

(define (accelerated-sequence transform s)
  (stream-map stream-car
              (make-tableau transform s)))

(display-stream (accelerated-sequence euler-transform
                                      natural-log-stream))
;; guile> 1.0
;; 0.7
;; 0.69327731092437
;; 0.693148869332925
;; 0.693147196073549
;; 0.693147180663564
;; 0.693147180560404
;; 0.693147180559945
;; 0.693147180559943
;; 0.693147180559945
;; +nan.0
;; done
}}}


== 3.66.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))


(define (display-stream strm count)
  (define (body strm n)
    (if (< n 0) 'done
        (begin (display (stream-car strm)) (newline)
               (body (stream-cdr strm) (- n 1)))))
  (body strm count))




(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))

(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) (stream-cdr t)))))


;; (stream-filter (lambda (pair)
;;                  (prime? (+ (car pair) (cadr pair))))
;;                int-pairs)

(define ones (cons-stream 1 ones))
(define integers (cons-stream 1 (add-streams ones integers)))

(pairs integers integers)

(display-stream (pairs integers integers) 20)



(1 1)
(1 2)(2 2)

(1 3)(2 3)
(1 4)(3 3)

(1 5)(2 4)
(1 6)(3 4)

(1 7)(2 5)

(1 8)(4 4)
(1 9)(2 6)
(1 10)(3 5)
(1 11)(2 7)
}}}


== 3.67.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))


(define (display-stream strm count)
  (define (body strm n)
    (if (< n 0) 'done
        (begin (display (stream-car strm)) (newline)
               (body (stream-cdr strm) (- n 1)))))
  (body strm count))




(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))

;; original
;; (define (pairs s t)
;;   (cons-stream
;;    (list (stream-car s) (stream-car t))
;;    (interleave
;;     (stream-map (lambda (x) (list (stream-car s) x))
;;                 (stream-cdr t))
;;     (pairs (stream-cdr s) (stream-cdr t)))))


;; 3.67


(define ones (cons-stream 1 ones))
(define integers (cons-stream 1 (add-streams ones integers)))

(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (interleave
     (stream-map (lambda (x) (list x (stream-car s)))
                 (stream-cdr t))
     (pairs (stream-cdr s) (stream-cdr t))))))

(display-stream (new-pairs integers integers) 20)
;; guile> (1 1)
;; (2 1)
;; (2 2)
;; (3 1)
;; (3 2)
;; (4 1)
;; (3 3)
;; (5 1)
;; (4 2)
;; (6 1)
;; (4 3)
;; (7 1)
;; (5 2)
;; (8 1)
;; (4 4)
;; (9 1)
;; (6 2)
;; (10 1)
;; (5 3)
;; (11 1)
;; (7 2)
;; done
;; guile> 

}}}


== 3.68.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))


(define (display-stream strm count)
  (define (body strm n)
    (if (< n 0) 'done
        (begin (display (stream-car strm)) (newline)
               (body (stream-cdr strm) (- n 1)))))
  (body strm count))




(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))

;; original
;; (define (pairs s t)
;;   (cons-stream
;;    (list (stream-car s) (stream-car t))
;;    (interleave
;;     (stream-map (lambda (x) (list (stream-car s) x))
;;                 (stream-cdr t))
;;     (pairs (stream-cdr s) (stream-cdr t)))))


;; 3.68
(define ones (cons-stream 1 ones))
(define integers (cons-stream 1 (add-streams ones integers)))

(define (pairs s t)
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                t)
    (pairs (stream-cdr s) (stream-cdr t))))

(display-stream (pairs integers integers) 10)
;; guile> ERROR: Stack overflow
;; ABORT: (stack-overflow)

;; This does expand stream, not delay it, because there is no cons-stream which makes stream delay.
}}}


== 3.69.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))


(define (display-stream strm count)
  (define (body strm n)
    (if (< n 0) 'done
        (begin (display (stream-car strm)) (newline)
               (body (stream-cdr strm) (- n 1)))))
  (body strm count))




(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))


(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) (stream-cdr t)))))
(display-stream (pairs integers integers) 10)

(define (triples s t u)
  (cons-stream
   (list (stream-car s) (stream-car t) (stream-car u))
   (interleave
    (stream-map (lambda (x) (cons (stream-car s) x))
                (pairs (stream-cdr s) (stream-cdr t)))
    (triples (stream-cdr s) (stream-cdr t) (stream-cdr u)))))

(define ones (cons-stream 1 ones))
(define integers (cons-stream 1 (add-streams ones integers)))

(display-stream (triples integers integers integers) 30)
;; guile> (1 1 1)
;; (1 2 2)
;; (2 2 2)
;; (1 2 3)
;; (2 3 3)
;; (1 3 3)
;; (3 3 3)
;; (1 2 4)
;; (2 3 4)
;; (1 3 4)
;; (3 4 4)
;; (1 2 5)
;; (2 4 4)
;; (1 4 4)
;; (4 4 4)
;; (1 2 6)
;; (2 3 5)
;; (1 3 5)
;; (3 4 5)
;; (1 2 7)
;; (2 4 5)
;; (1 4 5)
;; (4 5 5)
;; (1 2 8)
;; (2 3 6)
;; (1 3 6)
;; (3 5 5)
;; (1 2 9)
;; (2 5 5)
;; (1 5 5)
;; (5 5 5)
;; done


(define (pythagorean-filter triple)
  (let ((i (car triple))
        (j (cadr triple))
        (k (caddr triple)))
    (and (<= i j) (= (* k k) (+ (* i i) (* j j))))))

(pythagorean-filter '(3 4 5))
(pythagorean-filter '(3 4 6))

(display-stream (stream-filter pythagorean-filter (triples integers integers integers)) 5)
;;  (3 4 5)
;; (6 8 10)
;; (5 12 13)
;; (9 12 15)
;; (8 15 17)
;; (12 16 20)
}}}


== 3.70.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))


(define (display-stream strm count)
  (define (body strm n)
    (if (< n 0) 'done
        (begin (display (stream-car strm)) (newline)
               (body (stream-cdr strm) (- n 1)))))
  (body strm count))




(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))

(define ones (cons-stream 1 ones))
(define integers (cons-stream 1 (add-streams ones integers)))



;; 3.70
(define (merge s1 s2)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           (cond ((< s1car s2car)
                  (cons-stream s1car (merge (stream-cdr s1) s2)))
                 ((> s1car s2car)
                  (cons-stream s2car (merge s1 (stream-cdr s2))))
                 (else
                  (cons-stream s1car
                               (merge (stream-cdr s1)
                                      (stream-cdr s2)))))))))


(define (merge-weighted weight s1 s2)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           ;; weight값이 같다고 merge프로시저와 같이 하나의 pair 만 merge하면 안됨 
           ;; weight값이 같으면 s1을 먼저 연결할 것
           (cond ((<= (weight s1car) (weight s2car)) ;; must consider same case
                  (cons-stream s1car (merge-weighted weight (stream-cdr s1) s2)))
                 (else
                  (cons-stream s2car (merge-weighted weight s1 (stream-cdr s2)))))))))

(define (weight-ex pair)
  (+ (car pair) (cadr pair)))

(define test-pairs (cons-stream (list (stream-car integers) (stream-car integers))
                                (stream-map (lambda (x) (list x x))
                                            (stream-cdr integers))))
(define test-pairs-1 (stream-filter (lambda (x) (even? (car x)))
                                    test-pairs))
(define test-pairs-2 (stream-filter (lambda (x) (odd? (car x)))
                                    test-pairs))

(display-stream test-pairs-1 10)
(display-stream test-pairs-2 10)

(display-stream (merge-weighted weight-ex test-pairs-1 test-pairs-2) 10)

;; guile> (2 2)
;; (4 4)
;; (6 6)
;; (8 8)
;; (10 10)
;; (12 12)
;; (14 14)
;; (16 16)
;; (18 18)
;; (20 20)
;; (22 22)
;; done
;; guile> guile> (1 1)
;; (3 3)
;; (5 5)
;; (7 7)
;; (9 9)
;; (11 11)
;; (13 13)
;; (15 15)
;; (17 17)
;; (19 19)
;; (21 21)
;; done
;; guile> (1 1)
;; (2 2)
;; (3 3)
;; (4 4)
;; (5 5)
;; (6 6)
;; (7 7)
;; (8 8)
;; (9 9)
;; (10 10)
;; (11 11)
;; done

(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) (stream-cdr t)))))


;; 3.70.a

(define (weighted-pairs weight s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (merge-weighted weight
                   (stream-map (lambda (x) (list (stream-car s) x))
                               (stream-cdr t))
                   (weighted-pairs weight (stream-cdr s) (stream-cdr t)))))
   


(display-stream (weighted-pairs weight-ex integers integers) 10)
;; guile> (1 1) -2
;; (1 2) -3
;; (2 2) -4
;; (1 3)
;; (2 3) -5
;; (1 4)
;; (3 3) -6
;; (1 5)
;; (2 4)
;; (1 6) -7
;; (3 4)
;; done



;; 3.70.b
(define (weight-ex-b pair)
  (+ (* 2 (car pair)) (* 3 (cadr pair)) (* 5 (car pair) (cadr pair))))

(define (filter-ex-b pair)
  (let ((p1 (car pair))
        (p2 (cadr pair)))
    (cond ((or (= (modulo p1 2) 0) (= (modulo p2 2) 0)) #f)
          ((or (= (modulo p1 3) 0) (= (modulo p2 3) 0)) #f)
          ((or (= (modulo p1 5) 0) (= (modulo p2 5) 0)) #f)
          (else #t))))

(display-stream (stream-filter
                 filter-ex-b
                 (weighted-pairs weight-ex-b integers integers)) 100)
;; guile> (1 1)
;; (1 7)
;; (1 11)
;; (1 13)
;; (1 17)
;; (1 19)
;; (1 23)
;; (1 29)
;; (1 31)
;; (1 37)
;; (1 41)
;; (1 43)
;; (1 47)
;; (1 49)
;; (1 53)
;; (1 59)
;; (1 61)
;; (7 7)
;; (1 67)
;; (1 71)
;; (1 73)
;; (1 77)
;; (1 79)
;; (1 83)
;; (1 89)
;; (1 91)
;; (1 97)
;; (1 101)
;; (1 103)
;; (1 107)
;; (1 109)
;; (1 113)
;; (1 119)
;; (1 121)
;; (1 127)
;; (1 131)
;; (1 133)
;; (1 137)
;; (1 139)
;; (1 143)
;; (1 149)
;; (1 151)
;; (1 157)
;; (1 161)
;; (1 163)
;; (1 167)
;; (1 169)
;; (1 173)
;; (1 179)
;; (1 181)
;; (1 187)
;; (1 191)
;; (1 193)
;; (1 197)
;; (1 199)
;; (1 203)
;; (1 209)
;; (1 211)
;; (1 217)
;; (1 221)
;; (1 223)
;; (1 227)
;; (1 229)
;; (1 233)
;; (1 239)
;; (1 241)
;; (1 247)
;; (1 251)
;; (1 253)
;; (1 257)
;; (1 259)
;; (1 263)
;; (1 269)
;; (1 271)
;; (1 277)
;; (1 281)
;; (1 283)
;; (1 287)
;; (7 11)
;; (1 289)
;; (1 293)
;; (1 299)
;; (1 301)
;; (1 307)
;; (1 311)
;; (1 313)
;; (1 317)
;; (1 319)
;; (1 323)
;; (1 329)
;; (1 331)
;; (1 337)
;; (1 341)
;; (1 343)
;; (1 347)
;; (1 349)
;; (1 353)
;; (1 359)
;; (1 361)
;; (1 367)
;; (1 371)
;; done












}}}


== 3.71.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))


(define (display-stream strm count)
  (define (body strm n)
    (if (< n 0) 'done
        (begin (display (stream-car strm)) (newline)
               (body (stream-cdr strm) (- n 1)))))
  (body strm count))




(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))

(define ones (cons-stream 1 ones))
(define integers (cons-stream 1 (add-streams ones integers)))



;; 3.70

(define (merge-weighted weight s1 s2)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           ;; weight값이 같다고 merge프로시저와 같이 하나의 pair 만 merge하면 안됨 
           ;; weight값이 같으면 s1을 먼저 연결할 것
           (cond ((<= (weight s1car) (weight s2car)) ;; must consider same case
                  (cons-stream s1car (merge-weighted weight (stream-cdr s1) s2)))
                 (else
                  (cons-stream s2car (merge-weighted weight s1 (stream-cdr s2)))))))))


(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) (stream-cdr t)))))


(define (weighted-pairs weight s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (merge-weighted weight
                   (stream-map (lambda (x) (list (stream-car s) x))
                               (stream-cdr t))
                   (weighted-pairs weight (stream-cdr s) (stream-cdr t)))))
   
         

;; 3.71

(define (weight-ex pair)
  (let ((p1 (car pair))
        (p2 (cadr pair)))
    (+ (* p1 p1 p1) (* p2 p2 p2))))


(define (display-stream-with-weight strm count weight)
  (define (body strm n)
    (if (< n 0) 'done
        (begin (display (stream-car strm)) (display "->") (display (weight (stream-car strm))) (newline)
               (body (stream-cdr strm) (- n 1)))))
  (body strm count))


(display-stream-with-weight (weighted-pairs weight-ex integers integers) 70 weight-ex)


(define (extract-ramanujan pair-stream weight count)
  (if (= count 0) 'done
      (let ((p1 (stream-car pair-stream))
            (p2 (stream-car (stream-cdr pair-stream))))
        (if (= (weight p1) (weight p2))
            (begin (display (weight p1)) (newline)
                   (extract-ramanujan (stream-cdr pair-stream) weight (- count 1)))
            (extract-ramanujan (stream-cdr pair-stream) weight count)))))

(extract-ramanujan (weighted-pairs weight-ex integers integers)
                   weight-ex
                   6)
;;  guile> 1729
;; 4104
;; 13832
;; 20683
;; 32832
;; 39312
;; done
;; guile> 
}}}


== 3.72.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))


(define (display-stream strm count)
  (define (body strm n)
    (if (< n 0) 'done
        (begin (display (stream-car strm)) (newline)
               (body (stream-cdr strm) (- n 1)))))
  (body strm count))




(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))

(define ones (cons-stream 1 ones))
(define integers (cons-stream 1 (add-streams ones integers)))



;; 3.70

(define (merge-weighted weight s1 s2)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           ;; weight값이 같다고 merge프로시저와 같이 하나의 pair 만 merge하면 안됨 
           ;; weight값이 같으면 s1을 먼저 연결할 것
           (cond ((<= (weight s1car) (weight s2car)) ;; must consider same case
                  (cons-stream s1car (merge-weighted weight (stream-cdr s1) s2)))
                 (else
                  (cons-stream s2car (merge-weighted weight s1 (stream-cdr s2)))))))))


(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) (stream-cdr t)))))


(define (weighted-pairs weight s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (merge-weighted weight
                   (stream-map (lambda (x) (list (stream-car s) x))
                               (stream-cdr t))
                   (weighted-pairs weight (stream-cdr s) (stream-cdr t)))))
   
         

;; 3.72

(define (weight-ex pair)
  (let ((p1 (car pair))
        (p2 (cadr pair)))
    (+ (* p1 p1) (* p2 p2))))


(define (display-stream-with-weight strm count weight)
  (define (body strm n)
    (if (< n 0) 'done
        (begin (display (stream-car strm)) (display "->") (display (weight (stream-car strm))) (newline)
               (body (stream-cdr strm) (- n 1)))))
  (body strm count))


(display-stream-with-weight (weighted-pairs weight-ex integers integers) 70 weight-ex)


(define (extract pair-stream weight count)
  (if (= count 0) 'done
      (let ((p1 (stream-car pair-stream))
            (p2 (stream-car (stream-cdr pair-stream)))
            (p3 (stream-car (stream-cdr (stream-cdr pair-stream)))))
        (if (= (weight p1) (weight p2) (weight p3))
            (begin (display p1) (display ",") (display p2) (display ",")
                   (display p3) (display "-->") (display (weight p1)) (newline)
                   (extract (stream-cdr pair-stream) weight (- count 1)))
            (extract (stream-cdr pair-stream) weight count)))))

(extract (weighted-pairs weight-ex integers integers)
                   weight-ex
                   6)
;; guile> (1 18),(6 17),(10 15)-->325
;; (5 20),(8 19),(13 16)-->425
;; (5 25),(11 23),(17 19)-->650
;; (7 26),(10 25),(14 23)-->725
;; (2 29),(13 26),(19 22)-->845
;; (3 29),(11 27),(15 25)-->850
;; done
;; guile> 
}}}


== 3.73.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))


(define (display-stream strm count)
  (define (body strm n)
    (if (< n 0) 'done
        (begin (display (stream-car strm)) (newline)
               (body (stream-cdr strm) (- n 1)))))
  (body strm count))




(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))

(define ones (cons-stream 1 ones))
(define integers (cons-stream 1 (add-streams ones integers)))



;; 3.73

(define (integral integrand initial-value dt)
  (define int
    (cons-stream initial-value
                 (add-streams (scale-stream integrand dt)
                              int)))
  int)

(define (RC R C dt)
  (lambda (i-stream v-init)
    (add-streams (scale-stream (integral i-stream (* C v-init) dt) (/ 1 C))
                 (scale-stream i-stream R))))

(define RC1 (RC 5 1 0.5))

(display-stream (RC1 integers 0) 10)




}}}


== 3.74.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))


(define (display-stream strm count)
  (define (body strm n)
    (if (< n 0) 'done
        (begin (display (stream-car strm)) (newline)
               (body (stream-cdr strm) (- n 1)))))
  (body strm count))


(define (sign-change-detector cur-val last-val)
  (cond ((and (< last-val 0) (>= cur-val 0)) 1)
        ((and (>= last-val 0) (< cur-val 0)) -1)
        (else 0)))


(define zero-crossings
  (stream-map sign-change-detector sense-data (cons-stream 0 sense-data)))

(define sense-data
  (cons-stream 1 (cons-stream 2 (cons-stream 1.5 (cons-stream 1 (cons-stream 0.5 (cons-stream -0.1 (cons-stream -2 (cons-stream -3 (cons-stream -2 (cons-stream -0.5 (cons-stream 0.2 (cons-stream 3 (cons-stream 4 sense-data))))))))))))))

(display-stream sense-data 10)
(display-stream zero-crossings 10)


}}}


== 3.75.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))


(define (display-stream strm count)
  (define (body strm n)
    (if (< n 0) 'done
        (begin (display (stream-car strm)) (newline)
               (body (stream-cdr strm) (- n 1)))))
  (body strm count))




(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))

(define ones (cons-stream 1 ones))
(define integers (cons-stream 1 (add-streams ones integers)))



(define (sign-change-detector cur-val last-val)
  (cond ((and (< last-val 0) (>= cur-val 0)) 1)
        ((and (>= last-val 0) (< cur-val 0)) -1)
        (else 0)))

(define zero-crossings
  (stream-map sign-change-detector sense-data (cons-stream 0 sense-data)))

(define sense-data
  (cons-stream 1 (cons-stream 2 (cons-stream 1.5 (cons-stream 1 (cons-stream 0.5 (cons-stream -0.1 (cons-stream -2 (cons-stream -3 (cons-stream -2 (cons-stream -0.5 (cons-stream 0.2 (cons-stream 3 (cons-stream 4 sense-data))))))))))))))

(display-stream sense-data 10)
(display-stream zero-crossings 10)


(define (make-zero-crossings input-stream last-value last-avpt)
  (let ((avpt (/ (+ (stream-car input-stream) last-value) 2)))
    (cons-stream (sign-change-detector avpt last-avpt)
                 (make-zero-crossings (stream-cdr input-stream)
                                      (stream-car input-stream)
                                      avpt))))

(display-stream (make-zero-crossings sense-data 0 0) 10)
}}}


== 3.76.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))


(define (display-stream strm count)
  (define (body strm n)
    (if (< n 0) 'done
        (begin (display (stream-car strm)) (newline)
               (body (stream-cdr strm) (- n 1)))))
  (body strm count))




(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))

(define ones (cons-stream 1 ones))
(define integers (cons-stream 1 (add-streams ones integers)))



(define (sign-change-detector cur-val last-val)
  (cond ((and (< last-val 0) (>= cur-val 0)) 1)
        ((and (>= last-val 0) (< cur-val 0)) -1)
        (else 0)))

(define zero-crossings
  (stream-map sign-change-detector sense-data (cons-stream 0 sense-data)))

(define sense-data
  (cons-stream 1 (cons-stream 2 (cons-stream 1.5 (cons-stream 1 (cons-stream 0.5 (cons-stream -0.1 (cons-stream -2 (cons-stream -3 (cons-stream -2 (cons-stream -0.5 (cons-stream 0.2 (cons-stream 3 (cons-stream 4 sense-data))))))))))))))

(display-stream sense-data 10)
(display-stream zero-crossings 10)


(define (make-zero-crossings-old input-stream last-value last-avpt)
  (let ((avpt (/ (+ (stream-car input-stream) last-value) 2)))
    (cons-stream (sign-change-detector avpt last-avpt)
                 (make-zero-crossings-old (stream-cdr input-stream)
                                      (stream-car input-stream)
                                      avpt))))

(display-stream (make-zero-crossings-old sense-data 0 0) 13)


;; 3.76

(define (smooth strm)
  (let ((v1 (stream-car strm))
        (v2 (stream-car (stream-cdr strm))))
    (cons-stream (/ (+ v1 v2) 2)
                 (smooth (stream-cdr strm)))))

(display-stream (smooth sense-data) 10)

(define (make-zero-crossings smooth-proc input-stream)
  (stream-map sign-change-detector (smooth-proc sense-data) (cons-stream 0 (smooth-proc sense-data))))

(display-stream (make-zero-crossings smooth sense-data) 13)
}}}


== 3.77.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))


(define (display-stream strm count)
  (define (body strm n)
    (if (< n 0) 'done
        (begin (display (stream-car strm)) (newline)
               (body (stream-cdr strm) (- n 1)))))
  (body strm count))



(define ones (cons-stream 1 ones))
(define integers (cons-stream 1 (add-streams ones integers)))



(define (integral delayed-integrand initial-value dt)
  (cons-stream initial-value
               (let ((integrand (force delayed-integrand)))
                 (if (stream-null? integrand)
                     the-empty-stream
                     (integral (stream-cdr integrand)
                               (+ (* dt (stream-car integrand))
                                  initial-value)
                               dt)))))

(define (solve f y0 dt)
  (define (y) (integral (delay (dy)) y0 dt))
  (define (dy) (stream-map f (y)))
  (y))

(display-stream (solve (lambda (y) y) 1 0.001) 3)
;; guile> 1
;; ERROR: Stack overflow
;; ABORT: (stack-overflow)
;; guile> 


;; This is result from mit-scheme
;; 4 error> 1
;; ;Aborting!: maximum recursion depth exceeded


;; This works well, but solve procedure cannot work with guile.
}}}


== 3.81.scm ==


{{{
;; for Guile implementation
(define-macro (cons-stream a b)
  `(cons ,a (delay ,b)))

(define the-empty-stream '())
(define stream-null? null?)

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

;; (define (stream-map proc s)
;;   (if (stream-null? s)
;;       the-empty-stream
;;       (cons-stream (proc (stream-car s))
;;                    (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))


;; user native force of Guile
;; (define (force delayed-object)
;;   (delayed-object))

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define (stream-map proc . argstreams)
  (if (stream-null? (stream-car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc (map stream-cdr argstreams))))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))


(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))

(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define (mul-streams s1 s2)
  (stream-map * s1 s2))


(define (display-stream strm count)
  (define (body strm n)
    (if (< n 0) 'done
        (begin (display (stream-car strm)) (newline)
               (body (stream-cdr strm) (- n 1)))))
  (body strm count))



(define (stream-rand cmd numbers)
  (cond ((eq? cmd 'generate)
         
        ((eq? cmd 'reset)
         (stream-rand (cons-stream random-init (stream-map rand-update numbers))))
        (else
         (error "Unknown command"))))

(define random-numbers
  (cons-stream random-init
               (stream-map rand-update random-numbers)))

; example of rand-update
(define random-init-ex 1)
(define (rand-update-ex seed)
  (+ seed 3))


;; the first practice

;; (define (stream-rand rand-update last-num)
;;   (define (dispatch cmd)
;;     (cond ((eq? cmd 'generate)
;;            (cons-stream last-num
;;                         ((stream-rand rand-update (rand-update last-num)) 'generate)))
;;           ((eq? cmd 'reset)
;;            (lambda (new-number)
;;              (cons-stream new-number
;;                           ((stream-rand rand-update new-number) 'generate))))))
;;   dispatch)

;; (define my-rand
;;   (stream-rand rand-update-ex random-init-ex))
                                    
;; (display-stream (my-rand 'generate) 5)
;; (display-stream ((my-rand 'reset) 2) 5)
;; (display-stream ((my-rand 'reset) 3) 5)
;; guile> 2
;; 2
;; 5
;; 8
;; 11
;; 14
;; done
;; guile> 3
;; 3
;; 6
;; 9
;; 12
;; 15
;; done



;;--------------------------------------------------------------------
;; advance solution (other's solution on Net)

(define (stream-rand numbers)
  (define (dispatch cmd num)
    (cond ((eq? cmd 'g)
           (rand-update-ex num))
          (else
           cmd))) ; cmd is new initial number
  (cons-stream random-init-ex
               (stream-map dispatch numbers (stream-rand numbers)))) ; dispatch takes s0 and generated numbers


; Command generating random number is 'g
; normal number indicates new initial number
(define s-generate (cons-stream 'g s-generate))
(define s0 (cons-stream 'g
                        (cons-stream 'g
                                     (cons-stream 3
                                                  (cons-stream 'g
                                                               s-generate)))))

(display-stream (stream-rand s-generate) 10)
(display-stream (stream-rand s0) 10)
;; guile> 1
;; 4
;; 7
;; 10
;; 13
;; 16
;; 19
;; 22
;; 25
;; 28
;; 31
;; done
;; guile> 1
;; 4
;; 7
;; 3
;; 6
;; 9
;; 12
;; 15
;; 18
;; 21
;; 24
;; done
;; guile> 
;;--------------------------------------------------------------------
}}}


