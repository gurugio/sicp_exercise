== 4.1.scm ==


{{{

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           arguments
           (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure))))

(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) evn))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else
         (eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (eval (definition-value exp) env)
                    env)
  'ok)



;; 4.1

; test procedures
(define first-operand car)
(define rest-operands cdr)
(define no-operands? null?)
(define (eval a b) a)

(define (list-of-values-left-first exps env)
    (if (no-operands? exps)
        '()
        (let ((value (eval (first-operand exps) env)))
          (cons value
                (list-of-values-left-first (rest-operands exps) env)))))

(list-of-values-left-first '(a b c) '())
;;guile> (a b c)


(define (list-of-values-right-first exps env)
  (if (no-operands? exps)
      '()
       (append (list-of-values-right-first (rest-operands exps) env)
               (list (eval (first-operand exps) env)))))
       

(list-of-values-right-first '(a b c) '())
;;guile> (c b a)

      



}}}


== 4.2.scm ==


{{{

;--------------- eval - apply ------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           arguments
           (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure))))

(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) evn))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else
         (eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? cdr seq))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))



;; 4.2.a

; Run this modified eval with '(define x 3).
; The eval think define is procedure call,
; so (apply (eval define env) (list-of-values ...) is called.
; Then eval is called again and
; variable? is check the define is variable.
; But there is no variable that has name define.
; Finally eval cannot handle '(define x 3).
(define (eval exp env)
  (cond 
   ((application? exp)
    (display "operator:") (display (operator exp)) (display "-")
    (display "operand:") (display (operands exp)) (newline)
    (apply (eval (operator exp) env)
           (list-of-values (operands exp) env)))
   ((self-evaluating? exp) exp)
   ((variable? exp) 
    (display "lookup-variable:") (display exp) (newline)
    (lookup-variable-value exp env))
   ((quoted? exp) (text-of-quotation exp))
   ((assignment? exp) (eval-assignment exp env))
   ((definition? exp) (eval-definition exp env))
   ((if? exp) (eval-if exp env))
   ((lambda? exp)
    (make-procedure (lambda-parameters exp)
                    (lambda-body exp)
                    env))
   ((begin? exp)
    (eval-sequence (begin-actions exp) env))
   ((cond? exp) (eval (cond->if exp) env))
   (else
    (error "Unknown expression type -- EVAL" exp))))

(define test-env '())
(eval '(define x 3) '())


;; 4.2.b
; (call factorial 3)
(define (application? exp)
  (tagged-list? exp 'call))
(define (operator exp) (cadr exp))
(define (operands exp) (cddr exp))

(eval '(call define x 3) '())
}}}


== 4.3.scm ==


{{{
;----------------------------------------------------
;--------------- my-eval - my-apply------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (my-eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (my-eval (cond->if exp) env))
        ((application? exp)
         (my-apply (my-eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (my-apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           arguments
           (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure))))

(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (my-eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (my-eval (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (my-eval (first-exp exps) env))
        (else
         (my-eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (my-eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (my-eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


; compound procedure
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))

(define (compound-procedure? p)
  (tagged-list? p 'procedure))

(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))


; environment
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

; variables
(define (make-frame variables values)
  (cons variables values))

(define (frame-variables frame) (car frame))

(define (frame-values frame) (cdr frame))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))

(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
    

; setup running environment

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))


; setup primitive procedure

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        ;; add here more primitive procedures
        ))

(define (primitive-procedure-names)
  (map car 
       primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;----------------------------------------
;; Must call apply of native scheme implementation
;; I am using 'guile' and its apply is 'apply'
;; I changed produre names eval and apply
;; in this file into my-eval, my-apply,
;; so that they are not confused with native apply and eval.
(define apply-in-underlying-scheme apply)
;----------------------------------------


; read-eval-print loop
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (my-eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))

(define (announce-output string)
  (newline) (display string) (newline))


(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))

;---------- end of my-eval and my-apply --------------



;;----------------------------------
;; ch 3.3.3
;;----------------------------------
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))


(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
;;-------------------------------------------------------------


;; 4.3


;; 다음 것들은 태그에 따라 형태가 결정되므로 태크를 테이블에 넣으면
;; 테이블 검색만으로 형태를 결정할 수 있다.
;; 테이블에 태그와 태그에 따른 처리 프로시저를 넣고,
;; 표현식을 만날 때마다 테이블에서 태그를 이요해  프로시저를 꺼내서 쓴다.
;; assignment?, definitions?, quoted?, lambda?, begin? cond?, application?
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ;; data direct handler of each tag
        ((get 'proc (car exp))
         (display "eval->tag:") (display tag) (newline)
         ((get 'proc tag) (list exp env)))
        ;; Calling procedure has no tag
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))



; assignment
(define (handle-set! arg)
  (let ((exp (car arg))
        (env (cadr arg)))
    (display "handle-set!-> ") (display "exp:") (display exp) (display "  ")
    (display "env:") (display env) (newline)
    (eval-assignment exp env)))

; definition
(define (handle-define arg)
  (let ((exp (car arg))
        (env (cadr arg)))
    (display "handle-define-> ") (display "exp:") (display exp) (display "  ")
    (display "env:") (display env) (newline)
    (eval-definition exp env)))

; quoted
(define (handle-quote arg)
  (let ((exp (car arg))
        (env (cadr arg)))
    (display "handle-quote-> ") (display "exp:") (display exp) (display "  ")
    (display "env:") (display env) (newline)
    (text-of-assignment exp env)))

; lambda
(define (handle-lambda arg)
  (let ((exp (car arg))
        (env (cadr arg)))
    (display "handle-lambda-> ") (display "exp:") (display exp) (display "  ")
    (display "env:") (display env) (newline)
    (make-procedure (lambda-parameter exp)
                    (lambda-body exp)
                    (env))))

(define (handle-if arg)
  (let ((exp (car arg))
        (env (cadr arg)))
    (display "handle-if-> ") (display "exp:") (display exp) (display "  ")
    (display "env:") (display env) (newline)
    (eval-if exp env)))


(define (handle-begin arg)
  (let ((exp (car arg))
        (env (cadr arg)))
    (display "handle-begin-> ") (display "exp:") (display exp) (display "  ")
    (display "env:") (display env) (newline)
    (eval-sequence (begin-actions exp) env)))

(define (handle-cond arg)
  (let ((exp (car arg))
        (env (cadr arg)))
    (display "handle-cond-> ") (display "exp:") (display exp) (display "  ")
    (display "env:") (display env) (newline)
    (eval (cond->if exp) env)))

;; store procedure for each tag
(put 'proc 'set! handle-set!)
(put 'proc 'define handle-define)
(put 'proc 'quote handle-quote)
(put 'proc 'lambda handle-lambda)
(put 'proc 'if handle-if)
(put 'proc 'begin handle-begin)
(put 'proc 'cond handle-cond)

             

(define the-global-environment (setup-environment))
(driver-loop)

(define x 3)
x

;; result
;; ;;; M-Eval input:

;; ;;; M-Eval value:
;; ok

;; ;;; M-Eval input:

;; ;;; M-Eval value:
;; ok

;; ;;; M-Eval input:

;; ;;; M-Eval value:
;; 3

;; ;;; M-Eval input:
}}}


== 4.4.scm ==


{{{
;----------------------------------------------------
;--------------- my-eval - my-apply------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (my-eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (my-eval (cond->if exp) env))
        ((application? exp)
         (my-apply (my-eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (my-apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           arguments
           (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure))))

(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (my-eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (my-eval (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (my-eval (first-exp exps) env))
        (else
         (my-eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (my-eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (my-eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        ((eq? exp '#t) true)
        ((eq? exp '#f) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


; compound procedure
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))

(define (compound-procedure? p)
  (tagged-list? p 'procedure))

(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))


; environment
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

; variables
(define (make-frame variables values)
  (cons variables values))

(define (frame-variables frame) (car frame))

(define (frame-values frame) (cdr frame))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))

(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
    

; setup running environment

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))


; setup primitive procedure

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        ;; add here more primitive procedures
        (list '= =)
        (list '#t #t)
        ))

(define (primitive-procedure-names)
  (map car 
       primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;----------------------------------------
;; Must call apply of native scheme implementation
;; I am using 'guile' and its apply is 'apply'
;; I changed produre names eval and apply
;; in this file into my-eval, my-apply,
;; so that they are not confused with native apply and eval.
(define apply-in-underlying-scheme apply)
;----------------------------------------


; read-eval-print loop
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (my-eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))

(define (announce-output string)
  (newline) (display string) (newline))


(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))

;---------- end of my-eval and my-apply --------------

;; ex4.4

; string, number
; #t, #f should be self-evaluating.
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        ((eq? exp '#t) true)
        ((eq? exp '#f) true)
        (else false)))

(define (my-eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((or? exp) (eval-or exp env))
        ((and? exp) (eval-and exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) 
         (display exp)
         (my-eval (cond->if exp) env))
        ((application? exp)
         (apply (my-eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))


(define (or? exp)
  (tagged-list? exp 'or))

(define (and? exp)
  (tagged-list? exp 'and))

(define (eval-or exp env)
  (define (or->if exps)
    (if (null? exps)
        false
        (make-if (car exps) true (or->if (cdr exps)))))
  (my-eval (or->if (cdr exp)) env))

(define (eval-and exp env)
  (define (and->if exps)
    (if (null? exps)
        true
        (make-if (car exps) (and->if (cdr exps)) false)))
  (my-eval (and->if (cdr exp)) env))
  

(define the-global-environment (setup-environment))
(driver-loop)

(define x true)
(define y false)
(and x x)
(and x y)
(or x x)
(or x y)

;; result
;; ;;; M-Eval input:

;; ;;; M-Eval value:
;; ok

;; ;;; M-Eval input:

;; ;;; M-Eval value:
;; ok

;; ;;; M-Eval input:

;; ;;; M-Eval value:
;; #t

;; ;;; M-Eval input:

;; ;;; M-Eval value:
;; #f

;; ;;; M-Eval input:

;; ;;; M-Eval value:
;; #t

;; ;;; M-Eval input:

;; ;;; M-Eval value:
;; #t

;; ;;; M-Eval input:





}}}


== 4.5.scm ==


{{{

;----------------------------------------------------
;--------------- my-eval - my-apply------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (my-eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (my-eval (cond->if exp) env))
        ((application? exp)
         (my-apply (my-eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (my-apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           arguments
           (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure))))

(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (my-eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (my-eval (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (my-eval (first-exp exps) env))
        (else
         (my-eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (my-eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (my-eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        ((eq? exp '#t) true)
        ((eq? exp '#f) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


; compound procedure
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))

(define (compound-procedure? p)
  (tagged-list? p 'procedure))

(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))


; environment
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

; variables
(define (make-frame variables values)
  (cons variables values))

(define (frame-variables frame) (car frame))

(define (frame-values frame) (cdr frame))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))

(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
    

; setup running environment

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))


; setup primitive procedure

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        ;; add here more primitive procedures
        (list '= =)
        (list '#t #t)
        (list 'assoc assoc)
        (list 'cadr cadr)
        ))

(define (primitive-procedure-names)
  (map car 
       primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;----------------------------------------
;; Must call apply of native scheme implementation
;; I am using 'guile' and its apply is 'apply'
;; I changed produre names eval and apply
;; in this file into my-eval, my-apply,
;; so that they are not confused with native apply and eval.
(define apply-in-underlying-scheme apply)
;----------------------------------------


; read-eval-print loop
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (my-eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))

(define (announce-output string)
  (newline) (display string) (newline))


(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))

;---------- end of my-eval and my-apply --------------

;; ex4.5


(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (if (tagged-list? (cond-actions first) '=>)
                (let ((proc (cadr (cond-actions first))))
                  (display (list proc (cond-predicate first)))
                  (list proc (cond-predicate first)))
                (make-if (cond-predicate first)
                         (sequence->exp (cond-actions first))
                         (expand-clauses rest)))))))


(define the-global-environment (setup-environment))
(driver-loop)

(cond ((assoc 'b '((a 1) (b 2))) => cadr)
      (else false))

;; result
;; ;;; M-Eval input:
;; (cadr (assoc (quote b) (quote ((a 1) (b 2)))))
;; ;;; M-Eval value:
;; 2
}}}


== 4.6.scm ==


{{{

;--------------- eval - apply ------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           arguments
           (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure))))

(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else
         (eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


;; ex4.6

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((let? exp) 
         (display (let->combination exp))
         (eval (let->combination exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))


(define (let? exp)
  (tagged-list? exp 'let))

(define (let->combination exp)
  (let ((args (cadr exp))
        (body (cddr exp)))
    (let ((vars (map car args))
          (exps (map cadr args)))
      (cons (make-lambda vars body) exps))))
      

(let->combination '(let ((a 1) (b 2) (c 3)) (+ a b c)))
;result -> ((lambda (a b c) (+ a b c)) 1 2 3)

(eval '(let ((a 1) (b 2) (c 3))
         (+ a b c))
      '())
;; result ->

;; guile> guile> ((lambda (a b c) (+ a b c)) 1 2 3)
;; Backtrace:
;; In standard input:
;;  714: 0* [eval (let ((a 1) (b 2) (c 3)) (+ a b c)) ()]
;;  692: 1  (cond (# exp) (# #) (# #) ...)
;;    ...
;;  709: 2  [apply ...
;;  709: 3*  [eval (lambda (a b c) (+ a b c)) ()]
;;  692: 4   (cond (# exp) (# #) (# #) ...)
;;  699: 5   (make-procedure (lambda-parameters exp) (lambda-body exp) env)

;; standard input:699:10: In expression (make-procedure (lambda-parameters exp) (lambda-body exp) ...):
;; standard input:699:10: Unbound variable: make-procedure
;; ABORT: (unbound-variable)
;; guile> 
}}}


== 4.7.scm ==


{{{

;--------------- eval - apply ------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           arguments
           (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure))))

(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else
         (eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


;; ex4.7

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((let? exp) 
         (display (let->combination exp))
         (eval (let->combination exp) env))
        ((let*? exp)
         (display (let*->nested-lets exp))
         (eval (let*->nested-lets exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))


(define (let? exp)
  (tagged-list? exp 'let))

(define (let->combination exp)
  (let ((args (cadr exp))
        (body (cddr exp)))
    (let ((vars (map car args))
          (exps (map cadr args)))
      (cons (make-lambda vars body) exps))))
      
(let->combination '(let ((a 3)) (display a)))

(define (let*? exp)
  (tagged-list? exp 'let*))

(define (let*->nested-lets exp)
  (define (let*->nested-lets-core args body)
    (if (null? args)
        body
        (let->combination (list 'let (list (car args))
                                (let*->nested-lets-core (cdr args) body)))))
  (let*->nested-lets-core (cadr exp) (caddr exp)))

(let*->nested-lets-core '((x 3) (y 2) (z 1)) '(* z x))

(let*->nested-lets '(let* ((x 3)
                           (y (+ x 2))
                           (z (+ x y 5)))
                      (* z x)))
;; result
;; guile> ((lambda (x) ((lambda (y) ((lambda (z) (* z x)) (+ x y 5))) (+ x 2))) 3)

(eval '(let* ((x 3)
              (y (+ x 2))
              (z (+ x y 5)))
         (* z x))
      '())

; result
;; guile> ((lambda (x) ((lambda (y) ((lambda (z) (* z x)) (+ x y 5))) (+ x 2))) 3)
;; Backtrace:
;; In standard input:
;;  402: 0* [eval (let* ((x 3) (y #) (z #)) (* z x)) ()]
;;  377: 1  (cond (# exp) (# #) (# #) ...)
;;    ...
;;  397: 2  [apply ...
;;  397: 3*  [eval (lambda (x) ((lambda # #) (+ x 2))) ()]
;;  377: 4   (cond (# exp) (# #) (# #) ...)
;;  384: 5   (make-procedure (lambda-parameters exp) (lambda-body exp) env)

;; standard input:384:10: In expression (make-procedure (lambda-parameters exp) (lambda-body exp) ...):
;; standard input:384:10: Unbound variable: make-procedure
;; ABORT: (unbound-variable)
;; guile> 
}}}


== 4.8.scm ==


{{{

;--------------- eval - apply ------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           arguments
           (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure))))

(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else
         (eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


;; ex4.8

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((let? exp) 
         (display (let->combination exp))
         (eval (let->combination exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))


(define (let? exp)
  (tagged-list? exp 'let))

(define (let->combination exp)
  (if (pair? (cadr exp))
      ;; normal let syntax
      (let ((args (cadr exp))
            (body (cddr exp)))
        (let ((vars (map car args))
              (exps (map cadr args)))
          (cons (make-lambda vars body) exps)))
      ;; procedure definition with let
      (let ((var (cadr exp))
            (bindings (caddr exp))
            (body (cadddr exp)))
        (let ((var-args (map car bindings))
              (exps (map cadr bindings)))
          ;; (display var) (display " -- ")
          ;; (display bindings) (display " -- ")
          ;; (display body) (newline)
          (sequence->exp (list (cons (list 'define (cons var var-args) body) exps)
                               (cons var exps)))))))

(let->combination '(let fib-iter ((a 1)
                                  (b 0)
                                  (count n))
                     (if (= count 0)
                         b
                         (fib-iter (+ a b) a (- count 1)))))


;result
;(begin ((define (fib-iter a b count) (if (= count 0) b (fib-iter (+ a b) a (- count 1)))) 1 0 n) (fib-iter 1 0 n))





}}}


== 4.9.scm ==


{{{

;--------------- eval - apply ------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           arguments
           (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure))))

(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else
         (eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


;; ex4.9
; make (while <condition> <body>)

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((let? exp) 
         (display (let->combination exp))
         (eval (let->combination exp) env))
        ((while? exp)
         (eval-while exp env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))


(define (let? exp)
  (tagged-list? exp 'let))

(define (let->combination exp)
  (if (pair? (cadr exp))
      ;; normal let syntax
      (let ((args (cadr exp))
            (body (cddr exp)))
        (let ((vars (map car args))
              (exps (map cadr args)))
          (cons (make-lambda vars body) exps)))
      ;; procedure definition with let
      (let ((var (cadr exp))
            (bindings (caddr exp))
            (body (cadddr exp)))
        (let ((var-args (map car bindings))
              (exps (map cadr bindings)))
          ;; (display var) (display " -- ")
          ;; (display bindings) (display " -- ")
          ;; (display body) (newline)
          (sequence->exp (list (cons (list 'define (cons var var-args) body) exps)
                               (cons var exps)))))))

(define (while? exp)
  (tagged-list? exp 'while))

(define (while-predicate exp)
  (cadr exp))
(define (while-body exp)
  (caddr exp))

(define (eval-while exp env)
  (display "condition:") (display (while-predicate exp)) (display " -- ")
  (display "body:") (display (while-body exp)) (newline)
  (if (true? (eval (while-predicate exp) env))
      (begin
        (eval (while-body exp) env)
        (eval exp env))))

(eval-while '(while (= 3 3) (display "OK")) '())


}}}


== 4.10.scm ==


{{{
;----------------------------------------------------
;--------------- my-eval - my-apply------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (my-eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (my-eval (cond->if exp) env))
        ((application? exp)
         (my-apply (my-eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (my-apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           arguments
           (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure))))

(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (my-eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (my-eval (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (my-eval (first-exp exps) env))
        (else
         (my-eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (my-eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (my-eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


; compound procedure
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))

(define (compound-procedure? p)
  (tagged-list? p 'procedure))

(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))


; environment
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

; variables
(define (make-frame variables values)
  (cons variables values))

(define (frame-variables frame) (car frame))

(define (frame-values frame) (cdr frame))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))

(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
    

; setup running environment

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))


; setup primitive procedure

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        ;; add here more primitive procedures
        ))

(define (primitive-procedure-names)
  (map car 
       primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;----------------------------------------
;; Must call apply of native scheme implementation
;; I am using 'guile' and its apply is 'apply'
;; I changed produre names eval and apply
;; in this file into my-eval, my-apply,
;; so that they are not confused with native apply and eval.
(define apply-in-underlying-scheme apply)
;----------------------------------------


; read-eval-print loop
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (my-eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))

(define (announce-output string)
  (newline) (display string) (newline))


(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))

;---------- end of my-eval and my-apply --------------

(define the-global-environment (setup-environment))
(driver-loop)


;; test R-E-P
(define (append x y)
  (if (null? x)
      y
      (cons (car x)
            (append (cdr x) y))))

(append '(a b) '(1 2))
(car (append '(a b) '(1 2)))
}}}


== 4.11.scm ==


{{{
;----------------------------------------------------
;--------------- my-eval - my-apply------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (my-eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (my-eval (cond->if exp) env))
        ((application? exp)
         (my-apply (my-eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (my-apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           arguments
           (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure))))

(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (my-eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (my-eval (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (my-eval (first-exp exps) env))
        (else
         (my-eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (my-eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (my-eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


; compound procedure
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))

(define (compound-procedure? p)
  (tagged-list? p 'procedure))

(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))


; environment
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

; variables
(define (make-frame variables values)
  (cons variables values))

(define (frame-variables frame) (car frame))

(define (frame-values frame) (cdr frame))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))

(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
    

; setup running environment

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))


; setup primitive procedure

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        ;; add here more primitive procedures
        ))

(define (primitive-procedure-names)
  (map car 
       primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;----------------------------------------
;; Must call apply of native scheme implementation
;; I am using 'guile' and its apply is 'apply'
;; I changed produre names eval and apply
;; in this file into my-eval, my-apply,
;; so that they are not confused with native apply and eval.
(define apply-in-underlying-scheme apply)
;----------------------------------------


; read-eval-print loop
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (my-eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))

(define (announce-output string)
  (newline) (display string) (newline))


(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))

;---------- end of my-eval and my-apply --------------

; variables

(define (make-frame variables values)
;  (cons variables values))
  (if (not (null? variables))
      (cons (cons (car variables) (car values))
            (make-frame (cdr variables) (cdr values)))
      '()))

(define (frame-variables frame)
  ;(car frame))
  (map car frame))

(define (frame-values frame)
 ;(cdr frame))
  (map cdr frame))

(define (add-binding-to-frame! var val frame)
  ;; (set-car! frame (cons var (car frame)))
  ;; (set-cdr! frame (cons val (cdr frame))))
  (let ((new-set (cons var val)))
    (set-cdr! frame (cons new-set (cdr frame)))))

(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
;             (set-car! vals val))
             (set-cdr! var val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             ;(set-car! vals val))
             (set-cdr! var val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
    

;;-------------- test ----------------------
(define the-global-environment (setup-environment))
(driver-loop)


;; test R-E-P
(define (append x y)
  (if (null? x)
      y
      (cons (car x)
            (append (cdr x) y))))

(append '(a b) '(1 2))
(car (append '(a b) '(1 2)))


;; result
;; guile> the-global-environment
;; (((car primitive #<primitive-procedure car>) (false . #f) (true . #t) (cdr primitive #<primitive-procedure cdr>) (cons primitive #<primitive-procedure cons>) (null? primitive #<primitive-procedure null?>)))
;; guile> 

;; ;;; M-Eval input:

;; ;;; M-Eval value:
;; ok

;; ;;; M-Eval input:

;; ;;; M-Eval value:
;; (a b 1 2)

;; ;;; M-Eval input:

;; ;;; M-Eval value:
;; a

;; ;;; M-Eval input:
}}}


== 4.12.scm ==


{{{
;----------------------------------------------------
;--------------- my-eval - my-apply------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (my-eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (my-eval (cond->if exp) env))
        ((application? exp)
         (my-apply (my-eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (my-apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           arguments
           (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure))))

(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (my-eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (my-eval (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (my-eval (first-exp exps) env))
        (else
         (my-eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (my-eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (my-eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        ((eq? exp '#t) true)
        ((eq? exp '#f) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


; compound procedure
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))

(define (compound-procedure? p)
  (tagged-list? p 'procedure))

(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))


; environment
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

; variables
(define (make-frame variables values)
  (cons variables values))

(define (frame-variables frame) (car frame))

(define (frame-values frame) (cdr frame))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))

(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
    

; setup running environment

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))


; setup primitive procedure

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        ;; add here more primitive procedures
        ))

(define (primitive-procedure-names)
  (map car 
       primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;----------------------------------------
;; Must call apply of native scheme implementation
;; I am using 'guile' and its apply is 'apply'
;; I changed produre names eval and apply
;; in this file into my-eval, my-apply,
;; so that they are not confused with native apply and eval.
(define apply-in-underlying-scheme apply)
;----------------------------------------


; read-eval-print loop
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (my-eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))

(define (announce-output string)
  (newline) (display string) (newline))


(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))

;---------- end of my-eval and my-apply --------------


; ex4.12

(define (abstract-scan vars vals var)
  (display var) (display " -- ") (display vars) (newline)
  (cond ((null? vars)
         '())
        ((eq? var (car vars))
         vals)
        (else (abstract-scan (cdr vars) (cdr vals) var))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (let ((found-vals (abstract-scan (frame-variables frame)
                                           (frame-values frame)
                                           var)))
            (if (not (null? found-vals))
                (car found-vals)
                (env-loop (enclosing-environment env)))))))
  (env-loop env))

(lookup-variable-value 'false the-global-environment)

(define (set-variable-value! var val env)
  (define (env-loop env)
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (let ((found-vals (abstract-scan (frame-variables frame)
                                           (frame-values frame)
                                           var)))
            (if (not (null? found-vals))
                (set-car! found-vals val)
                (env-loop (enclosing-environment env)))))))
  (env-loop env))

(set-variable-value! 'false 'false the-global-environment)
(display the-global-environment)
(set-variable-value! 'false '#f the-global-environment)

(set-variable-value! 'null? 'test the-global-environment)
(display the-global-environment)
(set-variable-value! 'null? (list 'primitive null?) the-global-environment)


(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (let ((found-vals (abstract-scan (frame-variables frame)
                                     (frame-values frame)
                                     var)))
      (if (not (null? found-vals))
          (set-car! found-vals val)
          (add-binding-to-frame! var val frame)))))

(define-variable! 'cadr (list 'primitive cadr) the-global-environment)
(display the-global-environment)    


(define the-global-environment (setup-environment))
(driver-loop)


;; result
;; ;;; M-Eval input:
;; (cadr '(a b c))
;; cadr -- (cadr false true car cdr cons null?)

;; ;;; M-Eval value:
;; b

;; ;;; M-Eval input:
}}}


== 4.13.scm ==


{{{
;----------------------------------------------------
;--------------- my-eval - my-apply------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (my-eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (my-eval (cond->if exp) env))
        ((application? exp)
         (my-apply (my-eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (my-apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           arguments
           (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure))))

(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (my-eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (my-eval (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (my-eval (first-exp exps) env))
        (else
         (my-eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (my-eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (my-eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        ((eq? exp '#t) true)
        ((eq? exp '#f) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


; compound procedure
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))

(define (compound-procedure? p)
  (tagged-list? p 'procedure))

(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))


; environment
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

; variables
(define (make-frame variables values)
  (cons variables values))

(define (frame-variables frame) (car frame))

(define (frame-values frame) (cdr frame))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))

(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
    

; setup running environment

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))


; setup primitive procedure

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        ;; add here more primitive procedures
        ))

(define (primitive-procedure-names)
  (map car 
       primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;----------------------------------------
;; Must call apply of native scheme implementation
;; I am using 'guile' and its apply is 'apply'
;; I changed produre names eval and apply
;; in this file into my-eval, my-apply,
;; so that they are not confused with native apply and eval.
(define apply-in-underlying-scheme apply)
;----------------------------------------


; read-eval-print loop
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (my-eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))

(define (announce-output string)
  (newline) (display string) (newline))


(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))

;---------- end of my-eval and my-apply --------------


; ex4.13

(define (unbound? exp)
  (tagged-list? exp 'unbound))

(define (eval-unbound exp env)
  (make-unbound! (cadr exp) env))

(define (make-unbound! var env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             'done)
            ((eq? var (car vars))
             (set-car! vars '())
             (set-car! vals '()))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
             
(define (my-eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        
        ((unbound? exp) (eval-unbound exp env))

        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (my-eval (cond->if exp) env))
        ((application? exp)
         (my-apply (my-eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define the-global-environment (setup-environment))
(driver-loop)


; result
;; ;;; M-Eval input:
;; (define x 3)

;; ;;; M-Eval value:
;; ok

;; ;;; M-Eval input:
;; (unbound x)

;; ;;; M-Eval value:
;; #<unspecified>

;; ;;; M-Eval input:
;; x

;; Backtrace:
;; In standard input:
;; 2350: 0* [driver-loop]
;; 2287: 1  [driver-loop]
;; 2287: 2  [driver-loop]
;; 2283: 3* (let* ((input #)) (let* (#) (announce-output output-prompt) ...))
;; 2284: 4  (let* ((output #)) (announce-output output-prompt) (user-print output))
;; 2284: 5* [my-eval x (((() false true ...) () #f ...))]
;; 2327: 6  (cond (# exp) (# #) (# #) ...)
;;    ...
;; 2196: 7  [error "Unbound variable" x]

;; standard input:2196:9: In procedure error in expression (error "Unbound variable" var):
;; standard input:2196:9: Unbound variable x
;; ABORT: (misc-error)
;; guile> 
}}}


== 4.14.scm ==


{{{
;----------------------------------------------------
;--------------- my-eval - my-apply------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (my-eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (my-eval (cond->if exp) env))
        ((application? exp)
         (my-apply (my-eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (my-apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           arguments
           (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure))))

(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (my-eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (my-eval (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (my-eval (first-exp exps) env))
        (else
         (my-eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (my-eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (my-eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        ((eq? exp '#t) true)
        ((eq? exp '#f) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


; compound procedure
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))

(define (compound-procedure? p)
  (tagged-list? p 'procedure))

(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))


; environment
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

; variables
(define (make-frame variables values)
  (cons variables values))

(define (frame-variables frame) (car frame))

(define (frame-values frame) (cdr frame))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))

(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
    

; setup running environment

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))


; setup primitive procedure

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        ;; add here more primitive procedures
        ))

(define (primitive-procedure-names)
  (map car 
       primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;----------------------------------------
;; Must call apply of native scheme implementation
;; I am using 'guile' and its apply is 'apply'
;; I changed produre names eval and apply
;; in this file into my-eval, my-apply,
;; so that they are not confused with native apply and eval.
(define apply-in-underlying-scheme apply)
;----------------------------------------


; read-eval-print loop
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (my-eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))

(define (announce-output string)
  (newline) (display string) (newline))


(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))

;---------- end of my-eval and my-apply --------------


; ex4.14

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        ;; add here more primitive procedures
        (list 'map map)
        ))

(define (primitive-procedure-names)
  (map car 
       primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  (if (eq? (cadr proc) map)
      (begin
        (display "proc:") (display proc) (display " -- ")
        (display "args:") (display (cadr (car args))) (display " ")
        (display (cadr args)) (newline)
        (apply-in-underlying-scheme
         (primitive-implementation proc) (list (cadr (car args))
                                               (cadr args))))
      (apply-in-underlying-scheme
       (primitive-implementation proc) args)))


(define the-global-environment (setup-environment))
(driver-loop)

(map car '((a 1) (b 2) (c 3)))


;; result before fix
;; The second argument must be car, but tag primitive is attached
;; so that the second argument is '(primitive car).

;; ;;; M-Eval input:
;; proc:(primitive #<primitive-generic map>) -- args:((primitive #<primitive-procedure car>) ((a 1) (b 2) (c 3)))

;; Backtrace:
;; In standard input:
;;  781: 0* [driver-loop]
;;  735: 1* (let* ((input #)) (let* (#) (announce-output output-prompt) ...))
;;  736: 2  (let* ((output #)) (announce-output output-prompt) (user-print output))
;;  736: 3* [my-eval (map car (quote (# # #))) (((false true car ...) #f #t ...))]
;;  761: 4  (cond (# exp) (# #) (# #) ...)
;; In unknown file:
;;    ...
;;    ?: 5  [map]
;;    ?: 6* [map {(primitive #<primitive-procedure car>)} ((a 1) (b 2) (c 3))]

;; ERROR: In procedure map:
;; ERROR: Wrong type argument in position 1: (primitive #<primitive-procedure car>)
;; ABORT: (wrong-type-arg)

;; result after fix -> tag is deleted
;; ;; ;;; M-Eval input:
;; ;;; M-Eval input:
;; proc:(primitive #<primitive-generic map>) -- args:#<primitive-procedure car> ((a 1) (b 2) (c 3))

;; ;;; M-Eval value:
;; (a b c)

;; ;;; M-Eval input:
}}}


== 4.15.scm ==


{{{

(define (run-forever) (run-forever))

(define (try p)
  (if (halts? p p)
      (run-forever)
      'halted))

(try try)

1. (try try)의 실행이 멈추는 경우:
 - (try try)의 실행이 멈추기 위해서는 (halts? try try)가 거짓이 되서 'halted가 반환되야 함
 - (halts? try try)가 거짓이 되기 위해서는 halts?가 (try try)의 실행이 멈추지 않는다고 판단해야 함
 - (try try)의 실행이 멈추지만 halts?는 (try try)의 실행이 멈추지 않는다고 판단함
 -> halts? 실패

2. (try try)의 실행이 멈추지 않는 경우:
 - (try try)의 실행이 멈치지 않기 위해서는 (halts? try try)가 참이 되서 (run-forever)가 실행되야 함
 - (halts? try try)가 참이 되기 위해서는 halts?가 (try try)의 실행이 멈춘다고 판단해야 함
 - (try try)의 실행이 멈추지 않지만 halts?는 실행이 멈춘다고 판단함
 -> halts? 실패

result: (try try)의 실행 결과가 어떤 것이든 halts?는 정의와 어긋나게 동작함
}}}


== 4.16.scm ==


{{{
;----------------------------------------------------
;--------------- my-eval - my-apply------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (my-eval exp env)
  (display "my-eval:") (display exp) (newline)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (my-eval (cond->if exp) env))

        ;; add by ex4.6
        ((let? exp) 
         (display (let->combination exp))
         (my-eval (let->combination exp) env))

        ((application? exp)
         (my-apply (my-eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (my-apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           arguments
           (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure arguments))))

(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (my-eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (my-eval (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (my-eval (first-exp exps) env))
        (else
         (my-eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                       (my-eval (assignment-value exp) env)
                       env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (my-eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        ((eq? exp '#t) true)
        ((eq? exp '#f) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


; compound procedure
(define (make-procedure parameters body env)
;  (list 'procedure parameters body env))
  (list 'procedure parameters (scan-out-defines body) env))

(define (compound-procedure? p)
  (tagged-list? p 'procedure))

(define (procedure-parameters p) (cadr p))
(define (procedure-body p) 
  (caddr p))
(define (procedure-environment p) (cadddr p))

; let
(define (let? exp)
  (tagged-list? exp 'let))

(define (let->combination exp)
  (let ((args (cadr exp))
        (body (cddr exp)))
    (let ((vars (map car args))
          (exps (map cadr args)))
      (cons (make-lambda vars body) exps))))
      

; environment
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

; variables
(define (make-frame variables values)
  (cons variables values))

(define (frame-variables frame) (car frame))

(define (frame-values frame) (cdr frame))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))

(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))

            ;; ex4.16.a
            ((eq? var (car vars))
             (if (eq? (car vals) '*unassigned*)
                 (error "Unbound variable" var)
                 (car vals)))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
    

; setup running environment

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))


; setup primitive procedure

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        ;; add here more primitive procedures
        (list '+ +)
        (list '* *)
        (list '- -)
        ))

(define (primitive-procedure-names)
  (map car 
       primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;----------------------------------------
;; Must call apply of native scheme implementation
;; I am using 'guile' and its apply is 'apply'
;; I changed produre names eval and apply
;; in this file into my-eval, my-apply,
;; so that they are not confused with native apply and eval.
(define apply-in-underlying-scheme apply)
;----------------------------------------


; read-eval-print loop
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (my-eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))

(define (announce-output string)
  (newline) (display string) (newline))


(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))



;; ex4.16.b
(define (scan-out-defines exps)
  (display "scan-out-defines gets:") (display exps) (newline)
  (let ((vars '())
        (vals '()))
    (define (extract-defines exps)
      (if (not (null? exps))
          (if (tagged-list? (car exps) 'define)
              (begin
                (set! vars (append vars (list (cadr (car exps)))))
                (set! vals (append vals (list (caddr (car exps)))))
                (extract-defines (cdr exps)))
              (extract-defines (cdr exps)))
          '()))
    (define (make-args vars)
      (if (not (null? vars))
          (cons (list (car vars) (quote '*unassigned*))
                (make-args (cdr vars)))
          '()))
    (define (make-sets vars vals)
      (if (not (null? vars))
          (cons (list 'set! (car vars) (car vals))
                (make-sets (cdr vars) (cdr vals)))
          '()))
    (define (extract-no-definition-body exps)
      (if (not (null? exps))
          (if (tagged-list? (car exps) 'define)
              (extract-no-definition-body (cdr exps))
              (cons (car exps)
                    (extract-no-definition-body (cdr exps))))
          '()))

    (extract-defines exps)
    (display "vars:") (display vars) (newline)
    (if (null? vars)
        exps
        (list (append (list 'let (make-args vars))
                      (make-sets vars vals)
                      (extract-no-definition-body exps))))))
    

;; test scan-out-defines
(scan-out-defines '((define u 11) (define v 22) (+ u v) (* v u)))
(scan-out-defines '(+ u v))



(define the-global-environment (setup-environment))
(driver-loop)

(define u 1)
(define v 3)
(define (ddd) (+ u v))
(ddd)

(let ((a 3)
      (b 4))
  (+ a b))

(define (ddd) (define u 11) (define v 22) (+ u v) (* v u))
(ddd)


;; test result

;; guile> scan-out-defines gets:((define u 11) (define v 22) (+ u v) (* v u))
;; vars:(u v)
;; ((let ((u (quote *unassigned*)) (v (quote *unassigned*))) (set! u 11) (set! v 22) (+ u v) (* v u)))
;; guile> scan-out-defines gets:(+ u v)
;; vars:()
;; (+ u v)
;; guile> guile> 

;; ;;; M-Eval input:
;; my-eval:(define u 1)
;; my-eval:1

;; ;;; M-Eval value:
;; ok

;; ;;; M-Eval input:
;; my-eval:(define v 3)
;; my-eval:3

;; ;;; M-Eval value:
;; ok

;; ;;; M-Eval input:
;; my-eval:(define (ddd) (+ u v))
;; my-eval:(lambda () (+ u v))
;; scan-out-defines gets:((+ u v))
;; vars:()

;; ;;; M-Eval value:
;; ok

;; ;;; M-Eval input:
;; my-eval:(ddd)
;; my-eval:ddd
;; my-eval:(+ u v)
;; my-eval:+
;; my-eval:u
;; my-eval:v

;; ;;; M-Eval value:
;; 4

;; ;;; M-Eval input:
;; my-eval:(let ((a 3) (b 4)) (+ a b))
;; ((lambda (a b) (+ a b)) 3 4)my-eval:((lambda (a b) (+ a b)) 3 4)
;; my-eval:(lambda (a b) (+ a b))
;; scan-out-defines gets:((+ a b))
;; vars:()
;; my-eval:3
;; my-eval:4
;; my-eval:(+ a b)
;; my-eval:+
;; my-eval:a
;; my-eval:b

;; ;;; M-Eval value:
;; 7

;; ;;; M-Eval input:
;; my-eval:(define (ddd) (define u 11) (define v 22) (+ u v) (* v u))
;; my-eval:(lambda () (define u 11) (define v 22) (+ u v) (* v u))
;; scan-out-defines gets:((define u 11) (define v 22) (+ u v) (* v u))
;; vars:(u v)

;; ;;; M-Eval value:
;; ok

;; ;;; M-Eval input:
;; my-eval:(ddd)
;; my-eval:ddd
;; my-eval:(let ((u (quote *unassigned*)) (v (quote *unassigned*))) (set! u 11) (set! v 22) (+ u v) (* v u))
;; ((lambda (u v) (set! u 11) (set! v 22) (+ u v) (* v u)) (quote *unassigned*) (quote *unassigned*))my-eval:((lambda (u v) (set! u 11) (set! v 22) (+ u v) (* v u)) (quote *unassigned*) (quote *unassigned*))
;; my-eval:(lambda (u v) (set! u 11) (set! v 22) (+ u v) (* v u))
;; scan-out-defines gets:((set! u 11) (set! v 22) (+ u v) (* v u))
;; vars:()
;; my-eval:(quote *unassigned*)
;; my-eval:(quote *unassigned*)
;; my-eval:(set! u 11)
;; my-eval:11
;; my-eval:(set! v 22)
;; my-eval:22
;; my-eval:(+ u v)
;; my-eval:+
;; my-eval:u
;; my-eval:v
;; my-eval:(* v u)
;; my-eval:*
;; my-eval:v
;; my-eval:u

;; ;;; M-Eval value:
;; 242

;; ;;; M-Eval input:

}}}


== 4.18.scm ==


{{{
;----------------------------------------------------
;--------------- my-eval - my-apply------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (my-eval exp env)
  (display "my-eval:") (display exp) (newline)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (my-eval (cond->if exp) env))

        ;; add by ex4.6
        ((let? exp) 
         (display (let->combination exp))
         (my-eval (let->combination exp) env))

        ((application? exp)
         (my-apply (my-eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (my-apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           arguments
           (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure arguments))))

(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (my-eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (my-eval (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (my-eval (first-exp exps) env))
        (else
         (my-eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                       (my-eval (assignment-value exp) env)
                       env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (my-eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        ((eq? exp '#t) true)
        ((eq? exp '#f) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


; compound procedure
(define (make-procedure parameters body env)
;  (list 'procedure parameters body env))
  (list 'procedure parameters (scan-out-defines body) env))

(define (compound-procedure? p)
  (tagged-list? p 'procedure))

(define (procedure-parameters p) (cadr p))
(define (procedure-body p) 
  (caddr p))
(define (procedure-environment p) (cadddr p))

; let
(define (let? exp)
  (tagged-list? exp 'let))

(define (let->combination exp)
  (let ((args (cadr exp))
        (body (cddr exp)))
    (let ((vars (map car args))
          (exps (map cadr args)))
      (cons (make-lambda vars body) exps))))
      

; environment
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

; variables
(define (make-frame variables values)
  (cons variables values))

(define (frame-variables frame) (car frame))

(define (frame-values frame) (cdr frame))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))

(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))

            ;; ex4.16.a
            ((eq? var (car vars))
             (if (eq? (car vals) '*unassigned*)
                 (error "Unbound variable" var)
                 (car vals)))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
    

; setup running environment

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))


; setup primitive procedure

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        ;; add here more primitive procedures
        (list '+ +)
        (list '* *)
        (list '- -)
        ))

(define (primitive-procedure-names)
  (map car 
       primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;----------------------------------------
;; Must call apply of native scheme implementation
;; I am using 'guile' and its apply is 'apply'
;; I changed produre names eval and apply
;; in this file into my-eval, my-apply,
;; so that they are not confused with native apply and eval.
(define apply-in-underlying-scheme apply)
;----------------------------------------


; read-eval-print loop
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (my-eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))

(define (announce-output string)
  (newline) (display string) (newline))


(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))


(define (scan-out-defines exps)
  (display "scan-out-defines gets:") (display exps) (newline)
  (let ((vars '())
        (vals '()))
    (define (extract-defines exps)
      (if (not (null? exps))
          (if (tagged-list? (car exps) 'define)
              (begin
                (set! vars (append vars (list (cadr (car exps)))))
                (set! vals (append vals (list (caddr (car exps)))))
                (extract-defines (cdr exps)))
              (extract-defines (cdr exps)))
          '()))
    (define (make-args vars)
      (if (not (null? vars))
          (cons (list (car vars) (quote '*unassigned*))
                (make-args (cdr vars)))
          '()))
    (define (make-sets vars vals)
      (if (not (null? vars))
          (cons (list 'set! (car vars) (car vals))
                (make-sets (cdr vars) (cdr vals)))
          '()))
    (define (extract-no-definition-body exps)
      (if (not (null? exps))
          (if (tagged-list? (car exps) 'define)
              (extract-no-definition-body (cdr exps))
              (cons (car exps)
                    (extract-no-definition-body (cdr exps))))
          '()))

    (extract-defines exps)

    (display "vars:") (display vars) (newline)

    (if (null? vars)
        exps
        (list (list 'let
                    (make-args vars)
                    (cons 'let
                          (cons (list (list 'a (car vals)) (list 'b (cadr vals)))
                                (make-sets vars '(a b)))))))))
  

;; test scan-out-defines
(scan-out-defines '((define u 11) (define v 22) (+ u v) (* v u)))
(scan-out-defines '(+ u v))



(define the-global-environment (setup-environment))
(driver-loop)

(define (ddd) (define u 11) (define v 22) (+ u v) (* v u))
(ddd)


;; (define (solve f y0 dt)
;;   (define y (integral (delay dy) y0 dt))
;;   (define dy (stream-map f y))
;;   y)

;; translated result:
;; (compound-procedure (f y0 dt)
;;                     ((let ((y (quote *unassigned*))
;;                            (dy (quote *unassigned*)))
;;                        (let ((a (integral (delay dy) y0 dt))
;;                              (b (stream-map f y)))
;;                          (set! y a)
;;                          (set! dy b))))
;;                     <procedure-env>)

;; When b is evaluated, y is just *unassigned* value. Therefore b cannot be evaluated.


}}}


== 4.22.scm ==


{{{
;----------------------------------------------------
;--------------- my-eval - my-apply------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (my-eval exp env)
  ((my-analyze exp) env))

(define (my-analyze exp)

  (cond ((self-evaluating? exp)
         (analyze-self-evaluating exp))
        ((quoted? exp) (analyze-quoted exp))
        ((variable? exp) (analyze-variable exp))
        ((assignment? exp) (analyze-assignment exp))
        ((definition? exp) (analyze-definition exp))
        ((if? exp) (analyze-if exp))
        ((lambda? exp)
         (analyze-lambda exp))

        ;; ex 4.22
        ((let? exp) (my-analyze (let->combination exp)))

        ((begin? exp) (analyze-sequence (begin-actions exp)))
        ((cond? exp) (analyze (cond->if exp)))
        ((application? exp) (analyze-application exp))
        (else
         (error "Unknown expression type -- ANALYZE" exp))))

(define (my-apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           arguments
           (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure arguments))))

;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        ((eq? exp '#t) true)
        ((eq? exp '#f) true)
        (else false)))

(define (analyze-self-evaluating exp)
  (lambda (env) exp))

(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env) qval)))

(define (analyze-variable exp)
  (lambda (env) (lookup-variable-value exp env)))

(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (my-analyze (assignment-value exp))))
    (lambda (env)
      (set-variable-value! var (vproc env) env)
      'ok)))

(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (my-analyze (definition-value exp))))
;    (display vproc)
    (lambda (env)
      (define-variable! var (vproc env) env)
      'ok)))

(define (analyze-if exp)
  (let ((pproc (my-analyze (if-predicate exp)))
        (cproc (my-analyze (if-consequent exp)))
        (aproc (my-analyze (if-alternative exp))))
    (lambda (env)
      (if (true? (pproc env))
          (cproc env)
          (aproc env)))))

(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env) (make-procedure vars bproc env))))



(define (analyze-sequence exps)
  (define (sequentially proc1 proc2)
    (lambda (env) (proc1 env) (proc2 env)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map my-analyze exps)))
    (if (null? procs)
        (error "Empty sequence -- ANALYZE"))
    (loop (car procs) (cdr procs))))

;; sequentially combines every expression in the sequence
;; finally first-proc of loop procedure is combination of all expressions.
(define (utest-analyze-sequence exps)
  (define (sequentially proc1 proc2)
    (list proc1 proc2))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
  (let ((procs exps))
    (if (null? procs)
        (error "Empty sequence -- ANALYZE"))
    (loop (car procs) (cdr procs))))

;(utest-analyze-sequence '(a b c d e f))
;;guile> (((((a b) c) d) e) f)



(define (analyze-application exp)
  (let ((fproc (my-analyze (operator exp)))
        (aprocs (map my-analyze (operands exp))))
    (lambda (env)
      (execute-application (fproc env)
                           (map (lambda (aproc) (aproc env))
                                aprocs)))))

(define (execute-application proc args)
  (cond ((primitive-procedure? proc)
         (apply-primitive-procedure proc args))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment (procedure-parameters proc)
                              args
                              (procedure-environment proc))))
        (else
         (error
          "Unknown procedure type -- EXECUTE-APPLICATION"
          proc))))
         
             


; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


; compound procedure
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))


(define (compound-procedure? p)
  (tagged-list? p 'procedure))

(define (procedure-parameters p) (cadr p))
(define (procedure-body p) 
  (caddr p))
(define (procedure-environment p) (cadddr p))

; let
(define (let? exp)
  (tagged-list? exp 'let))

(define (let->combination exp)
  (let ((args (cadr exp))
        (body (cddr exp)))
    (let ((vars (map car args))
          (exps (map cadr args)))
      (cons (make-lambda vars body) exps))))
      

; environment
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

; variables
(define (make-frame variables values)
  (cons variables values))

(define (frame-variables frame) (car frame))

(define (frame-values frame) (cdr frame))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))

(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))

            ;; ex4.16.a
            ((eq? var (car vars))
             (if (eq? (car vals) '*unassigned*)
                 (error "Unbound variable" var)
                 (car vals)))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
    

; setup running environment

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))


; setup primitive procedure

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        ;; add here more primitive procedures
        (list '+ +)
        (list '* *)
        (list '- -)
        ))

(define (primitive-procedure-names)
  (map car 
       primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;----------------------------------------
;; Must call apply of native scheme implementation
;; I am using 'guile' and its apply is 'apply'
;; I changed produre names eval and apply
;; in this file into my-eval, my-apply,
;; so that they are not confused with native apply and eval.
(define apply-in-underlying-scheme apply)
;----------------------------------------


; read-eval-print loop
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (my-eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))

(define (announce-output string)
  (newline) (display string) (newline))


(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))



(define the-global-environment (setup-environment))
(driver-loop)

(let ((a 2))
  (+ a 3))
}}}


== 4.25.scm ==


{{{


(define (unless condition usual-value exception-value)
  (if condition exception-value usual-value))

(define (factorial n)
;;  (display n) (newline)
  (unless (= n 1)
          (* n (factorial (- n 1)))
          1))

(factorial 5)

;; guile> ERROR: Stack overflow
;; ABORT: (stack-overflow)
;; guile> 

;; => applicative-order
;; (factorial 5)
;; -> (unless (= 5 1) (* 5 (factorial 4)) 1)
;; -> do (* 5 (factorial 4))
;; -> do (factorial 4)
;; ...
;; (factorial 1) => (unless (= 1 1) (* 1 (factorial 0)) 1)
;; -> try to compute (factorial 0), because argument must be computed first.
;; (factorial 0) => (unless (= 0 1) (* 0 (factorial -1)) 1)
;; -> try to compute (factorial -1)
;; ...
;; try to compute (factorial n) infinitely

;; => normal-order
;; (factorial 5) => (unless (= 5 1) (* 5 (factorial 4)) 1)
;; -> try to call (factorial 4). Inside of factorial procedure is called.
;; -> (unless (= 4 1) (* 4 (factorial 3)) 1)
;; ......
;; -> try to call (factorial 1)
;; -> (unless (= 1 1) ... 1) -> return 1






}}}


== 4.26.scm ==


{{{
;----------------------------------------------------
;--------------- my-eval - my-apply------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (my-eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (my-eval (cond->if exp) env))
        ((let? exp) 
         (my-eval (let->combination exp) env))
        ((unless? exp)
         (eval-unless exp env))
        ((application? exp)
         (my-apply (my-eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (my-apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           arguments
           (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure))))

(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (my-eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (my-eval (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (my-eval (first-exp exps) env))
        (else
         (my-eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (my-eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (my-eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        ((eq? exp '#t) true)
        ((eq? exp '#f) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


; let
(define (let? exp)
  (tagged-list? exp 'let))

(define (let->combination exp)
  (let ((args (cadr exp))
        (body (cddr exp)))
    (let ((vars (map car args))
          (exps (map cadr args)))
      (cons (make-lambda vars body) exps))))
      

; compound procedure
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))

(define (compound-procedure? p)
  (tagged-list? p 'procedure))

(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))


; environment
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

; variables
(define (make-frame variables values)
  (cons variables values))

(define (frame-variables frame) (car frame))

(define (frame-values frame) (cdr frame))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))

(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
    

; setup running environment

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))


; setup primitive procedure

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        (list '+ +)
        (list '- -)
        (list '* *)
        (list '/ /)
        (list '= =)
        (list 'eq? eq?)
        ;; add here more primitive procedures
        ))

(define (primitive-procedure-names)
  (map car 
       primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;----------------------------------------
;; Must call apply of native scheme implementation
;; I am using 'guile' and its apply is 'apply'
;; I changed produre names eval and apply
;; in this file into my-eval, my-apply,
;; so that they are not confused with native apply and eval.
(define apply-in-underlying-scheme apply)
;----------------------------------------


; read-eval-print loop
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (my-eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))

(define (announce-output string)
  (newline) (display string) (newline))


(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))


;------ex4.26-----------------------------------------

;; unless is implemented as special form
(define (unless? exp)
  (tagged-list? exp 'unless))

(define (unless-predicate exp) (cadr exp))
(define (unless-consequent exp) (caddr exp))
(define (unless-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (eval-unless exp env)
  (my-eval (make-if (unless-predicate exp)
                    (unless-alternative exp)
                    (unless-consequent exp))
           env))

;---------- end of my-eval and my-apply --------------
(define the-global-environment (setup-environment))
(driver-loop)

;; test result
;; ;;; M-Eval input:
;; (define a 1)

;; ;;; M-Eval value:
;; ok

;; ;;; M-Eval input:
;; (if (= a 1) (+ a 2))

;; ;;; M-Eval value:
;; 3

;; ;;; M-Eval input:
;; (unless (= a 2) (+ a 1))

;; ;;; M-Eval value:
;; 2

;; ;;; M-Eval input:
;; (unless (= a 1) (+ a 1) (+ a 2))

;; ;;; M-Eval value:
;; 3


;; If unless is implemented as procedure,
;; unless is passed to another high-order procedure as argument.

;; (define (ho-proc predict exp true-case false-case)
;;   (if (eq? (predict exp false-case true-case) true-case)
;;       (display "PREDICT IS SUCCESSED")))

;; (define (unless condition usual-value exceptional-value)
;;   (if condition exceptional-value usual-value))

;; (ho-proc unless (= 1 1) #t #f)
}}}


== 4.27.scm ==


{{{
;----------------------------------------------------
;--------------- my-eval - my-apply------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (my-eval exp env)
  (display "my-eval->exp=") (display exp) (newline)
  (display "my-eval->env=") (display env) (newline)
  (cond ((command? exp) (special-command exp env))
        ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (my-eval (cond->if exp) env))
        ((let? exp) 
         (my-eval (let->combination exp) env))
        ((application? exp)
         (my-apply (actual-value (operator exp) env) ;; evaluated-value of operator
                   (operands exp)                    ;; expressions of operands
                   env))                             ;; need to evaluate operands
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (my-apply procedure arguments env)
  (display "my-apply->procedure=") (display procedure) (newline)
  (display "my-apply->arguments=") (display arguments) (newline)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure
          procedure                     ; procedure is evaluated at eval
          (list-of-arg-values arguments env))) ; force arguments

         ;; (display "env=>") (display env) (newline)
         ;; (display "proc=>") (display procedure) (newline)
         ;; (display "args=>") (display arguments) (newline)
         ;; (display "actual-values=>") (display (list-of-arg-values arguments env))
         ;; (display "OK?"))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           (list-of-delayed-args arguments env)
           (procedure-environment procedure))))
        
        (else
         (error "Unknown procedure type -- APPLY" procedure))))


;--- my adding for debugging ----
; (CMD env) : display env

(define (command? exp)
  (tagged-list? exp 'CMD))

(define (special-command exp env)
  (let ((cmd (cadr exp)))
    (cond ((eq? cmd 'get-env)
           (display env))
          ((eq? cmd 'get-var)
           (let ((var (caddr exp)))
             (display (lookup-variable-value var env))))
          (else
           (error "Unknown special command -- CMD" exp))))
  'ok)


(define (actual-value exp env)
  (force-it (my-eval exp env)))


(define (delay-it exp env)
  (list 'thunk exp env))


(define (evaluated-thunk? obj)
  (tagged-list? obj 'evaluated-thunk))

(define (thunk-value evaluated-thunk) (cadr evaluated-thunk))

(define (thunk-exp thunk) (cadr thunk))
(define (thunk-env thunk) (caddr thunk))

(define (thunk? obj)
  (tagged-list? obj 'thunk))

(define (force-it obj)
;  (newline) (display "FORCE=>") (display obj) (newline)
  (cond ((thunk? obj)
         (let ((result (actual-value
                        (thunk-exp obj)
                        (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj) result)
           (set-cdr! (cdr obj) '())
           result))
        ((evaluated-thunk? obj)
         (thunk-value obj))
        (else obj)))
         
                        

(define (list-of-arg-values exps env)
  (if (no-operands? exps)
      '()
      (cons (actual-value (first-operand exps) env)
            (list-of-arg-values (rest-operands exps)
                                env))))

(define (list-of-delayed-args exps env)
  (if (no-operands? exps)
      '()
      (cons (delay-it (first-operand exps) env)
            (list-of-delayed-args (rest-operands exps)
                                  env))))


;; (define (list-of-values exps env)
;;   (if (no-operands? exps)
;;       '()
;;       (cons (my-eval (first-operand exps) env)
;;             (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (actual-value (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (my-eval (first-exp exps) env))
        (else
         (my-eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (my-eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (my-eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        ((eq? exp '#t) true)
        ((eq? exp '#f) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


; let
(define (let? exp)
  (tagged-list? exp 'let))

(define (let->combination exp)
  (let ((args (cadr exp))
        (body (cddr exp)))
    (let ((vars (map car args))
          (exps (map cadr args)))
      (cons (make-lambda vars body) exps))))
      

; compound procedure
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))

(define (compound-procedure? p)
  (tagged-list? p 'procedure))

(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))


; environment
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

; variables
(define (make-frame variables values)
  (cons variables values))

(define (frame-variables frame) (car frame))

(define (frame-values frame) (cdr frame))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))

(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
    

; setup running environment

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))


; setup primitive procedure

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        (list '+ +)
        (list '- -)
        (list '* *)
        (list '/ /)
        (list '= =)
        (list 'eq? eq?)
        ;; add here more primitive procedures
        ))

(define (primitive-procedure-names)
  (map car 
       primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  ;; (display "call primitive proc=>") (display proc) (newline)
  ;; (display "actual values=>") (display args) (newline)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;----------------------------------------
;; Must call apply of native scheme implementation
;; I am using 'guile' and its apply is 'apply'
;; I changed produre names eval and apply
;; in this file into my-eval, my-apply,
;; so that they are not confused with native apply and eval.
(define apply-in-underlying-scheme apply)
;----------------------------------------


; read-eval-print loop
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")

(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (actual-value input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))

(define (announce-output string)
  (newline) (display string) (newline))


(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))

;---------- end of my-eval and my-apply --------------
(define the-global-environment (setup-environment))
(driver-loop)

(define count 0)

(define (id x)
  (set! count (+ count 1))
  x)

(define (id2 x)
  (set! count (+ count 1))
  x)

(define w2 (id (id2 10)))


;; When evaluate w2, (id (id2 10)) is evaluated. At that time, (id2 10) is delayed and marked thunk data but body of id is evaluated. In other word, the body of w2 is ((set! count (+ count 1)) (id2 10)). (id2 10) is delayed and (set! count (+ count 1)) is evaluated. Finally the body of w2 is (thunk id2 10) and count is increased by 1.
;; And when I print the value of w2, it is forced by driver-loop. Final value of count is 2.


;; actual process of evaulating w2
;; When w2 is processed by apply, body of w2, (set! count (+ count 1), is evaluated but argument (id2 10) is delayed. Final body of w2 becomes (id2 10). I can watch that count value become 1 after definition of w2.

;; ;;; M-Eval input:
;; my-eval->exp=(define w2 (id (id2 10)))
;; my-eval->env=(((id2 id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((set! count (+ count 1)) x) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=(id (id2 10))
;; my-eval->env=(((id2 id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((set! count (+ count 1)) x) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=id
;; my-eval->env=(((id2 id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((set! count (+ count 1)) x) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-apply->procedure=(procedure (x) ((set! count (+ count 1)) x) (((id2 id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((set! count (+ count 1)) x) #-6#) #-7# 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))
;; my-apply->arguments=((id2 10))
;; my-eval->exp=(set! count (+ count 1))
;; my-eval->env=(((x) (thunk (id2 10) (((id2 id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((set! count (+ count 1)) x) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((id2 id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((set! count (+ count 1)) x) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=(+ count 1)
;; my-eval->env=(((x) (thunk (id2 10) (((id2 id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((set! count (+ count 1)) x) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((id2 id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((set! count (+ count 1)) x) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=+
;; my-eval->env=(((x) (thunk (id2 10) (((id2 id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((set! count (+ count 1)) x) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((id2 id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((set! count (+ count 1)) x) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-apply->procedure=(primitive #<primitive-generic +>)
;; my-apply->arguments=(count 1)
;; my-eval->exp=count
;; my-eval->env=(((x) (thunk (id2 10) (((id2 id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((set! count (+ count 1)) x) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((id2 id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((set! count (+ count 1)) x) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=1
;; my-eval->env=(((x) (thunk (id2 10) (((id2 id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((set! count (+ count 1)) x) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((id2 id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((set! count (+ count 1)) x) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=x
;; my-eval->env=(((x) (thunk (id2 10) (((id2 id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((set! count (+ count 1)) x) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 1 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((id2 id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((set! count (+ count 1)) x) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 1 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))

;; ;;; M-Eval value:
;; ok

;; ;;; M-Eval input:

}}}


== 4.28.scm ==


{{{
;----------------------------------------------------
;--------------- my-eval - my-apply------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (my-eval exp env)
  (display "my-eval->exp=") (display exp) (newline)
  (display "my-eval->env=") (display env) (newline)
  (cond ((command? exp) (special-command exp env))
        ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (my-eval (cond->if exp) env))
        ((let? exp) 
         (my-eval (let->combination exp) env))
        ((application? exp)
         (my-apply (actual-value (operator exp) env) ;; evaluated-value of operator
                   (operands exp)                    ;; expressions of operands
                   env))                             ;; need to evaluate operands
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (my-apply procedure arguments env)
  (display "my-apply->procedure=") (display procedure) (newline)
  (display "my-apply->arguments=") (display arguments) (newline)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure
          procedure                     ; procedure is evaluated at eval
          (list-of-arg-values arguments env))) ; force arguments

         ;; (display "env=>") (display env) (newline)
         ;; (display "proc=>") (display procedure) (newline)
         ;; (display "args=>") (display arguments) (newline)
         ;; (display "actual-values=>") (display (list-of-arg-values arguments env))
         ;; (display "OK?"))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           (list-of-delayed-args arguments env)
           (procedure-environment procedure))))
        
        (else
         (error "Unknown procedure type -- APPLY" procedure))))


;--- my adding for debugging ----
; (CMD env) : display env

(define (command? exp)
  (tagged-list? exp 'CMD))

(define (special-command exp env)
  (let ((cmd (cadr exp)))
    (cond ((eq? cmd 'get-env)
           (display env))
          ((eq? cmd 'get-var)
           (let ((var (caddr exp)))
             (display (lookup-variable-value var env))))
          (else
           (error "Unknown special command -- CMD" exp))))
  'ok)


(define (actual-value exp env)
  (force-it (my-eval exp env)))


(define (delay-it exp env)
  (list 'thunk exp env))


(define (evaluated-thunk? obj)
  (tagged-list? obj 'evaluated-thunk))

(define (thunk-value evaluated-thunk) (cadr evaluated-thunk))

(define (thunk-exp thunk) (cadr thunk))
(define (thunk-env thunk) (caddr thunk))

(define (thunk? obj)
  (tagged-list? obj 'thunk))

(define (force-it obj)
;  (newline) (display "FORCE=>") (display obj) (newline)
  (cond ((thunk? obj)
         (let ((result (actual-value
                        (thunk-exp obj)
                        (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj) result)
           (set-cdr! (cdr obj) '())
           result))
        ((evaluated-thunk? obj)
         (thunk-value obj))
        (else obj)))
         
                        

(define (list-of-arg-values exps env)
  (if (no-operands? exps)
      '()
      (cons (actual-value (first-operand exps) env)
            (list-of-arg-values (rest-operands exps)
                                env))))

(define (list-of-delayed-args exps env)
  (if (no-operands? exps)
      '()
      (cons (delay-it (first-operand exps) env)
            (list-of-delayed-args (rest-operands exps)
                                  env))))


;; (define (list-of-values exps env)
;;   (if (no-operands? exps)
;;       '()
;;       (cons (my-eval (first-operand exps) env)
;;             (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (actual-value (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (my-eval (first-exp exps) env))
        (else
         (my-eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (my-eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (my-eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        ((eq? exp '#t) true)
        ((eq? exp '#f) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


; let
(define (let? exp)
  (tagged-list? exp 'let))

(define (let->combination exp)
  (let ((args (cadr exp))
        (body (cddr exp)))
    (let ((vars (map car args))
          (exps (map cadr args)))
      (cons (make-lambda vars body) exps))))
      

; compound procedure
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))

(define (compound-procedure? p)
  (tagged-list? p 'procedure))

(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))


; environment
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

; variables
(define (make-frame variables values)
  (cons variables values))

(define (frame-variables frame) (car frame))

(define (frame-values frame) (cdr frame))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))

(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
    

; setup running environment

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))


; setup primitive procedure

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        (list '+ +)
        (list '- -)
        (list '* *)
        (list '/ /)
        (list '= =)
        (list 'eq? eq?)
        ;; add here more primitive procedures
        ))

(define (primitive-procedure-names)
  (map car 
       primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  ;; (display "call primitive proc=>") (display proc) (newline)
  ;; (display "actual values=>") (display args) (newline)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;----------------------------------------
;; Must call apply of native scheme implementation
;; I am using 'guile' and its apply is 'apply'
;; I changed produre names eval and apply
;; in this file into my-eval, my-apply,
;; so that they are not confused with native apply and eval.
(define apply-in-underlying-scheme apply)
;----------------------------------------


; read-eval-print loop
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")

(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (actual-value input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))

(define (announce-output string)
  (newline) (display string) (newline))


(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))

;---------- end of my-eval and my-apply --------------
(define the-global-environment (setup-environment))
(driver-loop)


(let ((f (lambda (x) (* x x))))
  (f 2))

;; F is assigned as (thunk (lambda (x) (* x x)))
;; Therefore F should be forced to work as procedure.

;; (let ((f (lambda (x) (* x x))))
;;   (f 2))
;; my-eval->exp=(let ((f (lambda (x) (* x x)))) (f 2))
;; my-eval->env=(((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=((lambda (f) (f 2)) (lambda (x) (* x x)))
;; my-eval->env=(((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=(lambda (f) (f 2))
;; my-eval->env=(((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-apply->procedure=(procedure (f) ((f 2)) (((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))
;; my-apply->arguments=((lambda (x) (* x x)))
;; my-eval->exp=(f 2)
;; my-eval->env=(((f) (thunk (lambda (x) (* x x)) (((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=f
;; my-eval->env=(((f) (thunk (lambda (x) (* x x)) (((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=(lambda (x) (* x x))
;; my-eval->env=(((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-apply->procedure=(procedure (x) ((* x x)) (((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))
;; my-apply->arguments=(2)
;; my-eval->exp=(* x x)
;; my-eval->env=(((x) (thunk 2 (((f) (evaluated-thunk (procedure (x) ((* x x)) (((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))))) ((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=*
;; my-eval->env=(((x) (thunk 2 (((f) (evaluated-thunk (procedure (x) ((* x x)) (((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))))) ((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-apply->procedure=(primitive #<primitive-generic *>)
;; my-apply->arguments=(x x)
;; my-eval->exp=x
;; my-eval->env=(((x) (thunk 2 (((f) (evaluated-thunk (procedure (x) ((* x x)) (((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))))) ((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=2
;; my-eval->env=(((f) (evaluated-thunk (procedure (x) ((* x x)) (((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))))) ((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=x
;; my-eval->env=(((x) (evaluated-thunk 2)) ((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))

;; ;;; M-Eval value:
;; 4


}}}


== 4.29.scm ==


{{{
;----------------------------------------------------
;--------------- my-eval - my-apply------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (my-eval exp env)
  (display "my-eval->exp=") (display exp) (newline)
  (display "my-eval->env=") (display env) (newline)
  (cond ((command? exp) (special-command exp env))
        ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (my-eval (cond->if exp) env))
        ((let? exp) 
         (my-eval (let->combination exp) env))
        ((application? exp)
         (my-apply (actual-value (operator exp) env) ;; evaluated-value of operator
                   (operands exp)                    ;; expressions of operands
                   env))                             ;; need to evaluate operands
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (my-apply procedure arguments env)
  (display "my-apply->procedure=") (display procedure) (newline)
  (display "my-apply->arguments=") (display arguments) (newline)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure
          procedure                     ; procedure is evaluated at eval
          (list-of-arg-values arguments env))) ; force arguments

         ;; (display "env=>") (display env) (newline)
         ;; (display "proc=>") (display procedure) (newline)
         ;; (display "args=>") (display arguments) (newline)
         ;; (display "actual-values=>") (display (list-of-arg-values arguments env))
         ;; (display "OK?"))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           (list-of-delayed-args arguments env)
           (procedure-environment procedure))))
        
        (else
         (error "Unknown procedure type -- APPLY" procedure))))


;--- my adding for debugging ----
; (CMD env) : display env

(define (command? exp)
  (tagged-list? exp 'CMD))

(define (special-command exp env)
  (let ((cmd (cadr exp)))
    (cond ((eq? cmd 'get-env)
           (display env))
          ((eq? cmd 'get-var)
           (let ((var (caddr exp)))
             (display (lookup-variable-value var env))))
          (else
           (error "Unknown special command -- CMD" exp))))
  'ok)


(define (actual-value exp env)
  (force-it (my-eval exp env)))


(define (delay-it exp env)
  (list 'thunk exp env))


(define (evaluated-thunk? obj)
  (tagged-list? obj 'evaluated-thunk))

(define (thunk-value evaluated-thunk) (cadr evaluated-thunk))

(define (thunk-exp thunk) (cadr thunk))
(define (thunk-env thunk) (caddr thunk))

(define (thunk? obj)
  (tagged-list? obj 'thunk))

(define (force-it obj)
;  (newline) (display "FORCE=>") (display obj) (newline)
  (cond ((thunk? obj)
         (let ((result (actual-value
                        (thunk-exp obj)
                        (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj) result)
           (set-cdr! (cdr obj) '())
           result))
        ((evaluated-thunk? obj)
         (thunk-value obj))
        (else obj)))
         
                        

(define (list-of-arg-values exps env)
  (if (no-operands? exps)
      '()
      (cons (actual-value (first-operand exps) env)
            (list-of-arg-values (rest-operands exps)
                                env))))

(define (list-of-delayed-args exps env)
  (if (no-operands? exps)
      '()
      (cons (delay-it (first-operand exps) env)
            (list-of-delayed-args (rest-operands exps)
                                  env))))


;; (define (list-of-values exps env)
;;   (if (no-operands? exps)
;;       '()
;;       (cons (my-eval (first-operand exps) env)
;;             (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (actual-value (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (my-eval (first-exp exps) env))
        (else
         (my-eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (my-eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (my-eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        ((eq? exp '#t) true)
        ((eq? exp '#f) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


; let
(define (let? exp)
  (tagged-list? exp 'let))

(define (let->combination exp)
  (let ((args (cadr exp))
        (body (cddr exp)))
    (let ((vars (map car args))
          (exps (map cadr args)))
      (cons (make-lambda vars body) exps))))
      

; compound procedure
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))

(define (compound-procedure? p)
  (tagged-list? p 'procedure))

(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))


; environment
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

; variables
(define (make-frame variables values)
  (cons variables values))

(define (frame-variables frame) (car frame))

(define (frame-values frame) (cdr frame))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))

(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
    

; setup running environment

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))


; setup primitive procedure

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        (list '+ +)
        (list '- -)
        (list '* *)
        (list '/ /)
        (list '= =)
        (list 'eq? eq?)
        ;; add here more primitive procedures
        ))

(define (primitive-procedure-names)
  (map car 
       primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  ;; (display "call primitive proc=>") (display proc) (newline)
  ;; (display "actual values=>") (display args) (newline)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;----------------------------------------
;; Must call apply of native scheme implementation
;; I am using 'guile' and its apply is 'apply'
;; I changed produre names eval and apply
;; in this file into my-eval, my-apply,
;; so that they are not confused with native apply and eval.
(define apply-in-underlying-scheme apply)
;----------------------------------------


; read-eval-print loop
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")

(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (actual-value input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))

(define (announce-output string)
  (newline) (display string) (newline))


(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))

;---------- end of my-eval and my-apply --------------
(define the-global-environment (setup-environment))
(driver-loop)

(define count 0)

(define (id x)
  (set! count (+ count 1))
  x)

(define (square x)
  (* x x))

(square (id 10))

count


;; When (square (id 10)) is evaluated,
;; 1. (id 10) -> (thunk '(id 10))
;; 2. x -> (thunk '(id 10)) -> (evaluated-thunk 10), count=1
;; 3. (* x x) -> (* (evaluated-thunk 10) (evaluated-thunk 10)) -> 100


;; ;;; M-Eval input:
;; my-eval->exp=(define count 0)
;; my-eval->env=(((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=0
;; my-eval->env=(((false true car cdr cons null? + - * / = eq?) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))

;; ;;; M-Eval value:
;; ok

;; ;;; M-Eval input:
;; my-eval->exp=(define (id x) (set! count (+ count 1)) x)
;; my-eval->env=(((count false true car cdr cons null? + - * / = eq?) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=(lambda (x) (set! count (+ count 1)) x)
;; my-eval->env=(((count false true car cdr cons null? + - * / = eq?) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))

;; ;;; M-Eval value:
;; ok

;; ;;; M-Eval input:
;; my-eval->exp=(define (square x) (* x x))
;; my-eval->env=(((id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((set! count (+ count 1)) x) #-6#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=(lambda (x) (* x x))
;; my-eval->env=(((id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((set! count (+ count 1)) x) #-6#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))

;; ;;; M-Eval value:
;; ok

;; ;;; M-Eval input:
;; my-eval->exp=(square (id 10))
;; my-eval->env=(((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=square
;; my-eval->env=(((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-apply->procedure=(procedure (x) ((* x x)) (((square id count false true car cdr cons null? + - * / = eq?) #-6# (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))
;; my-apply->arguments=((id 10))
;; my-eval->exp=(* x x)
;; my-eval->env=(((x) (thunk (id 10) (((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=*
;; my-eval->env=(((x) (thunk (id 10) (((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-apply->procedure=(primitive #<primitive-generic *>)
;; my-apply->arguments=(x x)
;; my-eval->exp=x
;; my-eval->env=(((x) (thunk (id 10) (((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=(id 10)
;; my-eval->env=(((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=id
;; my-eval->env=(((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-apply->procedure=(procedure (x) ((set! count (+ count 1)) x) (((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) #-7# 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))
;; my-apply->arguments=(10)
;; my-eval->exp=(set! count (+ count 1))
;; my-eval->env=(((x) (thunk 10 (((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=(+ count 1)
;; my-eval->env=(((x) (thunk 10 (((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=+
;; my-eval->env=(((x) (thunk 10 (((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-apply->procedure=(primitive #<primitive-generic +>)
;; my-apply->arguments=(count 1)
;; my-eval->exp=count
;; my-eval->env=(((x) (thunk 10 (((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=1
;; my-eval->env=(((x) (thunk 10 (((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 0 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=x
;; my-eval->env=(((x) (thunk 10 (((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 1 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 1 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=10
;; my-eval->env=(((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 1 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=x
;; my-eval->env=(((x) (evaluated-thunk 10)) ((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 1 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))

;; ;;; M-Eval value:
;; 100

;; ;;; M-Eval input:
;; my-eval->exp=count
;; my-eval->env=(((square id count false true car cdr cons null? + - * / = eq?) (procedure (x) ((* x x)) #-6#) (procedure (x) ((set! count (+ count 1)) x) #-7#) 1 #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))

;; ;;; M-Eval value:
;; 1

;; ;;; M-Eval input:
}}}


== 4.30.scm ==


{{{
;----------------------------------------------------
;--------------- my-eval - my-apply------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (my-eval exp env)
  (display "my-eval->exp=") (display exp) (newline)
  (display "my-eval->env=") (display env) (newline)
  (cond ((command? exp) (special-command exp env))
        ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (my-eval (cond->if exp) env))
        ((let? exp) 
         (my-eval (let->combination exp) env))
        ((application? exp)
         (my-apply (actual-value (operator exp) env) ;; evaluated-value of operator
                   (operands exp)                    ;; expressions of operands
                   env))                             ;; need to evaluate operands
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (my-apply procedure arguments env)
  (display "my-apply->procedure=") (display procedure) (newline)
  (display "my-apply->arguments=") (display arguments) (newline)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure
          procedure                     ; procedure is evaluated at eval
          (list-of-arg-values arguments env))) ; force arguments

         ;; (display "env=>") (display env) (newline)
         ;; (display "proc=>") (display procedure) (newline)
         ;; (display "args=>") (display arguments) (newline)
         ;; (display "actual-values=>") (display (list-of-arg-values arguments env))
         ;; (display "OK?"))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           (list-of-delayed-args arguments env)
           (procedure-environment procedure))))
        
        (else
         (error "Unknown procedure type -- APPLY" procedure))))


;--- my adding for debugging ----
; (CMD env) : display env

(define (command? exp)
  (tagged-list? exp 'CMD))

(define (special-command exp env)
  (let ((cmd (cadr exp)))
    (cond ((eq? cmd 'get-env)
           (display env))
          ((eq? cmd 'get-var)
           (let ((var (caddr exp)))
             (display (lookup-variable-value var env))))
          (else
           (error "Unknown special command -- CMD" exp))))
  'ok)


(define (actual-value exp env)
  (force-it (my-eval exp env)))


(define (delay-it exp env)
  (list 'thunk exp env))


(define (evaluated-thunk? obj)
  (tagged-list? obj 'evaluated-thunk))

(define (thunk-value evaluated-thunk) (cadr evaluated-thunk))

(define (thunk-exp thunk) (cadr thunk))
(define (thunk-env thunk) (caddr thunk))

(define (thunk? obj)
  (tagged-list? obj 'thunk))

(define (force-it obj)
;  (newline) (display "FORCE=>") (display obj) (newline)
  (cond ((thunk? obj)
         (let ((result (actual-value
                        (thunk-exp obj)
                        (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj) result)
           (set-cdr! (cdr obj) '())
           result))
        ((evaluated-thunk? obj)
         (thunk-value obj))
        (else obj)))
         
                        

(define (list-of-arg-values exps env)
  (if (no-operands? exps)
      '()
      (cons (actual-value (first-operand exps) env)
            (list-of-arg-values (rest-operands exps)
                                env))))

(define (list-of-delayed-args exps env)
  (if (no-operands? exps)
      '()
      (cons (delay-it (first-operand exps) env)
            (list-of-delayed-args (rest-operands exps)
                                  env))))


;; (define (list-of-values exps env)
;;   (if (no-operands? exps)
;;       '()
;;       (cons (my-eval (first-operand exps) env)
;;             (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (actual-value (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))


;; original
;; (define (eval-sequence exps env)
;;   (cond ((last-exp? exps) (my-eval (first-exp exps) env))
;;         (else
;;          (my-eval (first-exp exps) env)
;;          (eval-sequence (rest-exps exps) env))))

;; Cy's proposal
(define (eval-sequence exps env)
  (cond ((last-exp? exps) (my-eval (first-exp exps) env))
        (else (actual-value (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (my-eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (my-eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        ((eq? exp '#t) true)
        ((eq? exp '#f) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


; let
(define (let? exp)
  (tagged-list? exp 'let))

(define (let->combination exp)
  (let ((args (cadr exp))
        (body (cddr exp)))
    (let ((vars (map car args))
          (exps (map cadr args)))
      (cons (make-lambda vars body) exps))))
      

; compound procedure
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))

(define (compound-procedure? p)
  (tagged-list? p 'procedure))

(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))


; environment
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

; variables
(define (make-frame variables values)
  (cons variables values))

(define (frame-variables frame) (car frame))

(define (frame-values frame) (cdr frame))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))

(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
    

; setup running environment

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))


; setup primitive procedure

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        (list '+ +)
        (list '- -)
        (list '* *)
        (list '/ /)
        (list '= =)
        (list 'eq? eq?)
        (list 'list list)
        (list 'newline newline)
        (list 'display display)
        ;; add here more primitive procedures
        ))

(define (primitive-procedure-names)
  (map car 
       primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  ;; (display "call primitive proc=>") (display proc) (newline)
  ;; (display "actual values=>") (display args) (newline)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;----------------------------------------
;; Must call apply of native scheme implementation
;; I am using 'guile' and its apply is 'apply'
;; I changed produre names eval and apply
;; in this file into my-eval, my-apply,
;; so that they are not confused with native apply and eval.
(define apply-in-underlying-scheme apply)
;----------------------------------------


; read-eval-print loop
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")

(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (actual-value input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))

(define (announce-output string)
  (newline) (display string) (newline))


(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))

;---------- end of my-eval and my-apply --------------
(define the-global-environment (setup-environment))
(driver-loop)

;; a. lambda expression (lambda (x) (newline) (display x))
;; is forced when it is called first in for-each.
;; Then every time lambda is called, it is always interpreted immediately.
;; Also at (proc (car items)), (thunk (car items)) is passed
;; into lambda. And display is primitive procedure
;; so that (car items) is always forced.
;; Therefore this example is working same to lazy interpreter
;; and normal interpreter.

(define (for-each proc items)
  (if (null? items)
      'done
      (begin (proc (car items))
             (for-each proc (cdr items)))))

(for-each (lambda (x) (newline) (display x))
          (list 12 23 34 54))


;; b.

(define (p1 x)
  (set! x (cons x '(2)))
  x)

(define (p2 x)
  (define (p e)
    e
    x)
  (p (set! x (cons x '(2)))))

(p1 1) 
(p2 1)
;; original -> Cy's
;; (1 2)    -> (1 2)
;; 1        -> (1 2)


;; c.
;; The same answer to a.


;; d.
;; p2 is very ambiguous. It does not have side-effect explicitly.
;; I think new syntax to force expression is need.

}}}


== 4.31.scm ==


{{{
;----------------------------------------------------
;--------------- my-eval - my-apply------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (my-eval exp env)
  (display "my-eval->exp=") (display exp) (newline)
  (display "my-eval->env=") (display env) (newline)
  (cond ((command? exp) (special-command exp env))
        ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (my-eval (cond->if exp) env))
        ((let? exp) 
         (my-eval (let->combination exp) env))
        ((application? exp)
         (my-apply (actual-value (operator exp) env) ;; evaluated-value of operator
                   (operands exp)                    ;; expressions of operands
                   env))                             ;; need to evaluate operands
        (else
         (error "Unknown expression type -- EVAL" exp))))


;; This solution is from
;; http://wqzhang.wordpress.com/2010/04/19/sicp-exercise-4-31/

(define (my-apply procedure arguments env)
  (display "my-apply->procedure=") (display procedure) (newline)
  (display "my-apply->arguments=") (display arguments) (newline)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure
          procedure                     ; procedure is evaluated at eval
          (list-of-arg-values arguments env))) ; force arguments
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           ;(list-of-delayed-args arguments env)
           (list-of-maybe-delayed-args
            (procedure-parameter-properties procedure)
            arguments env)
           (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure))))


;; normal argument that is without a restrictor has 'normal tag
;; lazy argument has 'simple-thunk tag
;; lazy-memo has 'thunk tag

;; For example, (define (f a (b lazy) c (d lazy-memo)) ...), (f 1 2 3 4) is applied.
;; This solution assumed that the parameter is (('normal 1) ('simple-thunk 2) ('normal 3) ('thunk 4)).
;; When list-of-maybe-delayed-args is called,
;; procedure-parameter-properties returns ('normal 'simple-thunk 'normal 'thunk).
;; Therefore return of list-of-maybe-delayed-args is (1 ('simple-thunk 2) 3 ('thunk 4)).



(define (list-of-maybe-delayed-args props exps env)
  (if (no-operands? exps)
      '()
      (cons (maybe-delay-it (car props) (first-operand exps) env)
            (list-of-maybe-delayed-args (cdr props)
                                        (rest-operands exps)
                                        env))))


(define (maybe-delay-it prop exp env)
  (cond ((eq? prop 'normal)
         (actual-value exp env)) ; find actual value
        ((eq? prop 'lazy)
         (list 'simple-thunk exp env))
        ((eq? prop 'lazy-memo)
         (list 'thunk exp env))
        (else
         (error "Unknown parameter type - MAYBE-DELAY-IT" prop))))

(define (procedure-parameters p)
  (define (extract-real-parameters x)
    (define (extract y)
      (if (pair? y)
          (car y)
          y))
    (if (null? x)
        '()
        (cons (extract (car x))
              (extract-real-parameters (cdr x)))))
  (extract-real-parameters (cadr p)))

(define (procedure-parameter-properties p)
  (define (make-property-list x)
    (define (property y)
      (if (pair? y)
          (cadr y)
          'normal))
    (if (null? x)
        '()
        (cons (property (car x))
              (make-property-list (cdr x)))))
  (make-property-list (cadr p))) ; cadr is to remove 'procedure tag in environment definition of procedure



;--- my adding for debugging ----
; (CMD get-env) : display env
; (CMD get-var <var>); display var

(define (command? exp)
  (tagged-list? exp 'CMD))

(define (special-command exp env)
  (let ((cmd (cadr exp)))
    (cond ((eq? cmd 'get-env)
           (display env))
          ((eq? cmd 'get-var)
           (let ((var (caddr exp)))
             (display (lookup-variable-value var env))))
          (else
           (error "Unknown special command -- CMD" exp))))
  'ok)


(define (actual-value exp env)
  (force-it (my-eval exp env)))


(define (delay-it exp env)
  (list 'thunk exp env))


(define (evaluated-thunk? obj)
  (tagged-list? obj 'evaluated-thunk))

(define (thunk-value evaluated-thunk) (cadr evaluated-thunk))

(define (thunk-exp thunk) (cadr thunk))
(define (thunk-env thunk) (caddr thunk))

(define (thunk? obj)
  (tagged-list? obj 'thunk))

(define (simple-thunk? obj)
  (tagged-list? obj 'simple-thunk))



;;If it has simple-thunk tag, force-it does not store forced-value.
(define (force-it obj)
  (cond ((simple-thunk? obj)
         (actual-value (thunk-exp obj) (thunk-env obj)))
        ((thunk? obj)
         (let ((result (actual-value
                        (thunk-exp obj)
                        (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj) result)
           (set-cdr! (cdr obj) '())
           result))
        ((evaluated-thunk? obj)
         (thunk-value obj))
        (else obj)))
         
                        

(define (list-of-arg-values exps env)
  (if (no-operands? exps)
      '()
      (cons (actual-value (first-operand exps) env)
            (list-of-arg-values (rest-operands exps)
                                env))))

(define (list-of-delayed-args exps env)
  (if (no-operands? exps)
      '()
      (cons (delay-it (first-operand exps) env)
            (list-of-delayed-args (rest-operands exps)
                                  env))))


(define (eval-if exp env)
  (if (true? (actual-value (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (my-eval (first-exp exps) env))
        (else
         (my-eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (my-eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (my-eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        ((eq? exp '#t) true)
        ((eq? exp '#f) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


; let
(define (let? exp)
  (tagged-list? exp 'let))

(define (let->combination exp)
  (let ((args (cadr exp))
        (body (cddr exp)))
    (let ((vars (map car args))
          (exps (map cadr args)))
      (cons (make-lambda vars body) exps))))
      

; compound procedure
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))

(define (compound-procedure? p)
  (tagged-list? p 'procedure))

;; redefined above
;;(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))


; environment
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

; variables
(define (make-frame variables values)
  (cons variables values))

(define (frame-variables frame) (car frame))

(define (frame-values frame) (cdr frame))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))

(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
    

; setup running environment

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))


; setup primitive procedure

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        (list '+ +)
        (list '- -)
        (list '* *)
        (list '/ /)
        (list '= =)
        (list 'eq? eq?)
        ;; add here more primitive procedures
        ))

(define (primitive-procedure-names)
  (map car 
       primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  ;; (display "call primitive proc=>") (display proc) (newline)
  ;; (display "actual values=>") (display args) (newline)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;----------------------------------------
;; Must call apply of native scheme implementation
;; I am using 'guile' and its apply is 'apply'
;; I changed produre names eval and apply
;; in this file into my-eval, my-apply,
;; so that they are not confused with native apply and eval.
(define apply-in-underlying-scheme apply)
;----------------------------------------


; read-eval-print loop
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")

(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (actual-value input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))

(define (announce-output string)
  (newline) (display string) (newline))


(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))

;---------- end of my-eval and my-apply --------------
(define the-global-environment (setup-environment))
(driver-loop)

;; This solution is from
;; http://wqzhang.wordpress.com/2010/04/19/sicp-exercise-4-31/


(define (f a (b lazy) c (d lazy-memo))
  (+ a b c d))

(f 1 2 3 4)


;; actual result is like following:
;; In the global env, a's value is normal 1,
;; b (simple-thunk 2), c normal 3, d (thunk 4).
;; The eval retuns forced-value of each parameters.

;; my-apply->procedure=(primitive #<primitive-generic +>)
;; my-apply->arguments=(a b c d)
;; my-eval->exp=a
;; my-eval->env=(((a b c d) 1 (simple-thunk 2 (((f false true car cdr cons null? + - * / = eq?) (procedure (a (b lazy) c (d lazy-memo)) ((+ a b c d)) #-6#) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))) 3 (thunk 4 (((f false true car cdr cons null? + - * / = eq?) (procedure (a (b lazy) c (d lazy-memo)) ((+ a b c d)) #-6#) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((f false true car cdr cons null? + - * / = eq?) (procedure (a (b lazy) c (d lazy-memo)) ((+ a b c d)) #-6#) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=b
;; my-eval->env=(((a b c d) 1 (simple-thunk 2 (((f false true car cdr cons null? + - * / = eq?) (procedure (a (b lazy) c (d lazy-memo)) ((+ a b c d)) #-6#) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))) 3 (thunk 4 (((f false true car cdr cons null? + - * / = eq?) (procedure (a (b lazy) c (d lazy-memo)) ((+ a b c d)) #-6#) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((f false true car cdr cons null? + - * / = eq?) (procedure (a (b lazy) c (d lazy-memo)) ((+ a b c d)) #-6#) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=2
;; my-eval->env=(((f false true car cdr cons null? + - * / = eq?) (procedure (a (b lazy) c (d lazy-memo)) ((+ a b c d)) #-6#) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=c
;; my-eval->env=(((a b c d) 1 (simple-thunk 2 (((f false true car cdr cons null? + - * / = eq?) (procedure (a (b lazy) c (d lazy-memo)) ((+ a b c d)) #-6#) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))) 3 (thunk 4 (((f false true car cdr cons null? + - * / = eq?) (procedure (a (b lazy) c (d lazy-memo)) ((+ a b c d)) #-6#) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((f false true car cdr cons null? + - * / = eq?) (procedure (a (b lazy) c (d lazy-memo)) ((+ a b c d)) #-6#) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=d
;; my-eval->env=(((a b c d) 1 (simple-thunk 2 (((f false true car cdr cons null? + - * / = eq?) (procedure (a (b lazy) c (d lazy-memo)) ((+ a b c d)) #-6#) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))) 3 (thunk 4 (((f false true car cdr cons null? + - * / = eq?) (procedure (a (b lazy) c (d lazy-memo)) ((+ a b c d)) #-6#) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>))))) ((f false true car cdr cons null? + - * / = eq?) (procedure (a (b lazy) c (d lazy-memo)) ((+ a b c d)) #-6#) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))
;; my-eval->exp=4
;; my-eval->env=(((f false true car cdr cons null? + - * / = eq?) (procedure (a (b lazy) c (d lazy-memo)) ((+ a b c d)) #-6#) #f #t (primitive #<primitive-procedure car>) (primitive #<primitive-procedure cdr>) (primitive #<primitive-procedure cons>) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>)))

;; ;;; M-Eval value:
;; 10

;; ;;; M-Eval input:


}}}


== 4.32.scm ==


{{{
;----------------------------------------------------
;--------------- my-eval - my-apply------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (my-eval exp env)
  ;; (display "my-eval->exp=") (display exp) (newline)
  ;; (display "my-eval->env=") (display env) (newline)
  (cond ((command? exp) (special-command exp env))
        ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (my-eval (cond->if exp) env))
        ((let? exp) 
         (my-eval (let->combination exp) env))
        ((application? exp)
         (my-apply (actual-value (operator exp) env) ;; evaluated-value of operator
                   (operands exp)                    ;; expressions of operands
                   env))                             ;; need to evaluate operands
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (my-apply procedure arguments env)
  ;; (display "my-apply->procedure=") (display procedure) (newline)
  ;; (display "my-apply->arguments=") (display arguments) (newline)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure
          procedure                     ; procedure is evaluated at eval
          (list-of-arg-values arguments env))) ; force arguments

         ;; (display "env=>") (display env) (newline)
         ;; (display "proc=>") (display procedure) (newline)
         ;; (display "args=>") (display arguments) (newline)
         ;; (display "actual-values=>") (display (list-of-arg-values arguments env))
         ;; (display "OK?"))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           (list-of-delayed-args arguments env)
           (procedure-environment procedure))))
        
        (else
         (error "Unknown procedure type -- APPLY" procedure))))


;--- my adding for debugging ----
; (CMD env) : display env

(define (command? exp)
  (tagged-list? exp 'CMD))

(define (special-command exp env)
  (let ((cmd (cadr exp)))
    (cond ((eq? cmd 'get-env)
           (display env))
          ((eq? cmd 'get-var)
           (let ((var (caddr exp)))
             (display (lookup-variable-value var env))))
          (else
           (error "Unknown special command -- CMD" exp))))
  'ok)


(define (actual-value exp env)
  (force-it (my-eval exp env)))


(define (delay-it exp env)
  (list 'thunk exp env))


(define (evaluated-thunk? obj)
  (tagged-list? obj 'evaluated-thunk))

(define (thunk-value evaluated-thunk) (cadr evaluated-thunk))

(define (thunk-exp thunk) (cadr thunk))
(define (thunk-env thunk) (caddr thunk))

(define (thunk? obj)
  (tagged-list? obj 'thunk))

(define (force-it obj)
;  (newline) (display "FORCE=>") (display obj) (newline)
  (cond ((thunk? obj)
         (let ((result (actual-value
                        (thunk-exp obj)
                        (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj) result)
           (set-cdr! (cdr obj) '())
           result))
        ((evaluated-thunk? obj)
         (thunk-value obj))
        (else obj)))
         
                        

(define (list-of-arg-values exps env)
  (if (no-operands? exps)
      '()
      (cons (actual-value (first-operand exps) env)
            (list-of-arg-values (rest-operands exps)
                                env))))

(define (list-of-delayed-args exps env)
  (if (no-operands? exps)
      '()
      (cons (delay-it (first-operand exps) env)
            (list-of-delayed-args (rest-operands exps)
                                  env))))


;; (define (list-of-values exps env)
;;   (if (no-operands? exps)
;;       '()
;;       (cons (my-eval (first-operand exps) env)
;;             (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (actual-value (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (my-eval (first-exp exps) env))
        (else
         (my-eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (my-eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (my-eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        ((eq? exp '#t) true)
        ((eq? exp '#f) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


; let
(define (let? exp)
  (tagged-list? exp 'let))

(define (let->combination exp)
  (let ((args (cadr exp))
        (body (cddr exp)))
    (let ((vars (map car args))
          (exps (map cadr args)))
      (cons (make-lambda vars body) exps))))
      

; compound procedure
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))

(define (compound-procedure? p)
  (tagged-list? p 'procedure))

(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))


; environment
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

; variables
(define (make-frame variables values)
  (cons variables values))

(define (frame-variables frame) (car frame))

(define (frame-values frame) (cdr frame))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))

(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
    

; setup running environment

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))


; setup primitive procedure

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        (list '+ +)
        (list '- -)
        (list '* *)
        (list '/ /)
        (list '= =)
        (list 'eq? eq?)
        ;; add here more primitive procedures
        ))

(define (primitive-procedure-names)
  (map car 
       primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  ;; (display "call primitive proc=>") (display proc) (newline)
  ;; (display "actual values=>") (display args) (newline)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;----------------------------------------
;; Must call apply of native scheme implementation
;; I am using 'guile' and its apply is 'apply'
;; I changed produre names eval and apply
;; in this file into my-eval, my-apply,
;; so that they are not confused with native apply and eval.
(define apply-in-underlying-scheme apply)
;----------------------------------------


; read-eval-print loop
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")

(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (actual-value input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))

(define (announce-output string)
  (newline) (display string) (newline))


(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))

;---------- end of my-eval and my-apply --------------
(define the-global-environment (setup-environment))
(driver-loop)

(define (cons x y)
  (lambda (m) (m x y)))

(define car
  (lambda (z) ; old school~
    (z (lambda (p q) p))))

(define cdr
  (lambda (z)
    (z (lambda (p q) q))))

(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))

(define (map proc items)
  (if (null? items)
      '()
      (cons (proc (car items))
            (map proc (cdr items)))))

(define (scale-list items factor)
  (map (lambda (x) (* x factor))
       items))

(define (add-lists list1 list2)
  (cond ((null? list1) list2)
        ((null? list2) list1)
        (else (cons (+ (car list1) (car list2))
                    (add-lists (cdr list1) (cdr list2))))))

(define ones (cons 1 ones))

(define integers (cons 1 (add-lists ones integers)))


(list-ref integers 17)


;; ex4.32
;; lasy list is good for integral computation, as shown in the text.

(define (integral integrand initial-value dt)
  (define int
    (cons initial-value
          (add-lists (scale-list integrand dt)
                     int)))
  int)

(define (solve f y0 dt)
  (define y (integral dy y0 dt))
  (define dy (map f y))
  y)

(list-ref (solve (lambda (x) x) 1 0.001) 10)

}}}


== 4.33.scm ==


{{{
;----------------------------------------------------
;--------------- my-eval - my-apply------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (my-eval exp env)
  (display "my-eval->exp=") (display exp) (newline)
  (display "my-eval->env=") (display env) (newline)
  (cond ((command? exp) (special-command exp env))
        ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp env))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (my-eval (cond->if exp) env))
        ((let? exp) 
         (my-eval (let->combination exp) env))
        ((application? exp)
         (my-apply (actual-value (operator exp) env) ;; evaluated-value of operator
                   (operands exp)                    ;; expressions of operands
                   env))                             ;; need to evaluate operands
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (my-apply procedure arguments env)
  ;; (display "my-apply->procedure=") (display procedure) (newline)
  ;; (display "my-apply->arguments=") (display arguments) (newline)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure
          procedure                     ; procedure is evaluated at eval
          (list-of-arg-values arguments env))) ; force arguments

         ;; (display "env=>") (display env) (newline)
         ;; (display "proc=>") (display procedure) (newline)
         ;; (display "args=>") (display arguments) (newline)
         ;; (display "actual-values=>") (display (list-of-arg-values arguments env))
         ;; (display "OK?"))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           (list-of-delayed-args arguments env)
           (procedure-environment procedure))))
        
        (else
         (error "Unknown procedure type -- APPLY" procedure))))


;--- my adding for debugging ----
; (CMD env) : display env

(define (command? exp)
  (tagged-list? exp 'CMD))

(define (special-command exp env)
  (let ((cmd (cadr exp)))
    (cond ((eq? cmd 'get-env)
           (display env))
          ((eq? cmd 'get-var)
           (let ((var (caddr exp)))
             (display (lookup-variable-value var env))))
          (else
           (error "Unknown special command -- CMD" exp))))
  'ok)


(define (actual-value exp env)
  (force-it (my-eval exp env)))


(define (delay-it exp env)
  (list 'thunk exp env))


(define (evaluated-thunk? obj)
  (tagged-list? obj 'evaluated-thunk))

(define (thunk-value evaluated-thunk) (cadr evaluated-thunk))

(define (thunk-exp thunk) (cadr thunk))
(define (thunk-env thunk) (caddr thunk))

(define (thunk? obj)
  (tagged-list? obj 'thunk))

(define (force-it obj)
;  (newline) (display "FORCE=>") (display obj) (newline)
  (cond ((thunk? obj)
         (let ((result (actual-value
                        (thunk-exp obj)
                        (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj) result)
           (set-cdr! (cdr obj) '())
           result))
        ((evaluated-thunk? obj)
         (thunk-value obj))
        (else obj)))
         
                        

(define (list-of-arg-values exps env)
  (if (no-operands? exps)
      '()
      (cons (actual-value (first-operand exps) env)
            (list-of-arg-values (rest-operands exps)
                                env))))

(define (list-of-delayed-args exps env)
  (if (no-operands? exps)
      '()
      (cons (delay-it (first-operand exps) env)
            (list-of-delayed-args (rest-operands exps)
                                  env))))


;; (define (list-of-values exps env)
;;   (if (no-operands? exps)
;;       '()
;;       (cons (my-eval (first-operand exps) env)
;;             (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (actual-value (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (my-eval (first-exp exps) env))
        (else
         (my-eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (my-eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (my-eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        ((eq? exp '#t) true)
        ((eq? exp '#f) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

;(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body


; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


; let
(define (let? exp)
  (tagged-list? exp 'let))

(define (let->combination exp)
  (let ((args (cadr exp))
        (body (cddr exp)))
    (let ((vars (map car args))
          (exps (map cadr args)))
      (cons (make-lambda vars body) exps))))
      

; compound procedure
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))

(define (compound-procedure? p)
  (tagged-list? p 'procedure))

(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))


; environment
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

; variables
(define (make-frame variables values)
  (cons variables values))

(define (frame-variables frame) (car frame))

(define (frame-values frame) (cdr frame))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))

(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
    

; setup running environment

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))


; setup primitive procedure

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        (list '+ +)
        (list '- -)
        (list '* *)
        (list '/ /)
        (list '= =)
        (list 'eq? eq?)
        (list 'cadr cadr)
        (list 'pair? pair?)
        ;; add here more primitive procedures
        ))

(define (primitive-procedure-names)
  (map car 
       primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  ;; (display "call primitive proc=>") (display proc) (newline)
  ;; (display "actual values=>") (display args) (newline)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;----------------------------------------
;; Must call apply of native scheme implementation
;; I am using 'guile' and its apply is 'apply'
;; I changed produre names eval and apply
;; in this file into my-eval, my-apply,
;; so that they are not confused with native apply and eval.
(define apply-in-underlying-scheme apply)
;----------------------------------------


; read-eval-print loop
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")

(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (actual-value input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))

(define (announce-output string)
  (newline) (display string) (newline))


(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))





;; ex 4.33
;; '(a b c) -> (cons 'a (cons 'b (cons 'c '())))
;; solution from http://wqzhang.wordpress.com/2010/04/21/sicp-exercise-4-33/

(define (text-of-quotation exp env)
  (define (body quoted-list)
    (if (pair? quoted-list)
        (my-eval (list 'cons (list 'quote (car quoted-list))
                       (list 'quote (cdr quoted-list)))
                 env)
        quoted-list))
  (body (cadr exp)))


;---------- end of my-eval and my-apply --------------
(define the-global-environment (setup-environment))
(driver-loop)

(define (cons x y)
  (lambda (m) (m x y)))

(define car
  (lambda (z) ; old school~
    (z (lambda (p q) p))))

(define cdr
  (lambda (z)
    (z (lambda (p q) q))))


(define ddd '(a b c))

;; get value of '(a b c)
;;(CMD get-var ddd)
;;(procedure (m) ((m x y)) (((x y) (thunk (quote a) (((ddd false true car cdr cons null? + - * / = eq? cadr pair?) #-12# #f #t (procedure (z) ((z (lambda (p q) p))) #-9#) (procedure (z) ((z (lambda (p q) q))) #-10#) (procedure (x y) ((lambda (m) (m x y))) #-11#) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>) (primitive #<primitive-procedure cadr>) (primitive #<primitive-procedure pair?>)))) (thunk (quote (b c)) (((ddd false true car cdr cons null? + - * / = eq? cadr pair?) #-13# #f #t (procedure (z) ((z (lambda (p q) p))) #-9#) (procedure (z) ((z (lambda (p q) q))) #-10#) (procedure (x y) ((lambda (m) (m x y))) #-11#) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>) (primitive #<primitive-procedure cadr>) (primitive #<primitive-procedure pair?>))))) ((ddd false true car cdr cons null? + - * / = eq? cadr pair?) #-7# #f #t (procedure (z) ((z (lambda (p q) p))) #-9#) (procedure (z) ((z (lambda (p q) q))) #-10#) (procedure (x y) ((lambda (m) (m x y))) #-11#) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>) (primitive #<primitive-procedure cadr>) (primitive #<primitive-procedure pair?>))))

;; x -> (thunk (quote a) ...)
;; y -> (thunk (quote (b c)) ...)

;; (car ddd) just return (thunk (quote a))
(car ddd)
;; result = a



(cdr ddd)
;; (cdr ddd) is
;; -> (quote (b c)
;; -> (eval (list cons 'quote b) (list 'quote (c)))
;; -> (x y) (thunk (quote b) ...) (thunk (quote (c)) ...)

;; result is

;;my-eval->exp=(lambda (m) (m x y))
;;my-eval->env=(((x y) (thunk (quote b) (((ddd false true car cdr cons null? + - * / = eq? cadr pair?) (procedure (m) ((m x y)) (((x y) (evaluated-thunk a) (thunk (quote (b c)) #-13#)) . #-7#)) #f #t (procedure (z) ((z (lambda (p q) p))) #-9#) (procedure (z) ((z (lambda (p q) q))) #-10#) (procedure (x y) ((lambda (m) (m x y))) #-11#) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>) (primitive #<primitive-procedure cadr>) (primitive #<primitive-procedure pair?>)))) (thunk (quote (c)) (((ddd false true car cdr cons null? + - * / = eq? cadr pair?) (procedure (m) ((m x y)) (((x y) (evaluated-thunk a) (thunk (quote (b c)) #-13#)) . #-7#)) #f #t (procedure (z) ((z (lambda (p q) p))) #-9#) (procedure (z) ((z (lambda (p q) q))) #-10#) (procedure (x y) ((lambda (m) (m x y))) #-11#) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>) (primitive #<primitive-procedure cadr>) (primitive #<primitive-procedure pair?>))))) ((ddd false true car cdr cons null? + - * / = eq? cadr pair?) (procedure (m) ((m x y)) (((x y) (evaluated-thunk a) (thunk (quote (b c)) #-13#)) . #-7#)) #f #t (procedure (z) ((z (lambda (p q) p))) #-9#) (procedure (z) ((z (lambda (p q) q))) #-10#) (procedure (x y) ((lambda (m) (m x y))) #-11#) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>) (primitive #<primitive-procedure cadr>) (primitive #<primitive-procedure pair?>)))
;;; M-Eval value:
;; (compound-procedure (m) ((m x y)) <procedure-env>)


(car (cdr ddd))

;; result is

;; my-eval->exp=x
;; my-eval->env=(((m) (evaluated-thunk (procedure (p q) (p) (((z) (evaluated-thunk (procedure (m) ((m x y)) (((x y) (thunk (quote b) (((ddd false true car cdr cons null? + - * / = eq? cadr pair?) (procedure (m) ((m x y)) (((x y) (evaluated-thunk a) (evaluated-thunk #-22#)) . #-7#)) #f #t (procedure (z) ((z (lambda (p q) p))) #-9#) (procedure (z) ((z (lambda (p q) q))) #-10#) (procedure (x y) ((lambda (m) (m x y))) #-11#) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>) (primitive #<primitive-procedure cadr>) (primitive #<primitive-procedure pair?>)))) (thunk (quote (c)) (((ddd false true car cdr cons null? + - * / = eq? cadr pair?) (procedure (m) ((m x y)) (((x y) (evaluated-thunk a) (evaluated-thunk #-23#)) . #-7#)) #f #t (procedure (z) ((z (lambda (p q) p))) #-9#) (procedure (z) ((z (lambda (p q) q))) #-10#) (procedure (x y) ((lambda (m) (m x y))) #-11#) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>) (primitive #<primitive-procedure cadr>) (primitive #<primitive-procedure pair?>))))) ((ddd false true car cdr cons null? + - * / = eq? cadr pair?) (procedure (m) ((m x y)) (((x y) (evaluated-thunk a) (evaluated-thunk #-17#)) . #-7#)) #f #t (procedure (z) ((z (lambda (p q) p))) #-9#) (procedure (z) ((z (lambda (p q) q))) #-10#) (procedure (x y) ((lambda (m) (m x y))) #-11#) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>) (primitive #<primitive-procedure cadr>) (primitive #<primitive-procedure pair?>)))))) ((ddd false true car cdr cons null? + - * / = eq? cadr pair?) (procedure (m) ((m x y)) (((x y) (evaluated-thunk a) (evaluated-thunk (procedure (m) ((m x y)) (((x y) (thunk (quote b) #-22#) (thunk (quote (c)) #-23#)) . #-17#)))) . #-7#)) #f #t (procedure (z) ((z (lambda (p q) p))) #-9#) (procedure (z) ((z (lambda (p q) q))) #-10#) (procedure (x y) ((lambda (m) (m x y))) #-11#) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>) (primitive #<primitive-procedure cadr>) (primitive #<primitive-procedure pair?>)))))) ((x y) (thunk (quote b) (((ddd false true car cdr cons null? + - * / = eq? cadr pair?) (procedure (m) ((m x y)) (((x y) (evaluated-thunk a) (evaluated-thunk (procedure (m) ((m x y)) #-22#))) . #-7#)) #f #t (procedure (z) ((z (lambda (p q) p))) #-9#) (procedure (z) ((z (lambda (p q) q))) #-10#) (procedure (x y) ((lambda (m) (m x y))) #-11#) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>) (primitive #<primitive-procedure cadr>) (primitive #<primitive-procedure pair?>)))) (thunk (quote (c)) (((ddd false true car cdr cons null? + - * / = eq? cadr pair?) (procedure (m) ((m x y)) (((x y) (evaluated-thunk a) (evaluated-thunk (procedure (m) ((m x y)) #-23#))) . #-7#)) #f #t (procedure (z) ((z (lambda (p q) p))) #-9#) (procedure (z) ((z (lambda (p q) q))) #-10#) (procedure (x y) ((lambda (m) (m x y))) #-11#) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>) (primitive #<primitive-procedure cadr>) (primitive #<primitive-procedure pair?>))))) ((ddd false true car cdr cons null? + - * / = eq? cadr pair?) (procedure (m) ((m x y)) (((x y) (evaluated-thunk a) (evaluated-thunk (procedure (m) ((m x y)) #-17#))) . #-7#)) #f #t (procedure (z) ((z (lambda (p q) p))) #-9#) (procedure (z) ((z (lambda (p q) q))) #-10#) (procedure (x y) ((lambda (m) (m x y))) #-11#) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>) (primitive #<primitive-procedure cadr>) (primitive #<primitive-procedure pair?>)))
;; my-eval->exp=(quote b)
;; my-eval->env=(((ddd false true car cdr cons null? + - * / = eq? cadr pair?) (procedure (m) ((m x y)) (((x y) (evaluated-thunk a) (evaluated-thunk (procedure (m) ((m x y)) (((x y) (thunk (quote b) #-22#) (thunk (quote (c)) #-23#)) . #-17#)))) . #-7#)) #f #t (procedure (z) ((z (lambda (p q) p))) #-9#) (procedure (z) ((z (lambda (p q) q))) #-10#) (procedure (x y) ((lambda (m) (m x y))) #-11#) (primitive #<primitive-procedure null?>) (primitive #<primitive-generic +>) (primitive #<primitive-generic ->) (primitive #<primitive-generic *>) (primitive #<primitive-generic />) (primitive #<primitive-generic =>) (primitive #<primitive-procedure eq?>) (primitive #<primitive-procedure cadr>) (primitive #<primitive-procedure pair?>)))

;; ;;; M-Eval value:
;; b

;; ;;; M-Eval input:

}}}


== 4.34.scm ==


{{{
;----------------------------------------------------
;--------------- my-eval - my-apply------------------

(define true #t)
(define false #f)
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))

(define (my-eval exp env)
  ;; (display "my-eval->exp=") (display exp) (newline)
  ;; (display "my-eval->env=") (display env) (newline)
  (cond ((command? exp) (special-command exp env))
        ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))

        ;; ex4.34
        ;; add syntax define-infinite
        ((definition-infinite? exp) (eval-definition-infinite exp env))

        
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (my-eval (cond->if exp) env))
        ((let? exp) 
         (my-eval (let->combination exp) env))
        ((application? exp)
         (my-apply (actual-value (operator exp) env) ;; evaluated-value of operator
                   (operands exp)                    ;; expressions of operands
                   env))                             ;; need to evaluate operands
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (my-apply procedure arguments env)
  ;; (display "my-apply->procedure=") (display procedure) (newline)
  ;; (display "my-apply->arguments=") (display arguments) (newline)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure
          procedure                     ; procedure is evaluated at eval
          (list-of-arg-values arguments env))) ; force arguments
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           (list-of-delayed-args arguments env)
           (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure))))


;--- my adding for debugging ----
; (CMD env) : display env

(define (command? exp)
  (tagged-list? exp 'CMD))

(define (special-command exp env)
  (let ((cmd (cadr exp)))
    (cond ((eq? cmd 'get-env)
           (display env))
          ((eq? cmd 'get-var)
           (let ((var (caddr exp)))
             (display (lookup-variable-value var env))))
          (else
           (error "Unknown special command -- CMD" exp))))
  'ok)

(define (delay-it exp env)
  (list 'thunk exp env))


(define (evaluated-thunk? obj)
  (tagged-list? obj 'evaluated-thunk))

(define (thunk-value evaluated-thunk) (cadr evaluated-thunk))

(define (thunk-exp thunk) (cadr thunk))
(define (thunk-env thunk) (caddr thunk))

(define (thunk? obj)
  (tagged-list? obj 'thunk))



;; ex4.34 - add env to force-it
(define (actual-value exp env)
  (force-it (my-eval exp env)))

;; ex4.34 add env argument
(define (force-it obj)
;;  (newline) (display "FORCE=>") (display obj) (newline)
  (cond ((thunk? obj)
         (let ((result (actual-value
                        (thunk-exp obj)
                        (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj) result)
           (set-cdr! (cdr obj) '())
           result))
        ((evaluated-thunk? obj)
         (thunk-value obj))
        (else obj)))
         

(define (list-of-arg-values exps env)
  (if (no-operands? exps)
      '()
      (cons (actual-value (first-operand exps) env)
            (list-of-arg-values (rest-operands exps)
                                env))))

(define (list-of-delayed-args exps env)
  (if (no-operands? exps)
      '()
      (cons (delay-it (first-operand exps) env)
            (list-of-delayed-args (rest-operands exps)
                                  env))))


;; (define (list-of-values exps env)
;;   (if (no-operands? exps)
;;       '()
;;       (cons (my-eval (first-operand exps) env)
;;             (list-of-values (rest-operands exps) env))))

(define (eval-if exp env)
  (if (true? (actual-value (if-predicate exp) env))
      (my-eval (if-consequent exp) env)
      (my-eval (if-alternative exp) env)))


(define (eval-sequence exps env)
  (cond ((last-exp? exps) (my-eval (first-exp exps) env))
        (else
         (my-eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))

(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (my-eval (assignment-value exp) env)
                      env)
  'ok)

(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (my-eval (definition-value exp) env)
                    env)
  'ok)


;--------------- grammar ------------------
      
; string, number
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        ((eq? exp '#t) true)
        ((eq? exp '#f) true)
        (else false)))

; variable
(define (variable? exp) (symbol? exp))

; quoted expression
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp) (cadr exp))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      #f))
;; Every expression is passed as quoted form like '(*).
;; Therefore quoted expression is interpreted like followings.
;; '('a)
;; ((quote a))
;; (car '('a))
;; (quote a)

; assignment: (set! <var> <value>)
(define (assignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


; definition
; 1. (define <var> <value>)
; 2. (define (<var> <parameter1> ...) <body>)
; 2'. (define <var>
;      (lambda <parameter1> ...)
;       <body>))
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)  ; parameter
                   (cddr exp)))) ; body



; lambda expression
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))

(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


; if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


; begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

; combine sequential expression into one begin expression
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq)) ; single expression
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        ; else로 시작하는지만 확인해서 아니면 if를 만든다.
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error ("ELSE cluase isn't last -- COND->IF" clauses)))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


; let
(define (let? exp)
  (tagged-list? exp 'let))

(define (let->combination exp)
  (let ((args (cadr exp))
        (body (cddr exp)))
    (let ((vars (map car args))
          (exps (map cadr args)))
      (cons (make-lambda vars body) exps))))
      

; compound procedure
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))

(define (compound-procedure? p)
  (tagged-list? p 'procedure))

(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))


; environment
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

; variables
(define (make-frame variables values)
  (cons variables values))

(define (frame-variables frame) (car frame))

(define (frame-values frame) (cdr frame))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))

(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
    

; setup running environment

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))


; setup primitive procedure

(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc) (cadr proc))

(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        (list '+ +)
        (list '- -)
        (list '* *)
        (list '/ /)
        (list '= =)
        (list 'eq? eq?)
        ;; add here more primitive procedures
        ))

(define (primitive-procedure-names)
  (map car 
       primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

(define (apply-primitive-procedure proc args)
  ;; (display "call primitive proc=>") (display proc) (newline)
  ;; (display "actual values=>") (display args) (newline)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;----------------------------------------
;; Must call apply of native scheme implementation
;; I am using 'guile' and its apply is 'apply'
;; I changed produre names eval and apply
;; in this file into my-eval, my-apply,
;; so that they are not confused with native apply and eval.
(define apply-in-underlying-scheme apply)
;----------------------------------------


; read-eval-print loop
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")

(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (actual-value input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))

(define (announce-output string)
  (newline) (display string) (newline))


(define (user-print object)
  (cond ((compound-procedure? object)
         (display (list 'compound-procedure
                        (procedure-parameters object)
                        (procedure-body object)
                        '<procedure-env>)))
        ((infinite-list? object)
         (display (list 'INFINITE (cdr object))))
        (else (display object))))


(define (infinite-list? object)
  (tagged-list? object 'infinite-list))
  


;; ex4.34
(define (eval-definition-infinite exp env)
  (define-variable!
    (definition-variable-infinite exp)
    (cons 'infinite-list (definition-value-infinite exp))
    env)
  'ok)

;; ex4.34
(define (definition-infinite? exp)
  (tagged-list? exp 'define-infinite))

(define (definition-variable-infinite exp)
  (cadr exp))

(define (definition-value-infinite exp)
  (caddr exp))




;---------- end of my-eval and my-apply --------------
(define the-global-environment (setup-environment))
(driver-loop)

(define (cons x y)
  (lambda (m) (m x y)))

(define car
  (lambda (z) ; old school~
    (z (lambda (p q) p))))

(define cdr
  (lambda (z)
    (z (lambda (p q) q))))

(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))

(define (map proc items)
  (if (null? items)
      '()
      (cons (proc (car items))
            (map proc (cdr items)))))

(define (scale-list items factor)
  (map (lambda (x) (* x factor))
       items))

(define (add-lists list1 list2)
  (cond ((null? list1) list2)
        ((null? list2) list1)
        (else (cons (+ (car list1) (car list2))
                    (add-lists (cdr list1) (cdr list2))))))

(define-infinite ones (cons 1 ones))

(define-infinite integers (cons 1 (add-lists ones integers)))



;; I can print the body of infinite-list.
;; But I don't know how to print the actual value of infinite-list.

;; ;;; M-Eval input:
;; ones

;; ;;; M-Eval value:
;; (INFINITE (cons 1 ones))

;; ;;; M-Eval input:
;; (car ones)

;; Backtrace:
;; In standard input:
;; 2667: 0* [driver-loop]
;; 2620: 1  [driver-loop]
;;    ...
;; 2620: 2  [driver-loop]
;; 2616: 3* (let* ((input #)) (let* (#) (announce-output output-prompt) ...))
;; 2617: 4  (let* ((output #)) (announce-output output-prompt) (user-print output))
;; 2617: 5* [actual-value (car ones) ((# # # # ...))]
;; 2269: 6  [force-it ...
;; 2269: 7*  [my-eval (car ones) ((# # # # ...))]
;; 2186: 8   (cond (# #) (# exp) (# #) ...)
;;     ...
;; 2230: 9   [error "Unknown procedure type -- APPLY" (infinite-list cons 1 ones)]

;; standard input:2230:10: In procedure error in expression (error "Unknown procedure type -- APPLY" procedure):
;; standard input:2230:10: Unknown procedure type -- APPLY (infinite-list cons 1 ones)
;; ABORT: (misc-error)
;; guile> guile> 

}}}


== 4.55.scm ==


{{{



a. (supervisor ?name (Ben Bitdiddle))
b. (job ?name (accounting . ?do))
c. (address ?name (Slumverville . ?where))

b and c should be expressed with dotted-tail expression.
}}}


== 4.56.scm ==


{{{


a. (and (supervisor ?name (Bitdiddle Ben))
        (address ?name ?where))

b. (and (salary (Bitdiddle Ben) ?Ben-amount)
        (salary ?name ?amount)
        (lisp-value > ?amount ?Ben-amount))

c. (and (supervisor ?target-name ?super-name)
        (not (job ?super-name (computer . ?type)))
        (job ?super-name ?do))


}}}


== 4.57.scm ==


{{{




(rule (can-replace ?p1 ?p2)
      (and (or (and (job ?p1 ?job1)
                    (job ?p2 ?job2)
                    (same ?job1 job2))
               (can-do-job ?job1 ?job2))
           (not (same ?p1 ?p2))))


a.
(can-replace ?person (Cy D. Fect))

b.

(and (can-replace ?person ?high-salary-person)
     (salary ?high-salary-person ?high-salary)
     (salary ?person ?salary)
     (lisp-value > ?high-salary ?salary))
}}}


== 4.58.scm ==


{{{



(rule (big-shot ?person)
      (or (and (supervisor ?person ?boss)
               (lisp-value null? ?boss))
          (and (supervisor ?person ?boss)
               (job ?person ?my-job)
               (job ?boss ?boss-job)
               (not (same ?boss-job ?my-job)))))



}}}


== 4.59.scm ==


{{{



a.
(meeting ?division (Friday ?time))


b.
(rule (meeting-time ?person ?day-and-time)
      (or (and (job ?person (?division .?))
               (meeting ?division ?day-and-time))
          (meeting whole-company ?day-and-time)))



                    
c.
(meeting-time (Hacker Alyssa P) (Wednesday ?time))
}}}


== 4.60.scm ==


{{{


I can change the code, (not (same ?person-1 ?person-2)), into another checking code:
for example lexicographic order checking.


}}}


== 4.61.scm ==


{{{



(?x next-to ?y in (1 (2 3) 4))

?x = 1, ?y = (2 3)
?x = (1 2), ?y = 4

(?x next-to 1 in (2 1 3 1))

?x = 2
?x = 3 -> right of the middle 1
?x = 3 -> left of the most right 1
}}}


== 4.62.scm ==


{{{

;; (define (last-pair lst)
;;   (if (null? (cdr lst))
;;       lst  --------------------> (1)
;;       (last-pair (cdr lst)))) -> (2)

;; (1)
(rule (last-pair (?z) (?z)))

;; (2)
(rule (last-pair (?y . ?x) ?z)
      (last-pair (?x) ?z))


;;http://d.hatena.ne.jp/rsakamot/20090707/1246973376
(assert! (rule (last-pair (?x . ()) (?x))))  ;rule1
(assert! (rule (last-pair (?x . ?y) ?z)      ;rule2
               (last-pair ?y ?z)))

;;내가 한거랑 일본사람이한거랑 어느게 맞나?
;;아래는 일본사람 테스트 결과
;; ;;; Query input:
;; (last-pair (3) ?x)
;; ;;; Query results:
;; (last-pair (3) (3))

;; ;;; Query input:
;; (last-pair (1 2 3) ?x)
;; ;;; Query results:
;; (last-pair (1 2 3) (3))

;; ;;; Query input:
;; (last-pair (2 ?x) (3))
;; ;;; Query results:
;; (last-pair (2 3) (3))

;; ;;; Query input:
;; (last-pair ?x (3))
}}}


== 4.63.scm ==


{{{


(rule (grand-son ?G ?S)
      (and (son ?F ?S)
           (son ?G ?F)))

(rule (son ?M ?S)
      (and (wife ?M ?W)
           (son ?W ?S)))


;; (son Adam Cain)  
;; (son Cain Enoch)  
;; (son Enoch Irad)  
;; (son Irad Mehujael)  
;; (son Mehujael Methushael)  
;; (son Methushael Lamech)  
;; (wife Lamech Ada)  
;; (son Ada Jabal)  
;; (son Ada Jubal)  
}}}


== 4.64.scm ==


{{{

(outranked-by Ben ?boss) ==>

(or (supervisor Ben Oliver) -> find Oliver
    (and (outranked-by ?middle-manager Oliver) -> outranked-by is called AGAIN
         (...)))

(outranked-by ?staff-person Oliver) ==>

(or (supervisor ?staff-person Oliver)   -> ?staff-person can have many choices
    (and (outranked-by ?middle-manager Oliver) -> outranked-by is called AGAIN
         (...)))

(outranked-by ?staff-person Oliver) ==>

(or (supervisor ?staff-person Oliver)
    (and (outranked-by ?middle-manager Oliver) -> outranked-by is called AGAIN
         (...)))

RESULT> (outranked-by ?staff-person Oliver) is repeated.
}}}


== 4.65.scm ==


{{{

Answer of (wheel ?who) will be followings:
(and (supervisor (Scrooge Eben) (Warbucks Oliver)) (supervisor (Cratchet Robert) (Scrooge Eben)))  
(and (supervisor (Bitdiddle Ben) (Warbucks Oliver)) (supervisor (Tweakit Lem E) (Bitdiddle Ben)))  
(and (supervisor (Hacker Alyssa P) (Bitdiddle Ben)) (supervisor (Reasoner Louis) (Hacker Alyssa P)))  
(and (supervisor (Bitdiddle Ben) (Warbucks Oliver)) (supervisor (Fect Cy D) (Bitdiddle Ben)))  
(and (supervisor (Bitdiddle Ben) (Warbucks Oliver)) (supervisor (Hacker Alyssa P) (Bitdiddle Ben)))

Therefore Oliver will be shown 4-times.
}}}


== 4.66.scm ==


{{{


According to the query pattern, the same result can be returned repeatly like wheel query of ex4.65.
We needs an extra procedure to check the frame list and remove repeated frames.

}}}


